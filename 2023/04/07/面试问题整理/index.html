<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试知识点整理 | YYM‘s Blog</title><meta name="keywords" content="面试整理"><meta name="author" content="杨译茗"><meta name="copyright" content="杨译茗"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA jdk1.8新特性   Lamda表达式 原先比较大小： 1234567List&lt;String&gt; names &#x3D; Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);Collections.sort(names, new Comparator&lt;St">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识点整理">
<meta property="og:url" content="https://boomboom-yang.github.io/2023/04/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="YYM‘s Blog">
<meta property="og:description" content="JAVA jdk1.8新特性   Lamda表达式 原先比较大小： 1234567List&lt;String&gt; names &#x3D; Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);Collections.sort(names, new Comparator&lt;St">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg">
<meta property="article:published_time" content="2023-04-06T16:35:18.000Z">
<meta property="article:modified_time" content="2023-04-13T16:29:01.819Z">
<meta property="article:author" content="杨译茗">
<meta property="article:tag" content="面试整理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg"><link rel="shortcut icon" href="https://i.loli.net/2021/05/22/yRLpfi8dHGJktEc.png"><link rel="canonical" href="https://boomboom-yang.github.io/2023/04/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?df75c0fdf4d51c6436007e2cf0312f5c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试知识点整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-14 00:29:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet"href="/css/icon.css"media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/05/22/2KPMBkSoU3ahebr.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-dragon"></i><span> 电影</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-spider"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YYM‘s Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-dragon"></i><span> 电影</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-spider"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试知识点整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-06T16:35:18.000Z" title="发表于 2023-04-07 00:35:18">2023-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-13T16:29:01.819Z" title="更新于 2023-04-14 00:29:01">2023-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0-JAVA-%E9%9D%A2%E8%AF%95/">-学习 -JAVA -面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">69.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>236分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试知识点整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>JAVA</h1>
<h2 id="jdk1-8新特性">jdk1.8新特性</h2>
<ol>
<li>
<p>Lamda表达式</p>
<p>原先比较大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>新做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简短</span></span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简短</span></span><br><span class="line"><span class="comment">//Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型</span></span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">Runnable r2 = () -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">r2.run();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">Consumer&lt;String&gt; con1 = (String s) -&gt; System.out.println(s);</span><br><span class="line">con1.accept(<span class="string">&quot;世上无难事，只怕有心人！&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">Consumer&lt;String&gt; con2 = (s) -&gt; System.out.println(s);</span><br><span class="line">con2.accept(<span class="string">&quot;世上无难事，只怕有心人！&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">Consumer&lt;String&gt; con3 = s -&gt; System.out.println(s);</span><br><span class="line">con3.accept(<span class="string">&quot;世上无难事，只怕有心人！&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(o2);</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(com2.compare(<span class="number">12</span>, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">System.out.println(com3.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Stream</p>
</li>
<li>
<p>Hashmap底层变为红黑树以及新的扩容机制</p>
</li>
<li>
<p>方法与构造函数引用</p>
<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用</p>
<p>传递方法：</p>
<p><strong>对象::实例方法名</strong></p>
<p><strong>类::静态方法名</strong></p>
<p><strong>类::实例方法名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line">PrintStream ps = System.out;</span><br><span class="line">Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">System.out.println(com2.compare(<span class="number">12</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class="line"><span class="comment">//注意：当函数式接口方法的第一个参数是需要引用方法的调用者，</span></span><br><span class="line"><span class="comment">//并且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName</span></span><br><span class="line"><span class="comment">// String中的 int t1.compareTo(t2)</span></span><br><span class="line">Comparator&lt;String&gt; com3 = String::compareTo;</span><br><span class="line">System.out.println(com3.compare(<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;abm&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">BiPredicate&lt;String, String&gt; pre2 = String::equals;</span><br><span class="line">System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名： &quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;、年龄： &quot;</span>+<span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFunction</span>&lt;<span class="title">A</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">crt</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFunction&lt;Person&gt; fun = Person::<span class="keyword">new</span>;    <span class="comment">//Person类构造方法的引用传递</span></span><br><span class="line">        System.out.println(fun.crt(<span class="string">&quot;小明&quot;</span>,<span class="number">15</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="8大基本类型">8大基本类型</h2>
<p><img src="https://s2.loli.net/2023/03/24/sxrmijaOCdc6oI7.png" alt="image-20230324162753360"></p>
<p><img src="https://s2.loli.net/2023/03/27/VrEDFKQqUpPb75a.png" alt="image-20230327231307702"></p>
<p><strong>注：封装类是引用类型</strong></p>
<h2 id="面向对象和面向过程的区别">面向对象和面向过程的区别</h2>
<p>面向过程：是分析解决问题的步骤，然后用函数把步骤一步一步的实现，在使用的时候一一调用即可，性能更高，比如单片机，嵌入式开发</p>
<p>面向对象：将问题分解成各个对象，对象是为了描述某个事物在解决整个问题的过程中所发生的行为，面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统，并且复用性强以及方便维护， 但是性能上来说，比面向过程要低。</p>
<h2 id="接口和抽象类的区别">接口和抽象类的区别</h2>
<p>接口：USB、耳机孔</p>
<p>抽象类：动物之于猫、狗</p>
<ol>
<li>**定义方式不同：**接口(interface)是一种纯粹的抽象类，只定义方法的签名，而没有方法的实现。抽象类(abstract class)是一种抽象的类，可以包含方法的实现。</li>
<li>**实现方式不同：**一个类可以实现多个接口，但只能继承一个抽象类（单继承）。</li>
<li><strong>作用不同：<strong>接口的主要作用是</strong>定义一组规范</strong>，让实现类去实现；抽象类则是<strong>为了提供一些通用的实现</strong>，让子类去扩展或重写。</li>
<li>**成员变量不同：**接口中不能定义成员变量，而抽象类可以定义成员变量。</li>
<li><strong>接口方法默认为public，抽象类可有别的：<strong>接口中的所有方法都默认为public，而</strong>抽象类中的方法可以有不同的访问修饰符</strong>。</li>
<li>**构造方法不同：**接口没有构造方法，而抽象类可以有构造方法。</li>
</ol>
<p>使用场景不同：</p>
<p><strong>抽象类用于定义一些通用的方法和属性</strong>，它们的子类可以实现这些方法和属性，并且可以添加自己的特定实现。抽象类通常用于类之间的继承关系，它们可以用来实现<strong>模板方法模式和策略模式</strong>等设计模式。</p>
<p><strong>接口用于定义一些通用的行为和功能</strong>，它们的实现类必须实现这些行为和功能，但是实现方式可以不同。接口通常用于类之间的解耦和代码重用，它们可以用来实现<strong>适配器模式和观察者模式</strong>等设计模式。</p>
<p><strong>总的来说，抽象类更多的是一种结构化的设计方式，而接口更多的是一种契约式的设计方式。</strong></p>
<h2 id="装箱与拆箱">装箱与拆箱</h2>
<ul>
<li>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的<strong>valueOf(int)</strong> 方法</li>
<li>拆箱就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）；调用方法：Integer的<strong>intValue</strong>方法</li>
</ul>
<p>POJO类强制使用包装类型</p>
<h2 id="Integer缓存是放在哪里的">Integer缓存是放在哪里的</h2>
<p>在Java中，对于Integer对象，JVM会缓存一定范围内的整数对象，这些对象被缓存在<strong>静态内部类IntegerCache</strong>中。具体来说，JVM缓存了-128到127之间的整数对象。</p>
<p>当Java程序使用自动装箱将一个int值转换为Integer对象时，如果该值在-128到127之间，JVM会直接从IntegerCache中取出已经缓存的Integer对象，而不是新创建一个对象。</p>
<h2 id="final">final</h2>
<p>修饰对象：则对象的引用地址不可变，里面的属性和值可以变</p>
<h2 id="String的不可变性">String的不可变性</h2>
<h3 id="原理">原理</h3>
<ol>
<li>
<p>String类由final修饰，所以不能被继承</p>
</li>
<li>
<p>Java 9之前字符串采用char[]数组来保存字符，即 <code>private final char[] value ；</code></p>
<p>Java 9做了改进，采用byte[]数组来保存字符，即 <code>private final byte[] value ；</code></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/11/A65w3symEjOIbWZ.png" alt="image-20230311151509558"></p>
<h3 id="好处：">好处：</h3>
<ol>
<li>
<p><strong>防止被篡改，保证信息数据的安全性</strong></p>
<p>如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作</p>
</li>
<li>
<p><strong>不变的对象和值是线程安全的</strong></p>
<p>由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作</p>
</li>
<li>
<p><strong>哈希值的唯一性来挺好性能</strong></p>
<p>由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于String 的不可变，避免重复计算 hashcode ，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能</p>
</li>
<li>
<p><strong>提高常量池的可用性</strong></p>
<p>字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 <code>String.intern() </code>方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存</p>
</li>
</ol>
<h2 id="创建对象的方式">创建对象的方式</h2>
<ol>
<li>
<p>new创建新对象</p>
</li>
<li>
<p>通过反射机制</p>
<ul>
<li>
<p>通过Class字节码对象newInstance();（默认通过无参构造创建）</p>
</li>
<li>
<p>通过获取构造器getConstructor(Class&lt;?&gt;…parameterTypes);（通过有参的构造器，参数可以指定具体类型和多个数量）</p>
<p>举例：</p>
<p>用户类User：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.java.zxj.test_project;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String userId;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反射创建无参构造对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.java.zxj.test_project;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clz = Class.forName(<span class="string">&quot;test.java.zxj.test_project.User&quot;</span>);</span><br><span class="line">		Object object = clz.newInstance();</span><br><span class="line">		System.out.println(object <span class="keyword">instanceof</span> User);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建有参构造的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给User添加有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String userId;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userId, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.java.zxj.test_project;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clz = Class.forName(<span class="string">&quot;test.java.zxj.test_project.User&quot;</span>);</span><br><span class="line">		<span class="comment">//获取参数为&lt;String,String&gt;的构造器</span></span><br><span class="line">		Constructor&lt;?&gt; constructor = clz.getConstructor(String.class, String.class);</span><br><span class="line">		Object object = constructor.newInstance(<span class="string">&quot;userId_001&quot;</span>,<span class="string">&quot;name_jack&quot;</span>);</span><br><span class="line"><span class="comment">//		System.out.println(object instanceof User);</span></span><br><span class="line">		<span class="keyword">if</span> (object <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">			User user = (User)object;</span><br><span class="line">			System.out.println(<span class="string">&quot;userId:&quot;</span> + user.getUserId());</span><br><span class="line">			System.out.println(<span class="string">&quot;name:&quot;</span> + user.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>采用clone机制</p>
</li>
<li>
<p>通过序列化机制</p>
<p>需要实现<strong>java.io.Serializable</strong>接口</p>
</li>
</ol>
<h2 id="反射">反射</h2>
<h3 id="什么是反射？">什么是反射？</h3>
<p>（1）Java反射机制的核心是<strong>在程序运行时动态加载类并获取类的详细信息</strong>，从而操作类或对象的属性和方法。 本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p>
<p>（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了， 而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到， 所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性， 不需要提前在编译期知道运行的对象是谁。</p>
<p>反射：能够分析类信息（属性、方法、构造器）的能力的程序叫做反射</p>
<h3 id="获取class对象的方式：">获取class对象的方式：</h3>
<ol>
<li>Class.forName(“类的路径”)：将字节码文件加载进内存，返回class对象</li>
<li>类名.class：通过类名的class获取</li>
<li>对象.getClass()：getClass()方法在object类当中定义着</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 1.Class.forName(&quot;全类名&quot;)：</span></span><br><span class="line">       Class class1 = Class.forName(<span class="string">&quot;com.haijiao12138.demo.spring.reflection.Person&quot;</span>);</span><br><span class="line">       System.out.println(class1);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.类名.class:通过类名的class获取</span></span><br><span class="line">       Class class2 = Person.class;</span><br><span class="line">       System.out.println(class2);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.对象.getClass()</span></span><br><span class="line">       Person person = <span class="keyword">new</span> Person();</span><br><span class="line">       Class class3 = person.getClass();</span><br><span class="line">       System.out.println(class3);</span><br><span class="line">       System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">       System.out.println(class1  == class2);</span><br><span class="line">       System.out.println(class1  == class3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射的原理">反射的原理</h3>
<p>在Java中，每个类都有一个Class对象，该对象包含了该类的信息，包括类的构造函数、字段、方法等。通过Java反射机制，可以在运行时获取并操作这些信息。</p>
<h3 id="反射获取：">反射获取：</h3>
<p>Java反射机制的核心是java.lang.reflect包中的三个类：<strong>Class、Constructor和Method</strong>。其中，Class类用于获取类的信息，Constructor类用于获取构造函数的信息，Method类用于获取方法的信息。通过这些类的方法，可以获取对应的类、构造函数和方法的详细信息，并进行相应的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">· <span class="number">1.</span>获取成员变量们</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span>Field[] getFields() ：获取所有<span class="keyword">public</span>修饰的成员变量</span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span>：获取指定名称的</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.Field[] <span class="title">getDeclaredFilds</span><span class="params">()</span>：获取所有的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">2.获取构造方法们</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">1.Constructor[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">2.Constructor <span class="title">getConstructor</span><span class="params">(类...parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.Constructor <span class="title">getDeclaredConstructors</span><span class="params">(类...parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.获取方法名</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">1.Method[] <span class="title">getMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">2.Method <span class="title">getMethod</span><span class="params">(String name,类... parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.Method[] <span class="title">getDeclaredMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.Method <span class="title">getDeclaredMethod</span><span class="params">(String name,类... parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.获取类名</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="举例">举例</h3>
<p><strong>简单：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: haijiao12138</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Student</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/15 2:51</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haijiao12138.demo.spring.reflection1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: haijiao12138</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: CommonReflect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/15 2:52</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReflect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取该类的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getClassName</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Class studentClass = Student.class;</span></span><br><span class="line">        <span class="comment">//String name = studentClass.getName().;</span></span><br><span class="line">        String className = object.getClass().getSimpleName();</span><br><span class="line">        System.out.println(<span class="string">&quot;类的名字是：&quot;</span>+className);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取类的变量名称   不考虑修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getField</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员变量的名称为：&quot;</span>+fields[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取类的成员方法  所有private的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethod</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Method[] methods = object.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员方法的名称：&quot;</span>+methods[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用该类的成员方法，以get为例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAction</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取到有多少get方法</span></span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            String fieldName = fields[i].getName();</span><br><span class="line">            String fistfont = fieldName.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase();</span><br><span class="line">            String methodname = <span class="string">&quot;get&quot;</span>+fistfont+fieldName.substring(<span class="number">1</span>); <span class="comment">//get+N+name=getName; getAge  getAddress</span></span><br><span class="line">            Method method = object.getClass().getMethod(methodname);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;get的输出结果：&quot;</span>+method.invoke(object));</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object studentObject = Student.class.getConstructor(String.class,<span class="keyword">int</span>.class,String.class).newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="string">&quot;保定&quot;</span>);</span><br><span class="line">        getClassName(studentObject);<span class="comment">//类名</span></span><br><span class="line">        getField(studentObject);<span class="comment">//成员变量名</span></span><br><span class="line">        getMethod(studentObject);<span class="comment">//成员方法名</span></span><br><span class="line">        getAction(studentObject);<span class="comment">//成员变量的输出结果</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">类的名字是：Student</span><br><span class="line">成员变量的名称为：name</span><br><span class="line">成员变量的名称为：age</span><br><span class="line">成员变量的名称为：address</span><br><span class="line">成员方法的名称：setAge</span><br><span class="line">成员方法的名称：getAge</span><br><span class="line">成员方法的名称：setAddress</span><br><span class="line">成员方法的名称：getAddress</span><br><span class="line">成员方法的名称：getName</span><br><span class="line">成员方法的名称：setName</span><br><span class="line">get的输出结果：张三</span><br><span class="line">get的输出结果：20</span><br><span class="line">get的输出结果：保定</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h3 id="JAVA反射机制的优缺点">JAVA反射机制的优缺点</h3>
<p>可以去任意构造一个类对象，获取任意一个类的成员变量，成员方法和属性，以及调用任意一个对象方法，反射可以使得java支持动态获取程序信息以及动态调用方法的能力</p>
<p><strong>优点：</strong></p>
<ol>
<li>能够运行时动态获取类的实例，提高灵活性</li>
<li>与动态编译结合</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</li>
<li>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</li>
</ol>
<p><strong>解决方案：</strong></p>
<ol>
<li>通过setAccessible(true)关闭JDK的安全检查来提升反射速度；</li>
<li>多次创建一个类的实例时，有缓存会快很多</li>
<li>ReflectASM工具类，通过字节码生成的方式加快反射速度</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/24/dcxiGEh13NBPALy.png" alt="image-20230224210051829"></p>
<p><img src="https://s2.loli.net/2023/02/24/NSdGvTYH7MFUJo6.png" alt="image-20230224210105527"></p>
<h2 id="反射和new对象的区别">反射和new对象的区别</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45076180/article/details/117733342">Spring的IOC容器为什么用反射而不用new来创建实例？</a></p>
<ol>
<li>
<p>反射和new都是创建对象实例的，但是new对象无法调用该类里面私有private的属性，而反射可以调用类中private的属性！</p>
</li>
<li>
<p>new属于静态编译。就是在编译的时候把所有的模块都确定，如果有添加或删除某些功能，需要重新编译。但系统不可能一次就把把它设计得很完美，当发现需要更新某些功能时，采用静态编译的话，需要把整个程序重新编译一次才可以实现功能的更新。也就是说，用户需要把以前的软件卸载了，再重新安装才会重新编译！这样的系统耦合严重，难以扩展！</p>
</li>
<li>
<p>反射属于动态编译。在运行时确定类型并创建对象，通过反射指定模板，动态的向模板中传入要实例化的对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。其中spring中ioc的核心就是利用了反射解耦合。</p>
</li>
<li>
<p>反射效率较低，但经过jdk很多版本的优化，效率已经很高了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple1234&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span></span>&#123;</span><br><span class="line">        fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//工厂中使用反射！</span></span><br><span class="line">            f=(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        fruit f=Factory.getInstance(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="静态代理和动态代理">静态代理和动态代理</h2>
<h3 id="静态代理：">静态代理：</h3>
<p>需要先定义一个接口，然后编写一个代理类，代理类实现接口并持有一个被代理对象的引用。在代理类的方法中，我们可以在调用被代理对象的方法前后执行一些额外的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(RealSubject realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxySubject before request&quot;</span>);</span><br><span class="line">        realSubject.request();</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxySubject after request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        ProxySubject proxySubject = <span class="keyword">new</span> ProxySubject(realSubject);</span><br><span class="line">        proxySubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态代理">动态代理</h3>
<p>在动态代理中，我们不需要自己写代理类，而是使用Java提供的<code>Proxy</code>类和<code>InvocationHandler</code>接口来实现。我们只需要编写一个<code>InvocationHandler</code>的实现类，并在其中实现代理对象方法的逻辑，然后使用<code>Proxy</code>类的<code>newProxyInstance()</code>方法创建代理对象。它接受三个参数：<strong>代理对象的类加载器、代理对象实现的接口、以及<code>InvocationHandler</code>对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现InvocationHandler接口的代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object realObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object realObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realObject = realObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DynamicProxy before request&quot;</span>);</span><br><span class="line">        Object result = method.invoke(realObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;DynamicProxy after request&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(realSubject);</span><br><span class="line">        Subject proxySubject = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                realSubject.getClass().getClassLoader(),</span><br><span class="line">                realSubject.getClass().getInterfaces(),</span><br><span class="line">                dynamicProxy</span><br><span class="line">        );</span><br><span class="line">        proxySubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>DynamicProxy</code>类实现了<code>InvocationHandler</code>接口，其中<code>invoke()</code>方法中实现了代理对象方法的逻辑。<code>Proxy.newProxyInstance()</code>方法用于创建代理对象</p>
<h2 id="try-catch-finally">try-catch-finally</h2>
<p>无论 try 中是否包含 return 语句，finally 语句块都会执行。</p>
<p>finally 语句块中的代码总是会在 try 或 catch 块中的代码执行完毕之后执行，无论 try 或 catch 中是否有 return 语句或抛出异常。这是因为 finally 语句块中的代码是一定会被执行的，它通常用于<strong>释放资源、关闭连接</strong>等必须要执行的操作。</p>
<p>当 try 或 catch 中有 return 语句时，finally 语句块中的代码会在返回之前执行。<strong>如果在 finally 语句块中也有 return 语句，那么它会覆盖之前的返回值，以 finally 中的 return 语句为准。</strong>（实际：finally是在return后面的表达式运算后执行的（<strong>此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值）</strong>，所以函数返回值是在finally执行前确定的）</p>
<p>需要注意的是，在某些特殊情况下，**如在 try 或 catch 块中调用了 System.exit() 方法，程序将会退出，finally 语句块中的代码不会执行。**此外，<strong>如果在 try 或 catch 块中使用了 Thread.stop() 方法强制终止线程，finally 语句块中的代码同样也不会执行</strong>。这些情况下 finally 语句块中的代码不会执行，是一个例外情况。</p>
<h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2>
<p>讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hhb442/article/details/128801265">深拷贝浅拷贝</a></p>
<h3 id="定义">定义</h3>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/25/MAD64ogxUvEfmGy.png" alt="image-20230225160018518"></p>
<h3 id="实现方式">实现方式</h3>
<p><strong>深拷贝的实现方式主要通过序列化和递归实现</strong></p>
<ol>
<li>
<p>**序列化：**以使⽤json序列化为例，通过将原对象序列化成json格式，然后通过json的反序列化功能，⾃动创建新的内存来存放新对象</p>
</li>
<li>
<p>**递归实现：**递归实现是深拷贝的常⽤解决⽅式，利⽤层层递归的⽅式，拷贝所有内部的成员对象</p>
</li>
</ol>
<h3 id="举例：">举例：</h3>
<p>浅拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Major major;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>深拷贝：</p>
<p>序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//写入字节流</span></span><br><span class="line">			ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">			obs.writeObject(obj);</span><br><span class="line">			obs.close();</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">			ByteArrayInputStream is = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">			ObjectInputStream os = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">			cloneObj = (T) os.readObject();</span><br><span class="line">			os.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cloneObj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归：</p>
<p>首先需要对更深一层次的引用类Major做改造，让其也实现<strong>Cloneable</strong>接口并重写clone()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String MajorName;</span><br><span class="line">    <span class="keyword">private</span> String MajorId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其次我们还需要在<strong>顶层的</strong>调用类中重写clone方法，来调用<strong>引用类型</strong>字段的clone()方法实现深度拷贝，对应到本文那就是Student类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Major major;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        Major m = (Major)<span class="keyword">this</span>.major.clone();    <span class="comment">//重要</span></span><br><span class="line">        student.major = m;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Major m = <span class="keyword">new</span> Major(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot;001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Student st1 = <span class="keyword">new</span> Student(<span class="string">&quot;jack&quot;</span>, <span class="number">11</span>, m);</span><br><span class="line">    <span class="comment">//拷贝</span></span><br><span class="line">    Student st2 = (Student)st1.clone();</span><br><span class="line"></span><br><span class="line">    System.out.println(st1==st2);</span><br><span class="line">    System.out.println(st1);</span><br><span class="line">    System.out.println(st2);</span><br><span class="line">    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改st1</span></span><br><span class="line">    st1.setAge(<span class="number">22</span>);</span><br><span class="line">    <span class="comment">//修改st1的引用类型字段</span></span><br><span class="line">    m.setMajorName(<span class="string">&quot;电子信息&quot;</span>);</span><br><span class="line">    m.setMajorId(<span class="string">&quot;002&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(st1);</span><br><span class="line">    System.out.println(st2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个不相等的对象有相同的hashcode">两个不相等的对象有相同的hashcode</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;str1：%d | str2：%d&quot;</span>,  str1.hashCode(),str2.hashCode()));</span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="和-equals-的区别">== 和 equals() 的区别</h2>
<ul>
<li>
<p>对于基本数据类型来说，<code>==</code> 比较的是值。</p>
</li>
<li>
<p>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址</p>
</li>
<li>
<p><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</p>
</li>
<li>
<p><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)</p>
</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值</p>
<p>重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;  </span><br><span class="line">       String anotherString = (String)anObject;  </span><br><span class="line">       <span class="keyword">int</span> n = count;  </span><br><span class="line">       <span class="keyword">if</span> (n == anotherString.count) &#123;  </span><br><span class="line">           <span class="keyword">char</span> v1[] = value;  </span><br><span class="line">           <span class="keyword">char</span> v2[] = anotherString.value;  </span><br><span class="line">           <span class="keyword">int</span> i = offset;  </span><br><span class="line">           <span class="keyword">int</span> j = anotherString.offset;  </span><br><span class="line">           <span class="keyword">while</span> (n– != <span class="number">0</span>) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (v1[i++] != v2[j++])  </span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="为什么重写-equals-时必须重写-hashCode-方法">为什么重写 equals() 时必须重写 hashCode() 方法</h2>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<h2 id="集合框架">集合框架</h2>
<p>讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/AOSIDIN/article/details/117533808">Java集合</a></p>
<p><img src="https://s2.loli.net/2023/04/12/ljtpmUXTox3wWfY.png" alt="image-20230412163646730"></p>
<p><img src="https://s2.loli.net/2023/04/07/2iWgXzLIZ8fQMke.png" alt="image-20230407101327402"></p>
<h2 id="集合框架的优点">集合框架的优点</h2>
<ol>
<li><strong>统一的API：<strong>集合框架提供了一个统一的API，使得</strong>不同的集合实现可以使用相同的方法来访问和操作集合元素</strong>。这使得代码更加简洁和易于维护</li>
<li><strong>高效的数据结构：<strong>集合框架提供了高效的数据结构，例如HashSet、TreeSet和HashMap等，这些数据结构</strong>在查找、插入和删除元素时具有高效性能</strong>。这些数据结构还具有<strong>自动排序、去重和关联</strong>等特性</li>
<li><strong>自动装箱和拆箱：<strong>Java中的基本类型和对象类型不能直接互换，需要通过装箱和拆箱操作来实现。集合框架提供了</strong>自动装箱和拆箱</strong>的功能，使得编写代码更加方便</li>
<li><strong>线程安全：<strong>集合框架提供了</strong>线程安全的集合实现</strong>，例如ConcurrentHashMap和CopyOnWriteArrayList等。这些实现可以在多线程环境中安全地操作集合元素</li>
<li><strong>可扩展性：<strong>集合框架</strong>提供了接口和抽象类</strong>，可以通过继承和实现来扩展现有集合实现，以满足特定的需求。这使得集合框架具有很高的可扩展性</li>
</ol>
<h2 id="ArrayList和数组的区别">ArrayList和数组的区别</h2>
<ol>
<li>数组是固定长度的，ArrayList是变长度并且会动态扩容，每次扩充为原来的1.5倍</li>
<li>数组在创建的时候就确认了数据类型，ArrayList为了兼容所有类型对象,使用了Object数组，在使用元素的时候会有装箱和拆箱的操作,降低了程序的性能</li>
<li>ArrayList只有把元素添加进去之后才可以通过下标访问相应的元素</li>
</ol>
<h2 id="ArrayList与LinkedList的两者区别">ArrayList与LinkedList的两者区别</h2>
<ol>
<li>ArrayList是<strong>Array即动态数组</strong>的数据结构，LinkedList是<strong>Link(链表)双向链表</strong>的数据结构</li>
<li>ArrayList需要初始化容量为10，插入新元素的时候，会判断是否需要扩容（利用数组的复制），扩容的步长是0.5倍；LinkedList不需要初始化</li>
<li>LinkedList插入和删除的速率很快，而ArrayList的查询速度很快</li>
</ol>
<h2 id="ArrayList初始容量以及扩容机制">ArrayList初始容量以及扩容机制</h2>
<p>默认初始化容量为10，扩容倍数为1.5，java8后是懒加载，一开始不会有容量，只有往里面加元素的时候才会在堆里面创建数组的实例，<strong>即向数组中添加第一个元素时，数组容量扩为 10</strong></p>
<h2 id="HashMap-和-Hashtable-的区别">HashMap 和 Hashtable 的区别</h2>
<p>Hashtable <strong>继承于Dictionary</strong>，实现了Map、Cloneable等接口</p>
<p><img src="https://s2.loli.net/2023/02/23/KepzNDH9gZO2maj.png" alt="image-20230223214459539"></p>
<h2 id="HashMap的put方法">HashMap的put方法</h2>
<ol>
<li>
<p>根据key通过哈希算法和与运算得出数组下标</p>
<p>异或操作：<strong>尽量打乱hashcode真正参与运算的低16位，让元素在hashmap中分布的更加均匀</strong></p>
<p>与操作：hash&amp;（n-1）</p>
</li>
<li>
<p>如果数组下标元素为空，则将key和value封装为Entry对象（JDK1.7是Entry对象，JDK1.8是Node对象）并放⼊该位置。</p>
</li>
<li>
<p>如果数组下标位置元素不为空，则要分情况</p>
<ul>
<li>
<p>如果是在JDK1.7，则⾸先会判断是否需要扩容，如果要扩容就进行扩容，如果不需要扩容就生成Entry对象，并使⽤头插法添加到当前链表中。</p>
</li>
<li>
<p>如果是在JDK1.8中，则会先判断当前位置上的TreeNode类型，看是红黑树还是链表Node</p>
<ul>
<li>如果是红黑树TreeNode，则将key和value封装为⼀个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value。</li>
<li>如果此位置上的Node对象是链表节点，则将key和value封装为⼀个Node并通过尾插法插⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历过程中会判断是否存在当前key，如果存在则更新其value，当遍历完链表后，将新的Node插⼊到链表中，插⼊到链表后，会看当前链表的节点个数，如果⼤于8，则会将链表转为红⿊树</li>
<li>将key和value封装为Node插⼊到链表或红⿊树后，在判断是否需要扩容，如果需要扩容，就结束put⽅法</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="HashMap会出现的问题">HashMap会出现的问题</h2>
<p>可能出现的问题：</p>
<ol>
<li>jdk1.7中扩容时可能会出现<strong>链表成环</strong>的问题，所以jdk1.8改成了尾插法并且在ConcurrentHashMap对单个Node加锁实现安全并发</li>
<li>jdk1.7时线程1的put和线程2的get并发，可能导致get为null，造成数据丢失问题</li>
<li>jdk1.8put方法，在多线程场景下，存在数据覆盖问题</li>
<li>多线程同时put时数据覆盖</li>
<li>size只是用了**transient（不参与序列化）**关键字修饰,在各个线程中的size不会及时同步，在多个线程操作的时候，size将会被覆盖</li>
</ol>
<h2 id="jdk1-7HashMap为什么用头插法">jdk1.7HashMap为什么用头插法</h2>
<p><strong>考虑到热点数据的原因，即最近插入的元素也很可能最近会被使用到。所以为了缩短链表查找元素的时间，每次都会将新插入的元素放到表头。</strong></p>
<h2 id="为什么要右移16位">为什么要右移16位</h2>
<p>为了使得hashmap 元素更加均匀</p>
<p><img src="https://s2.loli.net/2023/04/04/3stEcXmdhVL57uM.png" alt="image-20230404171056242"></p>
<p><img src="https://s2.loli.net/2023/04/04/7RSqGWvVODPelXp.png" alt="image-20230404171113110"></p>
<h2 id="ConcurrentHashMap-和-Hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别</h2>
<blockquote>
<p>在jdk1.7的时候是使⽤分段锁segment，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p>
<p>在jdk1.8的时候摒弃了 Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和 CAS 来操作。synchronized只锁定当前链表或红⿊⼆叉树的⾸节点。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/02/23/LlWczTNjIsJ1VUe.png" alt="image-20230223215518928"></p>
<blockquote>
<p>ConcurrentHashMap和Hashtable都是线程安全的Map实现，但是它们在加锁机制上有所不同。</p>
<p>Hashtable使用的是一种简单的方法级别的同步机制，也就是<strong>在每个方法上添加synchronized关键字</strong>，使得每个方法在被调用时都会获得一个对象级别的锁。这种机制使得多个线程不能同时访问Hashtable中的数据，因此在高并发场景下可能会存在性能问题。</p>
<p>而ConcurrentHashMap使用了一种不同的锁机制，它采用了<strong>分段锁</strong>的方式。ConcurrentHashMap中的数据结构是由多个Segment（段）组成的，<strong>每个Segment都是一个独立的Hashtable</strong>，它们各自维护自己的锁。当一个线程访问ConcurrentHashMap中的某个Segment时，只会锁定该Segment，而不会锁定整个ConcurrentHashMap，因此多个线程可以同时访问不同的Segment，从而提高了并发访问的效率。</p>
<p>另外，ConcurrentHashMap也支持读取数据时的无锁并发访问，即多个线程可以同时读取ConcurrentHashMap中的数据，而不会阻塞。</p>
<p>总之，ConcurrentHashMap的锁机制相比Hashtable更加高效，在高并发场景下表现更优秀。</p>
</blockquote>
<h2 id="为什么重写equals-就一定要重写hashcode-方法">为什么重写equals()就一定要重写hashcode()方法</h2>
<p>equals()源码：先比较两个字符串的地址，如果相同，则返回true，如果不同，则继续比较字符串的值，如果两个值完全相同，则返回true</p>
<p>如果两个完全相同的对象，也就是内存地址指向同一个，那他们的hashcode一定是相同的</p>
<p>答：只重写equals方法，这会导致hashcode值可能会不相同，那么这个类无法和所有集合类一起工作，在使用散列集合存储的时候就会出现问题（两个完全相同的对象，却存储在两个不同的位置）</p>
<h2 id="为什么Hashmap是扩展为红黑树而不是其他">为什么Hashmap是扩展为红黑树而不是其他</h2>
<ul>
<li>
<p>链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。</p>
</li>
<li>
<p>AVL树是一种高度平衡的二叉树，所以查找的稳定度非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多代价。每次插入、删除都要做调整，复杂、耗时。所以，hashmap用红黑树</p>
</li>
<li>
<p>如果用B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面。这个时候遍历效率就退化成了链表。</p>
</li>
</ul>
<h2 id="红黑树和B-树的区别">红黑树和B+树的区别</h2>
<p><strong>红黑树特征：</strong></p>
<ol>
<li>每个节点都是黑色或者红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色</li>
<li>如果一个节点是红色，那其子节点都必须是黑色</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/24/yCG7QdSRosgMTeP.png" alt="image-20230224220433318"></p>
<h2 id="HashMap可以键值对同时为null吗">HashMap可以键值对同时为null吗</h2>
<p>底层：HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null值，因为key不允许重复，因此只能有一个键为null而Hashtable不行</p>
<p><strong>Hashtable put 方法逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashMap hash 方法逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理</p>
<p>补充：</p>
<ol>
<li>来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1（key%m，把m选为素数，正是为了让所有key同m的公约数都为1，<strong>从而保证余数的均匀分布，降低冲突率</strong>。 鉴于此，在HashTable中，初始化容量是11，是个素数，后面扩容时也是按照2N+1的方式进行扩容， 确保扩容之后仍尽量是素数。）</li>
</ol>
<h2 id="生产者和消费者模型">生产者和消费者模型</h2>
<p>生产者线程用于生产数据，消费者线程用于消费数据</p>
<p>举例：</p>
<p>奶箱类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1：定义奶箱类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> milk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果有牛奶等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，就等到生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费完毕后,修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2:生产者类(Producer):实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run()方法，调用存储牛奶的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3:消费者类(Customer);实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run()方法，调用获取牛奶的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            b.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        Box b = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递。因为在这个类中要谓用存储牛奶的操作</span></span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        Customer c  =<span class="keyword">new</span> Customer(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        送奶工将第1瓶奶放入奶箱</span></span><br><span class="line"><span class="comment">//                用户拿到第1瓶奶</span></span><br><span class="line"><span class="comment">//        送奶工将第2瓶奶放入奶箱</span></span><br><span class="line"><span class="comment">//                用户拿到第2瓶奶</span></span><br><span class="line"><span class="comment">//        送奶工将第3瓶奶放入奶箱</span></span><br><span class="line"><span class="comment">//                用户拿到第3瓶奶</span></span><br><span class="line"><span class="comment">//        送奶工将第4瓶奶放入奶箱</span></span><br><span class="line"><span class="comment">//                用户拿到第4瓶奶</span></span><br><span class="line"><span class="comment">//        送奶工将第5瓶奶放入奶箱</span></span><br><span class="line"><span class="comment">//                用户拿到第5瓶奶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Spring</h1>
<h2 id="Web服务器和Tomcat">Web服务器和Tomcat</h2>
<p><img src="https://s2.loli.net/2023/03/30/4loigeUCTMyGXJs.png" alt="image-20230330135223829"></p>
<h2 id="讲讲使用SpringBoot的理由">讲讲使用SpringBoot的理由</h2>
<p>Spring Boot 是基于 Spring 框架的快速开发框架，它能够简化 Spring 应用的初始搭建以及开发过程中的配置管理。与传统的 Spring 框架相比，Spring Boot 具有以下几个优点：</p>
<ol>
<li>
<p>**简化配置：**Spring Boot 可以自动配置大部分组件，让开发者可以更加专注于业务逻辑的实现，而不是繁琐的配置。</p>
</li>
<li>
<p>**嵌入式服务器：**Spring Boot 内置了 Tomcat、Jetty 等嵌入式 Web 服务器，使得应用的部署更加简单。</p>
</li>
<li>
<p>**快速开发：**Spring Boot 提供了一些快速开发工具，如 Spring Initializr，可以帮助开发者快速创建项目，减少了开发时间。</p>
</li>
<li>
<p>**自动配置：**Spring Boot 自动配置了很多常见的场景，如数据源、事务管理等，使得开发者可以更快地搭建应用程序。</p>
<hr>
</li>
<li>
<p>微服务支持：Spring Boot 适用于微服务架构，可以轻松构建和部署微服务应用。</p>
</li>
</ol>
<h2 id="Spring和SpringBoot的区别">Spring和SpringBoot的区别</h2>
<p>SpringBoot优点：</p>
<ol>
<li>
<p>独立运行</p>
<p>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内</p>
</li>
<li>
<p>简化配置</p>
<p>spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置</p>
</li>
<li>
<p>自动配置</p>
<p>Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starterweb启动器就能拥有web的功能，无需其他配置</p>
</li>
<li>
<p>无需XML配置（通过注解即可）</p>
<p><strong>@SpringBootApplication</strong></p>
<ul>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能</li>
<li>@EnableAutoConfiguration：自动配置</li>
<li>@ComponentScan：Spring组件扫描</li>
</ul>
</li>
</ol>
<h2 id="讲讲对Spring的理解">讲讲对Spring的理解</h2>
<p>优点为：<strong>非侵入式设计、方便解耦，简化开发，支持AOP，方便程序的测试（Junit4），降低Java API的使用难度</strong>Spring对Java EE开发中非常难用的一些API（如：JDBC、JavaMail等），都提供了封装，使这些API应用难度大大降低</p>
<h3 id="IOC">IOC</h3>
<p>是一种设计思想，而不是一个具体的技术实现。IOC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</p>
<h3 id="AOP">AOP</h3>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如<strong>事务处理、日志管理、权限控制等</strong>）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</p>
<p>能够在已有方法，属性，代码块的基础上批量进行功能的增强</p>
<h2 id="AutoWired自动装配的原理">@AutoWired自动装配的原理</h2>
<h2 id="SpringBoot自动配置原理">SpringBoot自动配置原理</h2>
<p>SpringBoot所有的自动配置都在启动类中被扫描并加载，加载的所有自动配置类的在spring.factories，但是不一定生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，自动装配就能生效，即可配置成功</p>
<p><img src="https://s2.loli.net/2023/04/04/iXIS9hAct6bHprn.png" alt="image-20230404222532753"></p>
<p><img src="https://s2.loli.net/2023/04/04/VubtBF7kqXj5YUf.png" alt="image-20230404222621966"></p>
<p><img src="https://s2.loli.net/2023/04/04/baGUX5NvMdsQyct.png" alt="image-20230404222701213"></p>
<p><img src="https://s2.loli.net/2023/04/04/PWFhszrEKRy1LlB.png" alt="image-20230404223804180"></p>
<p><img src="https://s2.loli.net/2023/04/04/CbKRHkfhreP4AsW.png" alt="image-20230404224101006"></p>
<h2 id=""></h2>
<h2 id="讲讲对spring-IOC的理解">讲讲对spring IOC的理解</h2>
<p><strong>自己答：</strong></p>
<p>Spring IoC是spring的重要思想，它的核心思想是<strong>将对象之间的依赖关系交给容器来管理，从而实现了对象之间的松耦合</strong>，它的核心思想有两个，一个是IOC即控制反转，一个是DI即依赖注入，开发者只需要配置好对象之间的依赖关系，然后将这些对象交给Spring容器来管理，容器会负责对象的创建、销毁、依赖注入等任务。开发者无需手动创建对象，只需要从容器中获取对象即可。</p>
<p><strong>Chatgpt：</strong></p>
<blockquote>
<p>Spring IoC是一个轻量级的框架，它的核心思想是将对象之间的依赖关系交给容器来管理，从而实现了对象之间的松耦合。IoC即Inversion of Control（控制反转）和DI（Dependency Injection，依赖注入），是Spring框架的核心，是实现Spring的重要手段之一。</p>
<p>在Spring IoC中，开发者只需要配置好对象之间的依赖关系，然后将这些对象交给Spring容器来管理，容器会负责对象的创建、销毁、依赖注入等任务。开发者无需手动创建对象，只需要从容器中获取对象即可。这种方式避免了传统的耦合方式，使得开发更加灵活、方便、高效。</p>
<p>Spring IoC的实现方式包括<strong>XML配置、注解方式、Java Config方式</strong>等。通过这些方式，开发者可以将应用程序的组件（如Controller、Service、DAO等）交给Spring容器来管理，容器可以自动地将这些组件组装起来，从而实现了整个应用程序的松耦合和模块化管理。</p>
<p>总之，Spring IoC是一种通过容器来管理对象依赖关系的方式，它提供了一种灵活、方便、高效的方式来构建应用程序。</p>
</blockquote>
<h2 id="讲讲对Spring-AOP的理解">讲讲对Spring AOP的理解</h2>
<p>AOP讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39746820/article/details/124468249">一篇文章详细解读Spring的AOP原理过程（Spring面向切面详解）</a></p>
<p><strong>自己答：</strong></p>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如<strong>事务处理、日志管理、权限控制等</strong>）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性，能够在已有方法，属性，代码块的基础上批量进行功能的增强</p>
<p><strong>Spring 框架一般都是基于 AspectJ 实现 AOP 操作</strong></p>
<ol>
<li>基于 xml 配置文件实现</li>
<li>基于注解方式实现</li>
</ol>
<p><strong>Chatgpt:</strong></p>
<blockquote>
<p>Spring AOP（Aspect Oriented Programming，面向切面编程）是Spring框架中的一个重要组成部分，它提供了一种在不修改原有代码的情况下，通过对程序进行横向切割的方式来增强代码功能的手段。</p>
<p>AOP的核心思想是将系统的关注点（例如日志、安全性、事务等）从核心业务逻辑中分离出来，将其封装成一个切面（Aspect），然后将这个切面应用到核心业务逻辑的特定位置上，从而实现对核心业务逻辑的增强。在Spring AOP中，可以通过注解或XML配置的方式来声明切面和切入点，从而达到对系统的横向增强。</p>
<p>Spring AOP的实现方式主要依赖于动态代理(和字节码操作技术)，通过这些技术可以在运行时动态地生成代理对象，从而将切面的代码织入到目标对象中。Spring AOP支持的切面类型包括前置通知、后置通知、异常通知、环绕通知等等，这些通知可以根据需要进行组合使用，从而实现更加灵活的增强效果。</p>
<p>总之，Spring AOP是一种通过对系统关注点进行横向切割来增强代码功能的手段，它可以实现对核心业务逻辑的非侵入式增强，使得代码的可重用性、可维护性和可扩展性得到了显著提升。</p>
</blockquote>
<h2 id="讲讲对Spring-DI的理解">讲讲对Spring DI的理解</h2>
<p><strong>自己：</strong></p>
<p>依赖注入，它可以使得对象之间的依赖关系通过外部容器来管理，在传统的编程模式中，对象之间的依赖关系通常是通过new来实现的，这种方式导致对象之间的依赖关系非常紧密，代码耦合度高，而在Spring中，只需要将这些对象交给Spring容器来管理，容器会在创建对象的同时自动将依赖注入到对象中，从而实现了代码的松耦合和更高的灵活性。</p>
<p><strong>Chatgpt：</strong></p>
<blockquote>
<p>Spring DI（Dependency Injection，依赖注入）是Spring框架中的一个重要特性，它可以使得对象之间的依赖关系通过外部容器来管理，从而实现了代码的松耦合和更高的灵活性。</p>
<p>在传统的编程模式中，对象之间的依赖关系通常是通过new关键字或工厂方法来实现的，这种方式导致对象之间的依赖关系非常紧密，代码耦合度高，难以进行单元测试和重构。而在Spring DI中，开发者只需要在配置文件或代码中定义好对象之间的依赖关系，然后将这些对象交给Spring容器来管理，容器会在创建对象的同时自动将依赖注入到对象中，从而实现了对象之间的松耦合和更高的灵活性。</p>
<p>Spring DI的实现方式主要有两种：XML配置和注解配置。在XML配置中，开发者需要在配置文件中定义bean的属性，然后在应用程序中通过ApplicationContext来获取这些bean，容器会自动将这些属性注入到对象中。在注解配置中，开发者可以使用注解来定义bean和bean之间的依赖关系，然后容器会根据注解的信息来进行依赖注入。通过这些方式，Spring DI可以使得开发者的代码更加灵活、易于维护和测试，从而提高了开发效率和代码质量。</p>
<p>总之，Spring DI是一种通过外部容器来管理对象之间的依赖关系的手段，它可以实现对象之间的松耦合和更高的灵活性，从而提高了应用程序的可维护性、可测试性和可扩展性。</p>
</blockquote>
<h2 id="说下对Spring-MVC的理解">说下对Spring MVC的理解</h2>
<p>（1） 客户端发送请求，请求到达 DispatcherServlet 主控制器（前端控制器）。<br>
（3） HandlerMapping 负责维护请求和 Controller 组件对应关系。 HandlerMapping 根据请求调用对应的 Controller 组件处理。<br>
（4） 执行 Controller 组件的业务处理，需要访问数据库，可以调用 DAO 等组件。<br>
（5）Controller 业务方法处理完毕后，会返回一个 ModelAndView 对象。该组件封装了模型数据和视图标识。<br>
（6）Servlet 主控制器调用 ViewResolver 组件，根据 ModelAndView 信息处理。定位视图资源，生成视图响应信息。<br>
（7）控制器将响应信息给用户输出。</p>
<img src="https://s2.loli.net/2023/03/30/IuLmbGBKtDMpaVE.png" alt="image-20230330140215344" style="zoom:67%;" />
<h2 id="初始准备">初始准备</h2>
<h3 id="JDBC">JDBC</h3>
<img src="https://s2.loli.net/2023/03/30/lMXvLNPBIwcmVUg.png" alt="image-20230330154122014" style="zoom: 50%;" />
<img src="https://s2.loli.net/2023/03/30/OxE94g1hQ2LMNYr.png" alt="image-20230330154219337" style="zoom:50%;" />
<h3 id="MyBatis">MyBatis</h3>
<p>针对JDBC的缺点进行改进</p>
<ol>
<li>增删改查中大量重复代码</li>
<li>每次都要创建连接以及关闭资源，造成系统资源浪费，影响性能</li>
<li>不方便维护，频繁修改sql语句</li>
<li>查询操作时，需要手动讲结果集中的数据手动封装到实体中；插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</li>
</ol>
<img src="https://s2.loli.net/2023/03/30/vcl1I2Y6QtrHLTm.png" alt="image-20230330154725989" style="zoom: 67%;" />
<p>步骤：</p>
<ol>
<li>
<p>添加MyBatis的坐标</p>
</li>
<li>
<p>创建user数据表</p>
</li>
<li>
<p>编写User实体类</p>
</li>
<li>
<p>编写映射文件UserMapper.xml</p>
<p>里面包含select、delete、update等标签…，用于编写spl语句</p>
<p><img src="https://s2.loli.net/2023/03/30/f6dwa3nZvQoPke1.png" alt="image-20230330160148371"></p>
</li>
<li>
<p>编写核心文件SqlMapConfig.xml</p>
<p>配置数据源的环境</p>
<img src="https://s2.loli.net/2023/03/30/pKJXIDHcG9iTSry.png" alt="image-20230330155541360" style="zoom:67%;" />
</li>
<li>
<p>编写测试代码</p>
<img src="https://s2.loli.net/2023/03/30/kvRinbBydmXIPpZ.png" alt="image-20230330155611850" style="zoom:67%;" />
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/30/TcnULCrXSevEhGq.png" alt="image-20230330160824171"></p>
<p>可以用注解替换映射文件mapper</p>
<p><img src="https://s2.loli.net/2023/03/30/3OKvjlmW1ZS4pXy.png" alt="image-20230330161023114"></p>
<p><img src="https://s2.loli.net/2023/03/30/Y2PifcFrkRqnm6h.png" alt="image-20230330160445021"></p>
<p><img src="https://s2.loli.net/2023/03/30/dA2ZLICHeFSum3T.png" alt="image-20230330161116138"></p>
<h3 id="MyBatisPlus">MyBatisPlus</h3>
<p>只需要简单配置，即可进行简单的CRUD操作</p>
<h3 id="Spring">Spring</h3>
<ol>
<li>
<p>导入Spring开发的基本包坐标</p>
<p>pom.xml</p>
</li>
<li>
<p>编写Dao接口和实现类</p>
</li>
<li>
<p>创建Spring核心配置文件</p>
</li>
<li>
<p>在Spring配置文件中配置UserDaoImpl</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    	id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    	class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每添加一个Bean都要在xml中添加标签</p>
<p>依赖注入使用<strong>property</strong>标签</p>
</li>
<li>
<p>使用Spring的API获得Bean实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">		ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        BookService bookService = (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置数据源（连接池）</p>
<ol>
<li>
<p>导入数据源的坐标和数据库驱动坐标（pom.xml）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置第三方Bean.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">&lt;!--管理DruidDataSource对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取Bean对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">       DataSource dataSource = (DataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">       System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护，所以可抽出来为jdbc.properties，然后加载配置文件</p>
<ol>
<li>
<p>准备文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/spring_db</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开启<code>context</code>命名空间</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>     </span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>加载properties配置文件</p>
</li>
<li>
<p>完成属性注入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="SpringBoot">SpringBoot</h3>
<ul>
<li>自动配置。这个是用来解决 <code>Spring</code> 程序配置繁琐的问题</li>
<li>起步依赖。这个是用来解决 <code>Spring</code> 程序依赖设置繁琐的问题</li>
<li>辅助功能（内置服务器,…）。我们在启动 <code>SpringBoot</code> 程序时既没有使用本地的 <code>tomcat</code> 也没有使用 <code>tomcat</code> 插件，而是使用 <code>SpringBoot</code> 内置的服务器。</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/30/PJZWn76U9LeFC2p.png" alt="image-20230330163037613"></p>
<p><img src="https://s2.loli.net/2023/03/30/vRwNISHsFTMxQJ4.png" alt="image-20230330162949557"></p>
<p>只需要两个文件：</p>
<p>application.yml：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改banner</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">reggie_take_out</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="comment">#开启mp的日志，将每一个sql语句打印出来</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">ASSIGN_ID</span></span><br><span class="line"><span class="attr">reggie:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">D:\ReggieUpload\</span></span><br></pre></td></tr></table></figure>
<p>启动类： ReggieApplication</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="comment">//开启事务注解的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReggieApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">        log.info(<span class="string">&quot;项目启动成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：rest风格：</p>
<p><img src="https://s2.loli.net/2023/03/30/6pyxXSsPFNb8U1h.png" alt="image-20230330165045431"></p>
<p><img src="https://s2.loli.net/2023/03/30/qEjuZW9lcD2aMKs.png" alt="image-20230330165534127"></p>
<h3 id="SSM原始整合">SSM原始整合</h3>
<ol>
<li>
<p>建立数据库</p>
</li>
<li>
<p>创建Maven并导入坐标</p>
</li>
<li>
<p>编写实体类</p>
</li>
<li>
<p>编写Mapper接口</p>
</li>
<li>
<p>编写Service接口</p>
</li>
<li>
<p>编写Service接口实现类</p>
</li>
<li>
<p>编写Controller</p>
</li>
<li>
<p>编写相应的配置文件</p>
<p><img src="https://s2.loli.net/2023/03/30/sWtc58gnP2h4ji1.png" alt="image-20230330161841241"></p>
</li>
</ol>
<h3 id="SpringBoot整合MyBatis">SpringBoot整合MyBatis</h3>
<p><img src="https://s2.loli.net/2023/03/30/9NSe3PbnKdHyJqv.png" alt="image-20230330170005976"></p>
<p><img src="https://s2.loli.net/2023/03/30/fnE5sR7KC4TbN6u.png" alt="image-20230330170059473"></p>
<p><img src="https://s2.loli.net/2023/03/30/sU4PfMnQDTFahHq.png" alt="image-20230330170138856"></p>
<h3 id="SpringBoot整合MyBatisPlus">SpringBoot整合MyBatisPlus</h3>
<p>添加起步依赖：</p>
<p><img src="https://s2.loli.net/2023/03/30/o2Mkwx5uBYyjCUf.png" alt="image-20230330170413914"></p>
<p>实现CRUD：</p>
<p><strong>只需要继承(extends BaseMapper)</strong>，就无需写sql语句，直接使用CRUD功能（对比上面Mybatis中的UserMapper）</p>
<p><img src="https://s2.loli.net/2023/03/30/s5cELkVmUgJ6FrO.png" alt="image-20230330170644363"></p>
<p><img src="https://s2.loli.net/2023/03/30/TU5VBheikW4LQ2w.png" alt="image-20230330170535464"></p>
<p><img src="https://s2.loli.net/2023/03/30/hPwzM5QqB1UtDjn.png" alt="image-20230330170502109"></p>
<p>整合druid:</p>
<p><img src="https://s2.loli.net/2023/03/30/bgzBwCVoR9dTvsi.png" alt="image-20230330170904214"></p>
<h2 id="为什么DAO层不需要实现类">为什么DAO层不需要实现类</h2>
<p>讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tinpo_123/article/details/125352497">mybatis的DAO接口为什么不需要实现类？</a></p>
<p>因为会<strong>动态代理</strong></p>
<p>在执行<code>mapperInterface</code>这个接口的任何方法之前，都会执行代理<code>mapperProxy</code>对象的<code>invoke</code>方法</p>
<p><img src="https://s2.loli.net/2023/04/03/Kw4bNdcO2QvCeZm.png" alt="image-20230403224344545"></p>
<p>补充一个接口无实现类的验证方法：</p>
<ol>
<li>
<p>新增一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新增动态代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.readSQL(method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">readSQL</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>新增主方法，生成动态代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成动态代理对象</span></span><br><span class="line">        Mapper mapper = (Mapper) Proxy.newProxyInstance(</span><br><span class="line">                Mapper.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Mapper.class&#125;, <span class="keyword">new</span> MapperProxy());</span><br><span class="line">        Integer count = mapper.count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>主函数</p>
<img src="https://s2.loli.net/2023/04/03/xgO1aCmLkfE8P4B.png" alt="image-20230403224916248" style="zoom:67%;" />
</li>
</ol>
<h2 id="AOP术语">AOP术语</h2>
<ol>
<li>
<p><strong>连接点</strong></p>
<p>即为在类中可以被增强的方法。每一个方法就是一个连接点，所有可以被增强的方法都是连接点</p>
</li>
<li>
<p><strong>切入点</strong></p>
<p>即为类中实际被增强的方法。即具体加通知的地方</p>
</li>
<li>
<p><strong>通知（增强）</strong></p>
</li>
</ol>
<p>​		被增强的逻辑部分。通知规定了在什么时机干什么事，切入点规定了在什么地方</p>
<ol start="4">
<li><strong>切面</strong></li>
</ol>
<p>​		所谓切面是一个过程，就是把通知加到切入点上的过程。</p>
<ol start="5">
<li>
<p><strong>织入</strong></p>
<p>把切面应用到目标对象并创建代理对象的过程</p>
</li>
</ol>
<h2 id="AOP的具体实现">AOP的具体实现</h2>
<p>在不惊动原始设计的基础上为其进行功能增强，即无入侵式编程，<strong>可以将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统代码的重复代码和降低模块间的耦合度</strong></p>
<p>AOP有两种实现方式：静态代理和动态代理</p>
<ul>
<li>
<p><strong>静态代理：<strong>代理类在编译阶段生成，在编译阶段将通知植入Java字节码中，也称</strong>编译时增强</strong>，AspectJ使用的是静态代理，静态代理的缺点就是代理对象需要与目标对象实现一样的接口，并且实现接口的方法会有冗余代码，同时，一旦接口增加方法，目标对象与代理对象都要维护</p>
</li>
<li>
<p><strong>动态代理：<strong>在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类，具体来说，如果为Spring的某个bean配置的切面，那创建bean的时候，实际上创建的是这个bean的一个代理对象，后续对bean中方法的调用，实际上调用的是</strong>代理类重写的代理方法</strong>。有两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理</p>
</li>
<li>
<p><strong>JDK动态代理：如果目标实现了接口</strong>，SpringAOP会选择使用JDK动态代理目标类，JDK动态代理的代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口，JDK动态代理的核心是InvocationHandler接口（拦截器）和Proxy类，如果某个类没有实现接口，那这个类就不能用JDK动态代理</p>
</li>
<li>
<p>**CGLib动态代理：如果目标类没有实现接口，**那么AOP会选择使用CGLib来动态代理目标类，全称为Code Generation Library，可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类，CGLib是通过继承的方式实现的动态代理，因此如果某个类被标记为final，那么他是无法使用CGLib做动态代理的，CGLib的优点是目标类不需要实现特定的接口，更加灵活</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/30/U1m5RjhP2KeW7JM.png" alt="image-20230330153320904"></p>
<p><img src="https://s2.loli.net/2023/03/29/EHVfCin3DuXk9ZA.png" alt="image-20230329164943122"></p>
<p><img src="https://s2.loli.net/2023/03/29/UwrhMzcOdAsg6to.png" alt="image-20230329164955091"></p>
<p>连接点，切入点+通知——&gt;切面</p>
<blockquote>
<p>切入点表达式<br>
切入点表达式作用：知道对哪个类里面的哪个方法进行增强<br>
语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) )<br>
举例 1：对 com.csdn.dao.BookDao 类里面的 add 进行增强<br>
execution(* com.csdn.dao.BookDao.add(…))<br>
举例 2：对 com.csdn.dao.BookDao 类里面的所有的方法进行增强<br>
execution(* com.csdn.dao.BookDao.* (…))<br>
举例 3：对 com.csdn.dao 包里面所有类，类里面所有方法进行增强<br>
execution(* com.csdn.dao.<em>.</em> (…))</p>
</blockquote>
<p><strong>在 spring 配置文件中，开启注解扫描</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.csdn&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>
<p><strong>在 spring 配置文件中开启生成代理对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启 Aspect 生成代理对象--&gt; </span><br><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/02/27/fAgWX5jlR6usExo.png" alt="image-20230227210834126"></p>
<p><img src="https://s2.loli.net/2023/02/27/5wOEWZj3JHqUvat.png" alt="image-20230227211059048"></p>
<p><strong>在增强类上面添加注解 @Aspect</strong></p>
<p><img src="https://s2.loli.net/2023/02/27/hvkNTAYqu6241tV.png" alt="image-20230227211109637"></p>
<h2 id="Spring-中-ApplicationContext-和-BeanFactory-的区别">Spring 中 ApplicationContext 和 BeanFactory 的区别</h2>
<p>ApplicationContext 继承了 BeanFactory，BeanFactory 是 Spring 中比较原始的Factory，它不支持 AOP、Web 等 Spring 插件，相当于是Spring框架的一个基础设施，而 ApplicationContext 不仅包含了 BeanFactory的所有功能，还提供了更多面向实际应用的功能，比如国际化以及事件机制，还以一种面向框架的方式工作以及对上下文进行分层和实现继承</p>
<h2 id="BeanFactory和FactoryBean的区别">BeanFactory和FactoryBean的区别</h2>
<p>答：<strong>BeanFactory是一个Factory，是IOC容器的顶级接口，也是访问Spring容器的根接口，<strong>主要是负责Bean的创建和访问，里面有一个getBean方法，同时BeanFactory还能完成对Bean的依赖注入的功能，即DI，</strong>（它是所有Spring Bean的容器根接口，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的，它给Spring 的容器定义一套规范，给IOC容器提供了一套完整的规范）</strong></p>
<blockquote>
<p>⼀般情况下，<strong>Spring</strong>通过反射机制利⽤ <bean><bean> 的<strong>class</strong>属性指定实现类实例化<strong>Bean</strong>，在某些情况下，实例化<strong>Bean</strong>过程⽐较复杂，如果按照传统的⽅式，则需要在 <bean> <bean> 中提供⼤量的配置信息。配置⽅式的灵活性是受限的，这时采⽤编码的⽅式可能会得到⼀个简单的⽅案。</p>
<p>Spring为此提供了⼀个org.springframework.bean.factory.FactoryBean的⼯⼚类接⼝，⽤户可以通过实现该接⼝定制实例化Bean的逻辑。</p>
</blockquote>
<p>FactoryBean<strong>是一个能生产或者修饰对象生成的工厂Bean</strong>，是一个工厂Bean，如果配置了FactoryBean接口，那用户就可以通过实现该接口定制实例化bean，一个比较核心的方法是getObject。如果要使用Bean工厂，可以手动实现一个实现FactoryBean接口的一个类。</p>
<p>通过getObject方法返回一个对象，当用户使用容器本身时，可以使用转义字符<code>”&amp;”</code>来得到FactoryBean本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身，如果beanName没有加&amp;，则获取的是泛型T的对象，如果加了&amp;，获取的是实现了FactoryBean接口本身的对象</p>
<p><img src="https://s2.loli.net/2023/02/19/gYbyu1kczq8DGI7.png" alt="image-20230219155355502"></p>
<p>FactoryBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建好的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回需要创建的对象的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * bean是否是单例的</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="懒加载">懒加载</h2>
<p>lazy-init属性，设置为true</p>
<p>或者在SpringConfig中：@lazy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jt.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.jt.demo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.jt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的 spring 的配置问题。而 ApplicationContext 则相反，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误</p>
<h2 id="单例模式举例">单例模式举例</h2>
<h3 id="懒汉式：">懒汉式：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.防止外部直接 new 对象破坏单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2.通过私有变量保存单例对象【添加了 volatile 修饰】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 3.提供公共获取单例对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 第 1 次检查①</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 第 2 次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); <span class="comment">//②</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，使用了懒加载的方式创建单例实例，即只有在第一次调用 <code>getInstance()</code> 方法时才会实例化 <code>Singleton</code> 类。为了确保线程安全，使用了双重检查锁定（double-checked locking）的方式，使用 <code>synchronized</code> 关键字保证了同步操作。</p>
<p>此外，还将 <code>Singleton</code> 类的构造方法设为 private，这样外部就无法直接实例化该类，只能通过 <code>getInstance()</code> 方法获取该类的唯一实例。</p>
<blockquote>
<p><strong>创建对象的过程，的实际执行分为以下 3 步：</strong></p>
<ol>
<li><strong>创建内存空间。</strong></li>
<li><strong>在内存空间中初始化对象 Singleton。</strong></li>
<li><strong>将内存地址赋值给 instance 对象（执行了此步骤，instance 就不等于 null 了）</strong></li>
</ol>
<p><strong>如果不加 volatile，那么线程 1 在执行到上述代码的第 ② 处时就可能会执行指令重排序，将原本是 1、2、3 的执行顺序，重排为 1、3、2。但是特殊情况下，线程 1 在执行完第 3 步之后，如果来了线程 2 执行到上述代码的第 ① 处，判断 instance 对象已经不为 null，但此时线程 1 还未将对象实例化完，那么线程 2 将会得到一个被实例化“一半”的对象，从而导致程序执行出错，这就是为什么要给私有变量添加 volatile 的原因了。</strong></p>
</blockquote>
<h3 id="饿汉式：">饿汉式：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数私有化，防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取单例实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个实现中，我们在类加载时就创建了一个单例实例，并提供了一个公共的静态方法 <code>getInstance()</code> 来获取该实例。因为在类加载时就已经创建了单例实例，所以它是线程安全的，也就不需要使用synchronized来进行同步。</p>
<h2 id="单例Bean的创建步骤">单例Bean的创建步骤</h2>
<ol>
<li>通过反射实例化bean，生成原生对象引用</li>
<li>如果是scope=singleton且允许环形依赖，添加一个getEarlyBeanReference()到第三级缓存中(处理一下对象)</li>
<li>populateBean()，填充bean引用的对象，也就是依赖注入，这里就是可能触发环形依赖的地方<br>
在给引用赋值时，需要创建引用对象，如果依赖的应用对象引用的当前对象，那么就会触发从三级缓存中获取当前对象，执行早期引用的逻辑，然后升级到二级缓存，并删除三级缓存中当前对象，此时二级缓存中的对象依然是未初始化完成的对象，注意，在升级到二级缓存之后，如果还有动态代理逻辑要处理，这是不行的，因为此时引用已经给出去了，引用的那些对象是拿不到最终的代理对象的，这样会使某些功能失效。所以如果想要在循环依赖时将代理对象返回给其他对象，必须在将代理的创建逻辑放在SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference()中。</li>
<li>initializeBean()，在完成所有的依赖注入后，进行bean的各种后置处理，可以生成代理对象</li>
<li>如果scope=singleton且允许环形依赖，检测一下bean的类型和被其他类型引用的类型是否一致，不一致就要报错</li>
<li>初始化完毕后，调用addSingleton()方法，将bean从二级缓存中提升到一级缓存</li>
</ol>
<h2 id="Spring-IOC的工作流程">Spring IOC的工作流程</h2>
<p>IOC全称为Inversion of control，即控制反转，核心思想是把对象的管理权限交给了容器，好处是降低了对象与对象之间的耦合性</p>
<p><img src="https://s2.loli.net/2023/02/20/npTWvUomzHVul5t.png" alt="image-20230220185143785"></p>
<blockquote>
<p>声明Bean的方式：</p>
<ol>
<li>xml文件中使用<bean></li>
<li>@Service/@Repository/@Component</li>
<li>@Configuration-@Bean(在Configuration配置类里面通过Bean注解去声明)</li>
</ol>
<p>Spring在启动的时候会解析这些Bean，然后保存到IOC容器里面</p>
</blockquote>
<p>IOC的工作流程：</p>
<ol>
<li><strong>IOC容器的初始化阶段</strong>：通过解析和加载后生成的BeanDefinition，然后将BeanDefinition注册到IOC容器里面，把BeanDefinition保存到一个Map集合里面</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/zIx5vlCdG7O3XLb.png" alt="image-20230220191350435"></p>
<ol start="2">
<li><strong>完成Bean的初始化和依赖注入</strong>：会完成两个事情，第一个是通过反射去针对没有设置lazy-init属性的单例bean进行初始化，第二个是完成bean的依赖注入</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/X4nriPvkWbZI3dg.png" alt="image-20230220191642673"></p>
<p><strong>Bean的使用</strong>：通过BeanFactory.getBean()或者@Autowired</p>
<p><img src="https://s2.loli.net/2023/02/20/954EgFj8wWmeCUt.png" alt="image-20230220191810758"></p>
<h3 id="注入-Bean-的注解有哪些？">注入 Bean 的注解有哪些？</h3>
<p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="Autowired和-Resource的区别">@Autowired和@Resource的区别</h2>
<p><img src="https://s2.loli.net/2023/02/22/bYGiImM8p279zaj.png" alt="image-20230222181632905"></p>
<p>@AutoWired先根据属性的类型去Spring容器中找Bean对象，如果找到多个，就会根据名字去确定其中一个，如果根据名字没有找到则会报错；@Resouce会先根据名字取Spring容器中找Bean对象，如果没有则会按照属性，如果还没有则会报错，另外，可以指定@Resouce的name，如果配置了name，则只会找到这个叫name的Bean对象，如果没有找到，就会直接报错，不会再根据类型去找了，@AutoWired是Spring层面提供的，是和Spring强绑定的，@Resouce是JDK层面提供的</p>
<h2 id="Bean的生命周期">Bean的生命周期</h2>
<p>回答：</p>
<ol>
<li>
<p>推断构造方法</p>
</li>
<li>
<p>实例化对象</p>
</li>
<li>
<p>给里面加了AutoWierd注解等属性进行赋值，即依赖注入</p>
</li>
<li>
<p>处理Aware回调</p>
</li>
<li>
<p>初始化前，处理@PostConstruct注解修饰的方法</p>
<p>@PostConstruct是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法</p>
</li>
<li>
<p>初始化，处理InitializingBean接口</p>
<p>Spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中通过init-method指定，两种方式可以同时使用</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInitializingBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ceshi InitializingBean&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ceshi init-method&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化后，进行AOP</p>
</li>
</ol>
<p>具体流程：</p>
<img src="https://s2.loli.net/2023/04/09/hGfibWeHFDAcTK2.png" alt="image-20230409150734885" style="zoom:67%;" />
<p>实例化只是分配了内存空间,并没有进行其他操作！而初始化是真正创建了一个实例,给这块空间存放了数据！</p>
<p><strong>扫描clss得到BeanDefinition—&gt;根据class推断构造方法—&gt;构造方法 —&gt;普通对象—&gt;依赖注入—&gt;初始化前—&gt;初始化—&gt;初始化后(AOP)—&gt;放入单例池map—&gt;Bean对象</strong></p>
<p>依赖注入：给加了@Autowired注解的属性去赋值</p>
<p>初始化：Spring 容器调用 Bean 实例的初始化方·法，可以在 Bean 上使用 @PostConstruct 注解或者实现 InitializingBean 接口来指定初始化方法</p>
<p>单例池map：Map&lt;beanName, Bean对象&gt;</p>
<p>AOP步骤中：将代理对象的某个属性指向前面的普通对象，这样执行完代理逻辑后会执行普通对象的方法</p>
<p><img src="https://s2.loli.net/2023/03/24/gLmfskrijyU725n.png" alt=""></p>
<p><img src="https://s2.loli.net/2023/03/24/okECZtOg9VIn4bu.png" alt="image-20230324142423750"></p>
<h2 id="Spring中Bean的作用域有哪些">Spring中Bean的作用域有哪些</h2>
<ol>
<li>Spring 中 Bean 的作用域通常有下面几种：
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/30/OhQcMUXZG4q9DEl.png" alt="image-20230330141618570"></p>
<p>区别：</p>
<p><img src="https://s2.loli.net/2023/04/09/6HthYgaCVI58JPF.png" alt="image-20230409162550650"></p>
<p><img src="https://s2.loli.net/2023/03/30/D3Nc41ro8OCQ5By.png" alt="image-20230330141914103"></p>
<h2 id="循环依赖">循环依赖</h2>
<p><strong>假如A依赖B,B依赖A,先创建A只实例话但未属性填充的bean实例，并将bean的objectFactory放到三级缓存singletonFactories中提前曝光，接着执行populateBean()进行属性填充,填充时需要B，在缓存中未找到，所以如A的流程一样创建B的实例，对B进行属性填充时需要A,会从一二三级缓存中依次找，如果在三级缓存中找到了A的 ObjectFactory ，则通过执行他的getObject方法获取提前曝光的bean,并将bean放到二级缓存，然后注入，填充完后对B进行初始化，此时B是一个完整的对象会将他放到一级缓存中，B创建完后，A就可进行属性注入了，初始化完后也放到一级缓存中，从而避免了死循环</strong></p>
<p><img src="https://s2.loli.net/2023/04/13/bxusdRmADzVwfIB.png" alt="image-20230413172734585"></p>
<blockquote>
<ol>
<li>singletonObjects：缓存已经创建好的单例 Bean 实例，即经历了完整生命周期的bean对象</li>
<li>earlySingletonObjects：缓存正在创建中的 Bean 实例（进行了AOP之后得到的代理对象），还未进行属性注入。</li>
<li>singletonFactories：缓存 Bean 工厂对象，用于创建某个对象，解决循环依赖（存的是某个beanName对应的ObjectFactory  ）。</li>
</ol>
</blockquote>
<blockquote>
<p>以下三个Map均来自于 DefaultSingletonBeanRegistry<br>
Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);<br>
Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);<br>
Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap&lt;&gt;(16);</p>
<p>singletonObjects：用于保存BeanName和创建bean实例之间的关系，bean name 一＞ bean instance。<br>
singletonFactories：用于保存BeanName和创建bean的工厂之间的关系，bean name 一＞ObjectFactory。<br>
earlySingletonObjects：也是保存BeanName和创建bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例bean被放到这里面后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其目的是用来检测循环引用。<br>
总结： 后面两个Map实际上就是为了辅助第一个Map缓存Bean的实例，完成后数据就在后面两个Map中清掉了。</p>
</blockquote>
<p>一级缓存(SingletonObjects)：<strong>单例池，保存经过完整生命周期的Bean</strong></p>
<p>二级缓存(earlySingletonObjects)：<strong>保存出现循环依赖的Bean，方便提前给其他Bean使用的单例Bean（保存提前曝光的对象的代理对象）</strong></p>
<p>三级缓存(SingletonFactories)：<strong>用于打破循环，在AOP前拿到普通对象，执行lamda表达式后返回一个代理对象或者普通对象，然后放到二级缓存中，并移除lamda表达式</strong>（源码为：只要是单例Bean，并且处于循环依赖下，并且需要的Bean在创建中，就会生成lamda表达式并放入三级缓存中），<strong>在bean的⽣命周期中，⽣成完原始对象之后，就会构造⼀个ObjectFactory存⼊singletonFactories中</strong></p>
<h3 id="三级缓存解决不了的场景">三级缓存解决不了的场景</h3>
<p>有参构造中</p>
<p><img src="https://s2.loli.net/2023/03/24/Q9r7D8cyXspL1qn.png" alt="image-20230324150203973"></p>
<p>解决：@lazy注解</p>
<h2 id="循环依赖过程">循环依赖过程</h2>
<blockquote>
<p>假设此时我们只有两个Bean的相互依赖</p>
</blockquote>
<ol>
<li>
<p>A创建过程中需要 B 于是 A 将自己放到三级缓里面,去实例化 B</p>
</li>
<li>
<p>B实例化的时候发现需要 A ,于是 B 先查一级缓存,没有,再查二级缓存,还是没有,再查三级缓存,找到了 A 然后把三级缓存里面的这个 A 放到二级缓存里面,并删除三级缓存里面的 A</p>
</li>
<li>
<p>B顺利初始化完毕,将自己放到一级缓存里面(此时 B 里面的 A 依然是创建中状态)然后回来接着创建 A ,此时 B 己经创建结束,直接从一级缓存里面拿到 B ,然后完成创建,并将 A 自己放到一级缓存里面。</p>
</li>
</ol>
<p><strong>如果注入的都是普通对象的话，一级缓存和二级缓存已经能解决循环依赖问题。</strong></p>
<blockquote>
<p>但是如果是代理对象的话，如果只有一级缓存和二级缓存，那在对象实例化之后就必须要马上创建一个代理对象，这样就违背了 Spring 结合 AOP 跟 Bean 的生命周期的设计，Spring 结合 AOP 跟 Bean 的生命周期本身就是通过 AnnotationAwareAspectJAutoProxyCreator 这个后置处理器来完成的，所以 Spring 才会通过三级缓存来保证创建普通对象和创建代理对象时 bean 的生命周期流程统一。</p>
</blockquote>
<p><strong>如果注入的是被AOP管理的对象，那么就需要在单例池当中注入被动态代理的对象，而不是原对象。</strong></p>
<p><img src="https://s2.loli.net/2023/04/13/cxfbETa34ZUDp2m.png" alt="image-20230413170958879"></p>
<h2 id="创建Bean实例">创建Bean实例</h2>
<p>详细讲解+举例：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46228112/article/details/124342630">Spring系列之创建bean实例的方式</a></p>
<ol>
<li>
<p>通过反射调用构造方法创建bean对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean名称&quot;</span> <span class="attr">name</span>=<span class="string">&quot;bean名称或者别名&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean的完整类型名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;n&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>constructor-arg用于指定构造方法参数的值</p>
<p>index：构造方法中参数的位置，从0开始，依次递增</p>
<p>value：指定参数的值</p>
<p>ref：当插入的值为容器内其他bean的时候，这个值为容器中对应bean的名称</p>
</blockquote>
</li>
<li>
<p>通过静态工厂方法创建bean对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean名称&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;静态工厂完整类名&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;静态工厂的方法&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;n&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过工厂静态无参方法创建bean对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;createBeanByStaticFactoryMethod1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javacode2018.lesson001.demo3.UserStaticFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;buildUser1&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 通过工厂静态有参方法创建bean对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;createBeanByStaticFactoryMethod2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javacode2018.lesson001.demo3.UserStaticFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;buildUser2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;通过工厂静态有参方法创建UerModel实例对象&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过实例工厂方法创建bean对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean名称&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;需要调用的实例对象bean名称&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;bean对象中的方法&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;n&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义一个工厂实例 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.javacode2018.lesson001.demo3.UserFactory&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 通过userFactory实例的无参user方法创建UserModel对象 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;createBeanByBeanMethod1&quot;</span> factory-bean=<span class="string">&quot;userFactory&quot;</span> factory-method=<span class="string">&quot;buildUser1&quot;</span>/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 通过userFactory实例的有参user方法创建UserModel对象 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;createBeanByBeanMethod2&quot;</span> factory-bean=<span class="string">&quot;userFactory&quot;</span> factory-method=<span class="string">&quot;buildUser2&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg index=<span class="string">&quot;0&quot;</span> value=<span class="string">&quot;通过bean实例有参方法创建UserModel实例对象&quot;</span>/&gt;</span><br><span class="line">    &lt;constructor-arg index=<span class="string">&quot;1&quot;</span> value=<span class="string">&quot;30&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过FactoryBean创建bean对象</p>
<p>举例：</p>
<p><strong>创建一个FactoryBean实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javacode2018.lesson001.demo3;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">UserModel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserModel <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//@1</span></span><br><span class="line">        UserModel userModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">        userModel.setName(<span class="string">&quot;我是通过FactoryBean创建的第&quot;</span>+count+++ <span class="string">&quot;对象&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserModel.class; <span class="comment">//@2</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//@3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@1：返回了一个创建好的UserModel对象</p>
<p>@2：返回对象的Class对象</p>
<p>@3：返回true，表示创建的对象是单例的，那么我们每次从容器中获取这个对象的时候都是同一个对象</p>
<p><strong>bean xml配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过FactoryBean 创建UserModel对象 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;createByFactoryBean&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.javacode2018.lesson001.demo3.UserFactoryBean&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>主函数：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javacode2018.lesson001.demo3;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.bean配置文件位置</span></span><br><span class="line">        String beanXml = <span class="string">&quot;classpath:/com/javacode2018/lesson001/demo3/beans.xml&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2.创建ClassPathXmlApplicationContext容器，给容器指定需要加载的bean配置文件</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(beanXml);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;spring容器中所有bean如下：&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//getBeanDefinitionNames用于获取容器中所有bean的名称</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(beanName + <span class="string">&quot;:&quot;</span> + context.getBean(beanName));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//多次获取createByFactoryBean看看是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;createByFactoryBean:&quot;</span> + context.getBean(<span class="string">&quot;createByFactoryBean&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;createByFactoryBean:&quot;</span> + context.getBean(<span class="string">&quot;createByFactoryBean&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">javacode2018</span>.<span class="title">lesson001</span>.<span class="title">demo3</span>.<span class="title">UserStaticFactory</span>.<span class="title">buildUser1</span>()</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">javacode2018</span>.<span class="title">lesson001</span>.<span class="title">demo3</span>.<span class="title">UserStaticFactory</span>.<span class="title">buildUser2</span>()</span></span><br><span class="line"><span class="class">----------------------1</span></span><br><span class="line"><span class="class">----------------------2</span></span><br><span class="line"><span class="class"><span class="title">spring</span>容器中所有<span class="title">bean</span>如下：</span></span><br><span class="line"><span class="class"><span class="title">createBeanByConstructor1</span>:<span class="title">UserModel</span>(<span class="title">name</span></span>=我是通过UserModel的无参构造方法创建的!, age=<span class="number">0</span>)</span><br><span class="line">createBeanByConstructor2:UserModel(name=我是通过UserModel的有参方法构造的对象!, age=<span class="number">30</span>)</span><br><span class="line">createBeanByStaticFactoryMethod1:UserModel(name=我是无参静态构造方法创建的!, age=<span class="number">0</span>)</span><br><span class="line">createBeanByStaticFactoryMethod2:UserModel(name=通过工厂静态有参方法创建UerModel实例对象, age=<span class="number">30</span>)</span><br><span class="line">userFactory:com.javacode2018.lesson001.demo3.UserFactory@610694f1</span><br><span class="line">createBeanByBeanMethod1:UserModel(name=bean实例方法创建的对象!, age=<span class="number">0</span>)</span><br><span class="line">createBeanByBeanMethod2:UserModel(name=通过bean实例有参方法创建UserModel实例对象, age=<span class="number">30</span>)</span><br><span class="line">createByFactoryBean:UserModel(name=我是通过FactoryBean创建的第<span class="number">1</span>对象, age=<span class="number">0</span>)</span><br><span class="line">--------------------------</span><br><span class="line">createByFactoryBean:UserModel(name=我是通过FactoryBean创建的第<span class="number">1</span>对象, age=<span class="number">0</span>)</span><br><span class="line">createByFactoryBean:UserModel(name=我是通过FactoryBean创建的第<span class="number">1</span>对象, age=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="懒汉模式和饿汉模式">懒汉模式和饿汉模式</h2>
<p>懒汉模式和饿汉模式是单例模式的两种实现方式。</p>
<p><strong>懒汉</strong></p>
<p>懒汉模式：在需要获取单例对象时才会实例化该对象，如果未被创建，则创建该对象。懒汉模式的实现中需要注意多线程环境下的线程安全问题。</p>
<p>问题：如果在多线程环境下，有两个线程同时调用 <code>getInstance()</code> 方法，那么有可能会创建出两个不同的 <code>Singleton</code> 实例，这就违反了单例模式的要求。</p>
<p>解决：可以在 <code>getInstance()</code> 方法上加上同步锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="comment">//修改为线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>饿汉</strong></p>
<p>饿汉模式：在类被加载时就会创建单例对象，因此可以保证线程安全，但可能会浪费一些系统资源。</p>
<p>在饿汉模式中，由于 <code>instance</code> 静态成员变量在类加载时就被初始化，因此可以保证线程安全。但是，这也意味着如果该单例对象没有被使用到，也会占用一定的系统资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring中实现数据库事务的方法">Spring中实现数据库事务的方法</h2>
<p>讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jieandan/article/details/110871271">Spring事务管理之编程式事务管理和声明式事务</a></p>
<ol>
<li>
<p>声明式事务管理</p>
<p><strong>可知编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现</strong></p>
<p>使用Spring的声明式事务管理，通过在XML或注解中配置事务属性，可以将数据库事务的控制从业务代码中分离出来。在Spring中，声明式事务管理有两种实现方式：</p>
<ul>
<li>
<p>**基于XML的声明式事务管理：**通过配置XML文件中的AOP切面和事务属性，来实现声明式事务管理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置c3po连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入属性值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/wangyiyun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;153963&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一步：配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入dataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">&lt;!-- 第二步：配置事务增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 做事务操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置进行事务操作的方法匹配规则 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- account开头的所有方法 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">          propagation:事务传播行为； </span></span><br><span class="line"><span class="comment">          isolation：事务隔离级别；</span></span><br><span class="line"><span class="comment">          read-only：是否只读；</span></span><br><span class="line"><span class="comment">          rollback-for：发生那些异常时回滚 </span></span><br><span class="line"><span class="comment">          timeout:事务过期时间</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;account*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">&lt;!-- 第三步：配置切面 切面即把增强用在方法的过程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.itcast.service.OrdersService.*(..))&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;pointcut1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">&lt;!-- 对象生成及属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ordersService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.service.OrdersService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ordersDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ordersDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ordersDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.dao.OrdersDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**基于注解的声明式事务管理：**通过使用@Transactional注解，在业务方法上声明事务属性，来实现声明式事务管理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置c3po连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入属性值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/wangyiyun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;153963&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一步：配置事务管理器 (和配置文件方式一样)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入dataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二步： 开启事务注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第三步 在方法所在类上加注解 --&gt;</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">&lt;!-- 对象生成及属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ordersService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.service.OrdersService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ordersDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ordersDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ordersDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.dao.OrdersDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用@Transactional注意点：</p>
<ul>
<li>如果在接口、实现类或方法上都指定了@Transactional 注解，则优先级顺序为方法&gt;实现类&gt;接口；</li>
<li>建议只在实现类或实现类的方法上使用@Transactional，而不要在接口上使用，这是因为如果使用JDK代理机制（基于接口的代理）是没问题；而使用使用CGLIB代理（继承）机制时就会遇到问题，因为其使用基于类的代理而不是接口，这是因为接口上的@Transactional注解是“不能继承的”；</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编程式事务管理</p>
<p>通过<strong>Transaction Template手动管理事务</strong>，实际应用中很少使用</p>
<p>在Spring中，通过编写代码来实现事务控制也是一种常见的事务管理方式，这种方式称为编程式事务管理。在编程式事务管理中，业务代码需要显式地调用事务管理器的API，来开启、提交或回滚事务。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置c3po连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/wangyiyun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;153963&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 编程式事务管理 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入dataSource --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器模板 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionTemplate&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.support.TransactionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入真正进行事务管理的事务管理器,name必须为 transactionManager否则无法注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 对象生成及属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ordersService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.service.OrdersService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ordersDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ordersDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入事务管理的模板 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ordersDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.dao.OrdersDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JDBC模板对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Transactional具体实现原理">@Transactional具体实现原理</h2>
<p>@Transactional是一个注解，通常用于在Spring框架中处理事务。它可以应用于类或方法级别，并指示Spring在执行受注解标记的方法或类的操作时开启一个事务。如果方法或类内部存在多个数据操作，Spring会将这些操作作为一个单元来处理，并将它们视为一个整体，如果整体操作成功，则提交整个事务，否则回滚整个事务。</p>
<p>@Transactional的具体实现原理可以概括为以下几个步骤：</p>
<ol>
<li>首先，Spring会检查当前线程是否已经存在一个事务。如果不存在，它将创建一个新的事务。</li>
<li>接下来，Spring将在事务管理器中开启一个新的事务。</li>
<li>在执行受@Transactional标记的方法或类的操作之前，Spring会在当前线程中存储事务状态。这个状态包括事务的隔离级别、超时时间和只读属性等信息。</li>
<li>当受@Transactional标记的方法或类的操作完成时，Spring会检查操作是否成功。如果成功，它将提交事务，否则将回滚事务。</li>
<li>最后，Spring将恢复存储在当前线程中的事务状态，并关闭事务。</li>
</ol>
<p>总之，@Transactional的具体实现原理就是通过将所有的数据操作作为一个整体来处理，以保证整个事务的一致性和完整性。如果其中任何一个操作失败，整个事务都会被回滚，以确保数据的正确性。</p>
<h2 id="黑马Spring事务实现">黑马Spring事务实现</h2>
<p>三步：</p>
<p><img src="https://s2.loli.net/2023/02/27/z8RwDFpUWo3CX4T.png" alt="image-20230227212149992"></p>
<p>②设置事务管理器</p>
<p><img src="https://s2.loli.net/2023/02/27/EVohKeBqst8y4L9.png" alt=""></p>
<p>③开启注解式事务驱动</p>
<p><img src="https://s2.loli.net/2023/02/27/flvdZTyRtQFOuN6.png" alt="image-20230227211918009"></p>
<p>@Transactional一般放在接口里不放在实现类里，为了降低耦合</p>
<h2 id="spring事务的失效场景">spring事务的失效场景</h2>
<p>讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013733643/article/details/124042643?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124042643-blog-109117355.235%5Ev28%5Epc_relevant_t0_download&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124042643-blog-109117355.235%5Ev28%5Epc_relevant_t0_download&amp;utm_relevant_index=5">12种场景Spring事务会失效</a></p>
<ol>
<li><strong>事务方法访问修饰符非public，导致事务失效：</strong> spring要求被代理方法必须是<strong>public</strong>的，如果事务是<strong>static、final或者private、default、protected</strong>的，同样无法通过动态代理，事务也是不会生效的</li>
<li><strong>同一个类里面，方法的自调用</strong>：即直接调用了this对象的方法，理由是：不会生成动态代理对象</li>
<li>**@Transactional注解所在的类未被Spring管理，忘记添加@Service等：**因为使用spring事务的前提是：对象要被spring管理，需要创建bean实例</li>
<li>**数据表本身是不支持事务：**如MyISAM</li>
<li>**多线程调用，导致事务失效：**会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务</li>
<li>@Transactional注解的方法抛出的异常不是spring的事务支持的异常，导致事务失效<img src="https://s2.loli.net/2023/04/10/GVofmkaW9v2PxQY.png" alt="image-20230410155603668"></li>
</ol>
<h2 id="事务失效">事务失效</h2>
<p><strong>原因：</strong><br>
spring 在扫描bean的时候会扫描方法上是否包含@Transactional注解，如果包含，spring会为这个bean动态地生成一个子类（即代理类，proxy），代理类是继承原来那个bean的。此时，当这个有注解的方法被调用的时候，实际上是<strong>由代理类来调用的</strong>，代理类在调用之前就会启动transaction。然而，<strong>如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个bean</strong>，所以就不会启动transaction，我们看到的现象就是@Transactional注解无效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactinal</span></span><br><span class="line">    <span class="function">method <span class="title">b</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">method <span class="title">a</span><span class="params">()</span></span>&#123;    <span class="comment">//标记1</span></span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring扫描注解后，创建了另外一个代理类，并为有注解的方法插入一个startTransaction()方法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proxy</span>$<span class="title">A</span></span>&#123;</span><br><span class="line">    A objectA = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function">method <span class="title">b</span><span class="params">()</span></span>&#123;    <span class="comment">//标记2</span></span><br><span class="line">        startTransaction();</span><br><span class="line">        objectA.b();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">method <span class="title">a</span><span class="params">()</span></span>&#123;    <span class="comment">//标记3</span></span><br><span class="line">        objectA.a();    <span class="comment">//由于a()没有注解，所以不会启动transaction，而是直接调用A的实例的a()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用A的bean的a()方法的时候，也是被proxyA拦截，执行proxyA.a()拦截（标记3），然而，由以上代码可知，这时候它调用的是objectA.a()，也就是由原来的bean来调用a()方法了，所以代码跑到了“标记1”。由此可见，“标记2”并没有被执行到，所以startTransaction()方法也没有运行。</p>
<p>解决：</p>
<ol>
<li>把这两个方法分开到不同的类中；</li>
<li>把注解加到类名上面；</li>
</ol>
<h2 id="事务的传播级别">事务的传播级别</h2>
<p>详细讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/java_atguigu/article/details/124474849">Spring事务的传播级别</a></p>
<p>默认为：Propagation_required</p>
<p><img src="https://s2.loli.net/2023/03/24/3gVJKtQPrMROu6Z.png" alt="image-20230324150808482"></p>
<h2 id="“-”和“-”的区别">“#{}”和“${}”的区别</h2>
<p>答：都是Mybatis里面提供的两种实现动态SQL的方式，可以把参数传递到XML里面，#等同于JDBC里面的“？”占位符，PreparedStatement，“#”可以防止SQL注入，属于动态参数，适合于动态传递表名，动态设置排序字段，而使用“$”相当于直接把参数拼接到了原式SQL里面，Mybatis不会对它进行任何的特殊处理</p>
<blockquote>
<p>#{}将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如果传入的值是1111,那么解析成sql时的值为 “1111”, 如果传入的值是id，则传入 “id”.</p>
<p>${} 则只是简单的字符串替换，在动态解析阶段，该 sql 语句会直接将变量值替换进去，这样就有可能会发生sql注入的风险。</p>
<p>${}将传入的数据直接替换，如果传入的值是1111,那么解析成sql时的值为 1111, 如果传入的值是id，则传入 id</p>
</blockquote>
<p><strong>在传入关键字时，不可以使用#{}，在传入普通字符串时，不可以使用${}</strong></p>
<h2 id="DI的方式">DI的方式</h2>
<h3 id="Setter注入">Setter注入</h3>
<h4 id="引用类型">引用类型</h4>
<p>property标签，name属性+ref属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单属性">简单属性</h4>
<p>property标签，name属性+value属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造器注入">构造器注入</h3>
<h4 id="引用类型-2">引用类型</h4>
<p>constructor-arg标签，name属性+ref属性</p>
<p>其中name是构造器的形参，所以耦合度较高</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单属性-2">简单属性</h4>
<p>constructor-arg标签，name属性+value属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自动配置">自动配置</h3>
<ul>
<li>==按类型（常用）==：要求类型匹配必须唯一</li>
<li>按名称</li>
<li><img src="https://s2.loli.net/2023/02/27/rfscMWoCx4HjmSn.png" alt="image-20230227204257803"></li>
</ul>
<h2 id="纯注解开发">纯注解开发</h2>
<p>新建一个config包下的SpringConfig，这样就不用配置了，然后加上@Configuration，再写上@ComponentScan</p>
<p><img src="https://s2.loli.net/2023/02/27/HDKvaVkbyATXoNx.png" alt="image-20230227204844510"></p>
<p>然后换为注解开发加载配置类：</p>
<p><img src="https://s2.loli.net/2023/02/27/sVH4yKon73DMXO5.png" alt="image-20230227204919629"></p>
<p><img src="https://s2.loli.net/2023/02/27/xnrgtjTJBGquAf7.png" alt="image-20230227204949788"></p>
<p>在类中比如BookDaoImpl加上@Component，等价于<bean></p>
<p><img src="https://s2.loli.net/2023/02/27/7VmpXDKyAzxrvfC.png" alt="image-20230227205137500"></p>
<p>如果有多个相同类型的Bean，则：</p>
<p>@Autowired：使用暴力反射，故无需setter方法</p>
<p>@Qualifier(“Bean名称”)</p>
<p>如果是简单类型注入，则@Value</p>
<p>如果是外部properties注入，则先把SpringConfig加上@PropertySource(“jdbc.properties”)，然后改为@Value(“${name}”)，即可把properties里面的name注入</p>
<h2 id="将一个类声明为-Bean-的注解有哪些">将一个类声明为 Bean 的注解有哪些?</h2>
<p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要<strong>想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类</strong>,可以采用以下注解实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
<h2 id="Component和-Bean注解的区别">@Component和@Bean注解的区别</h2>
<p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p>
<blockquote>
<p>@Bean表示当前方法返回值是一个bean（黑马），一般用于管理第三方Bean，然后用@Import注解手动加入配置类到核心配置</p>
</blockquote>
<p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p>
<p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p>
<h2 id="ComponentScan">@ComponentScan</h2>
<p><img src="https://s2.loli.net/2023/04/04/HEBd9sf1PM5envX.png" alt="image-20230404223013143"></p>
<h2 id="Import">@Import</h2>
<p><img src="https://s2.loli.net/2023/04/04/4K3foqlH15dbJwz.png" alt="image-20230404223102112"></p>
<p>示例：</p>
<p><img src="https://s2.loli.net/2023/04/04/PuZFLD1UizaYNlQ.png" alt="image-20230404223153640"></p>
<h2 id="SpringBoot注解">SpringBoot注解</h2>
<h3 id="SpringBootConfiguration-注解">@SpringBootConfiguration 注解</h3>
<p>这个注解我们点进去就可以发现，它实际上就是一个 @Configuration 注解，这个注解大家应该很熟悉了，加上这个注解就是为了让当前类作为一个配置类交由 Spring 的 IOC 容器进行管理</p>
<p><strong>@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan</strong></p>
<h3 id="ComponentScan-注解">@ComponentScan 注解</h3>
<p>这个注解也很熟悉，用于定义 Spring 的扫描路径，等价于在 xml 文件中配置 context:component-scan，假如不配置扫描路径，那么 Spring 就会默认扫描当前类所在的包及其子包中的所有标注了 @Component，@Service，@Controller 等注解的类</p>
<h2 id="Mybatis和JDBC的区别">Mybatis和JDBC的区别</h2>
<ol>
<li>内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高</li>
<li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li>
</ol>
<h2 id="JDBC操作数据库">JDBC操作数据库</h2>
<ol>
<li>
<p>装载加载JDBC驱动并进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>建立数据库连接，获得 Connection 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据用户的输入组装查询 SQL 语句</p>
</li>
<li>
<p>根据 SQL 语句建立 Statement 对象 或者 PreparedStatement 对象</p>
</li>
<li>
<p>用 Connection 对象执行 SQL语句，获得结果集 ResultSet 对象。</p>
</li>
<li>
<p>处理和显示结果</p>
<ul>
<li>
<p>一条一条读取结果集 ResultSet 对象中的数据。</p>
</li>
<li>
<p>根据读取到的数据，按特定的业务逻辑进行计算。</p>
</li>
<li>
<p>根据计算得到的结果再组装更新 SQL 语句。</p>
</li>
<li>
<p>再使用 Connection 对象执行更新 SQL 语句，以更新数据库中的数据。</p>
</li>
</ul>
</li>
<li>
<p>释放资源，依次关闭各个 Statement 对象和 Connection 对象</p>
</li>
</ol>
<h2 id="MyBatis新建一个查询要做那些事情？">MyBatis新建一个查询要做那些事情？</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58342797/article/details/127324984">MyBatis基本操作_mybatis 查询表结构_</a></p>
<ol>
<li>
<p>查看表结构</p>
</li>
<li>
<p>根据表结构，创建对应类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> class_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span><span class="comment">//让这个接口被MyBatis框架接收、</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectByIdMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;<span class="comment">//根据id获取Student对象</span></span><br><span class="line"><span class="comment">//Param 表示在xml中对应获取的参数名称也是id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>xml文件实现接口的方法（这个文件的命名，和配置文件保持一致）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.example.demo.Mapper.SelectByIdMapper&quot;</span>&gt;</span><br><span class="line">&lt;!--&gt;namespace 绑定xml文件实现的接口 包名+类名  &lt;--&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;select id=<span class="string">&quot;getStudentById&quot;</span> resultType=<span class="string">&quot;com.example.demo.Model.Student&quot;</span>&gt;</span><br><span class="line">&lt;!--        这个id，表示实现StudentMapper接口的哪一个方法--&gt;</span><br><span class="line">&lt;!--        resultType 表示方法的返回类型--&gt;</span><br><span class="line"> </span><br><span class="line">        select * from student where id=$&#123;id&#125;</span><br><span class="line">&lt;!--        这里写具体的执行语句--&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol start="5">
<li>
<p><strong>Controll层，接收前端数据，调用Service层处理业务逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentControl</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//属性注入</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getstudentbyid&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudentById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> studentService.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Service层：处理业务逻辑，调用数据库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService &#123;</span><br><span class="line">    //使用StudentMapper对象 属性注入</span><br><span class="line">    @Autowired</span><br><span class="line">    private SelectByIdMapper selectByIdMapper;</span><br><span class="line"> </span><br><span class="line">    public Student getStudentById(Integer id) &#123;</span><br><span class="line">        return selectByIdMapper.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Mapper层：执行数据库操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span><span class="comment">//让这个接口被MyBatis框架接收、</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectByIdMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;<span class="comment">//根据id获取Student对象</span></span><br><span class="line"><span class="comment">//Param 表示在xml中对应获取的参数名称也是id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工厂模式举例">工厂模式举例</h2>
<img src="https://s2.loli.net/2023/03/23/gQbBt9vZCYJyMEX.png" alt="image-20230323230856964" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/JeAoBz9OWIRmTap.png" alt="image-20230323230904083" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/iuoR94sgzx5vED2.png" alt="image-20230323230911265" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/gUyOabKxIufjERN.png" alt="image-20230323230919429" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/RwoE1Vl9cY2QDuG.png" alt="image-20230323231006771" style="zoom:67%;" />
<h2 id="Log4j的4个级别">Log4j的4个级别</h2>
<p>优先级从高到低分别是ERROR、WARN、INFO、DEBUG</p>
<ol>
<li>DEBUG 指定细粒度信息事件是最有用的应用程序调试，一般使用log.debug()进行跟踪调试</li>
<li>INFO 指定能够突出在粗粒度级别的应用程序运行情况的信息的消息，就是输出提示信息。info级别监控系统运行情况，可以帮助程序员有效的了解程序的流转</li>
<li>WARN 指定具有潜在危害的情况，一般很少使用</li>
<li>ERROR  错误事件可能仍然允许应用程序继续运行。就是显示错误信息。比如接口访问超时，用try/catch 捕获异常，发生异常的时候log.error输出错误信息，并不影响程序的运行</li>
</ol>
<h2 id="Tomcat和Servlet容器">Tomcat和Servlet容器</h2>
<img src="https://s2.loli.net/2023/03/29/xDurA9JVePoRY6W.png" alt="image-20230329220919033" style="zoom:67%;" />
<p>Servlet容器的作用：负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个 Servlet，并把Servlet的执行结果返回给客户</p>
<p>Tomcat是一个servlet容器，实现了对Servlet和JSP的支持，除此之外，tomcat还可以作为 一个web应用服务器</p>
<p>Tomcat服务器接受客户请求并做出响应的过程如下：</p>
<ol>
<li><strong>客户端（通常都是浏览器）访问Web服务器，发送HTTP请求。</strong></li>
<li><strong>Web服务器接收到请求后，传递给Servlet容器。</strong></li>
<li><strong>Servlet容器加载Servlet，产生Servlet实例后，向其传递表示请求和响应的对象。</strong></li>
<li><strong>Servlet实例使用请求对象得到客户端的请求信息，然后进行相应的处理。</strong></li>
<li><strong>Servlet实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web服务器。</strong></li>
</ol>
<h1>JVM</h1>
<h2 id="为什么要在虚拟机中运行">为什么要在虚拟机中运行</h2>
<ol>
<li>
<p>JVM提供了<strong>跨平台</strong>的特性</p>
<p>通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，即 Java 字节码，实现**“一次编写，到处运行”**。</p>
</li>
<li>
<p>JVM提供了<strong>自动内存管理与垃圾回收</strong>的能力</p>
<p>带来了一个托管环境，能够代替我们处理一些代码中冗长而且容易出错的部分</p>
</li>
<li>
<p>JVM提供了诸如数组越界、动态类型、安全权限等的<strong>动态检测能力</strong></p>
<p>可以免于书写这些无关业务逻辑的代码</p>
</li>
</ol>
<h2 id="同步和异步的区别">同步和异步的区别</h2>
<p>同步：同步是指<strong>一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。</strong></p>
<p>异步：<strong>异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理</strong>，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。</p>
<blockquote>
<p>同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。</p>
<p>异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。</p>
</blockquote>
<p><strong>同步的好处：</strong></p>
<ol>
<li>同步流程对结果处理通常更为简单，可以就近处理。</li>
<li>同步流程对结果的处理始终和前文保持在一个上下文内。</li>
<li>同步流程可以很容易捕获、处理异常。</li>
<li>同步流程是最天然的控制过程顺序执行的方式。</li>
</ol>
<p><strong>异步的好处：</strong></p>
<ol>
<li>异步流程可以立即给调用方返回初步的结果。</li>
<li>异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。</li>
<li>异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。</li>
<li>异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。</li>
</ol>
<h2 id="并发和并行的区别">并发和并行的区别</h2>
<img src="https://s2.loli.net/2023/03/08/uVQWge2iH8ZxBca.png" alt="image-20230308223900844" style="zoom: 67%;" />
<h2 id="JMM内存模型">JMM内存模型</h2>
<p>是 Java 定义的并发编程相关的一组规范，它抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，增强程序可移植性</p>
<p>比如happens-before 原则来解决指令重排序问题，<strong>想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p>
<blockquote>
<p><strong>程序顺序规则</strong> ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</p>
<p><strong>解锁规则</strong> ：解锁 happens-before 于加锁；</p>
<p><strong>volatile 变量规则</strong> ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</p>
<p><strong>传递规则</strong> ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</p>
<p><strong>线程启动规则</strong> ：Thread 对象的 <code>start()</code>方法 happens-before 于此线程的每一个动作。</p>
<p>如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/06/dnk3C9i1gZ42mOM.png" alt="image-20230406205143035"></p>
<h2 id="JAVA内存结构">JAVA内存结构</h2>
<img src="https://s2.loli.net/2023/04/06/rbnc1VWKkOqiN3Y.png" alt="image-20230406153919703" style="zoom:80%;" />
<img src="https://s2.loli.net/2023/04/06/NUYHQSAWRrOItm9.png" alt="image-20230406153335523" style="zoom:67%;" />
<ol>
<li>
<p>**堆：**存放对象实例，分为新生代和老年代，其中新⽣代又分为Eden区，From Survivor和To Survivor区，⽐例是8:1:1</p>
</li>
<li>
<p><strong>方法区：<strong>存储已经被虚拟机加载的</strong>类信息，字段信息，方法等描述信息，常量，静态变量，即时编译器编译后的代码缓存</strong>（永久代，jkd1.8后改为元空间）</p>
</li>
<li>
<p>**虚拟机栈：**局部变量表，操作数栈，动态链接，方法返回地址</p>
<ul>
<li><strong>局部变量表：<strong>存放了编译期可知的</strong>各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong></li>
<li><strong>操作数栈：<strong>主要作为方法调用的中转站使用，用于</strong>存放方法执行过程中产生的中间计算结果</strong>。另外，计算过程中产生的临时变量也会放在操作数栈中。</li>
<li>**动态链接：**主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong></li>
<li><strong>方法返回地址</strong></li>
</ul>
</li>
<li>
<p>**程序计数器：**保存下一条需要执行的字节码指令（可以为空）</p>
<ul>
<li>
<p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
</li>
<li>
<p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
</li>
</ul>
</li>
<li>
<p>**本地方法栈：**与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;类体重定义的name&quot;</span>;			<span class="comment">//类中的成员变量并赋值</span></span><br><span class="line"> </span><br><span class="line">	People()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;类体方法中定义的name&quot;</span>;		<span class="comment">//在方法speak中定义和成员变量名字相同的name并赋值</span></span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name);		<span class="comment">//通过this来访问类中的成员变量</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThis</span> </span>&#123;                              <span class="comment">//源文件中只能有一个类是public类，并且源文件的名字必须与这个类的//名字完全相同，如果没有public类，那么源文件的名字只要和某个类的名字相同就可以了。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">		People myPeople = <span class="keyword">new</span> People();</span><br><span class="line">		myPeople.speak();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/02/28/rFUx1wWBl7YkO6A.png" alt="image-20230228161331502"></p>
<p><img src="https://s2.loli.net/2023/02/28/u2UX19jkl6TsEnF.png" alt="image-20230228161317419"></p>
<p><img src="https://s2.loli.net/2023/03/01/Ljd57vMagfht6xu.png" alt="image-20230301144634000"></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1714914983791082793&amp;wfr=spider&amp;for=pc">运行时数据区 (baidu.com)</a></p>
<h2 id="OOM问题">OOM问题</h2>
<p>除了程序计数器不会产⽣OOM，其余的均可以产⽣OOM</p>
<p><strong>堆OOM：</strong></p>
<ol>
<li>
<p><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p>
</li>
<li>
<p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。</p>
</li>
</ol>
<p><strong>方法区 OOM：</strong></p>
<p>1、 <strong>加载大量的第三方的jar包</strong></p>
<p>2、Tomcat部署的工程过多（30~50个）</p>
<p>3、<strong>大量动态的生成反射类</strong></p>
<h2 id="JVM内存溢出有哪些场景会导致">JVM内存溢出有哪些场景会导致</h2>
<ol>
<li>在JVM中，当 Java 堆内存用完时会导致内存溢出。</li>
<li>另一种情况是，程序中存在大量循环引用，导致无法被 Java 垃圾回收器回收，从而导致内存溢出。</li>
<li>同样，JVM 栈中的局部变量消耗太多的内存也会导致内存溢出。</li>
<li>在 JVM 运行时，虚拟机配置的内存大小比需求的大小要小，也会导致内存溢出。</li>
</ol>
<h2 id="JVM为什么把永久代换成了元空间">JVM为什么把永久代换成了元空间</h2>
<ol>
<li>在1.7版本中永久代内存是有上限的，虽然可以通过参数设置上限，但是JVM加载的class总数大小是很难去确定的，所以很容易出现OOM的问题，而元空间是存储在本地内存里面，内存上限比较大，可以很好的避免这个问题</li>
<li>永久代的对象是利用FullGC来垃圾回收的，即和老年代同时进行垃圾回收，替换成元空间后简化了FullGC的过程，即有各种垃圾回收算法，可以在不暂停的情况下去并发的释放类的数据，同时也提升了GC的性能</li>
<li>Oracal要合并Hotspot和JRockit的代码，而JRockit中没有永久代</li>
</ol>
<h2 id="方法区放的什么，堆放什么，静态变量放哪，栈放什么">方法区放的什么，堆放什么，静态变量放哪，栈放什么</h2>
<p>在<strong>方法区</strong>中，主要存放以下内容：</p>
<ol>
<li>
<p><strong>类型信息</strong>（Type Information）：每个类在JVM中都有一个对应的Class对象，该对象包含了该<strong>类的类型信息</strong>，如<strong>类名、父类、接口、字段、方法</strong>等信息。</p>
</li>
<li>
<p><strong>运行时常量池</strong>（Runtime Constant Pool）：在编译Java代码时，编译器会将所有的<strong>字面量和符号引用</strong>都存储到该区域中，包括<strong>字符串常量、类和方法名、字段名、接口名</strong>等。</p>
</li>
<li>
<p><strong>静态变量</strong>（Static Variables）：静态变量是类变量，它们的生命周期与类的生命周期相同，存储在方法区中。</p>
</li>
<li>
<p><strong>方法信息</strong>（Method Information）：存储类中的方法信息，包括<strong>方法的字节码、访问修饰符、返回值类型、参数类型</strong>等。</p>
<hr>
</li>
<li>
<p><strong>运行时内存布局</strong>（Memory Layout）：存储类的成员变量和方法的访问信息，包括方法表（Virtual Method Table，即VMT）和字段表（Field Table）等。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/06/Fhvt54KCSTqreyZ.png" alt="image-20230406170440282"></p>
<hr>
<p><strong>堆</strong>主要存放以下内容：</p>
<ol>
<li><strong>对象实例</strong>（Object Instances）：Java中所有的<strong>对象实例</strong>都是在堆上创建的，<strong>对象的实例变量</strong>也存储在堆上。</li>
<li><strong>数组</strong>（Arrays）：Java中的数组也是对象，数组元素的实例变量也存储在堆上。</li>
<li><strong>堆栈帧</strong>（Stack Frames）：每个线程在调用方法时都会创建一个堆栈帧，该帧存储方法的<strong>局部变量、操作数栈、方法出口</strong>等信息。</li>
</ol>
<p>需要注意的是，在堆中存储的对象实例是可被垃圾回收器回收的，当对象不再被引用时，垃圾回收器会回收该对象所占用的内存空间。此外，堆还分为新生代和老年代，新生代又分为Eden区和两个Survivor区，不同的对象在不同的区域中创建和存储，以达到更好的垃圾回收性能和效率。</p>
<hr>
<p><strong>栈</strong>主要存放以下内容：</p>
<ol>
<li><strong>方法调用</strong>（Method Invocation）：每个方法在被调用时都会创建一个栈帧，栈帧中存储了该方法的参数、局部变量、返回地址等信息。当方法执行完毕后，该栈帧会被弹出，恢复到调用该方法的上一级栈帧。</li>
<li><strong>局部变量</strong>（Local Variables）：每个栈帧中都包含了该方法的局部变量，这些局部变量只在该方法执行期间可见。</li>
<li><strong>操作数栈</strong>（Operand Stack）：每个栈帧中都包含了一个操作数栈，用于存储方法执行时的操作数和结果，例如算术运算、逻辑运算等。</li>
</ol>
<p>需要注意的是，栈中存储的数据是<strong>基本数据类型和对象引用</strong>，而不是对象本身。当一个方法被调用时，JVM会为该方法创建一个新的栈帧，并将该栈帧压入当前线程的栈顶。当方法执行完毕后，该栈帧会被弹出，恢复到调用该方法的上一级栈帧。</p>
<p>栈的大小是有限制的，当栈空间不足时会抛出栈溢出（StackOverflow）异常。</p>
<h2 id="常量池-运行时常量池-字符串常量池">常量池&amp;运行时常量池&amp;字符串常量池</h2>
<p>详细讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/123150212">JVM常量池、Class常量池、运行时常量池、字符串常量池</a></p>
<h3 id="常量池">常量池</h3>
<p>也叫Class常量池(<strong>常量池==Class常量池</strong>)。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区 <strong>各种字面量</strong> (Literal)和 <strong>符号引用</strong> 。（<strong>类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符</strong>）</p>
<img src="https://s2.loli.net/2023/03/22/cRpZ4s5hHPGvoaj.png" alt="image-20230322155514612" style="zoom:67%;" />
<p>举例：</p>
<p><img src="https://s2.loli.net/2023/03/26/3rqvFWTDHdyRS9C.png" alt="image-20230326133812533"></p>
<p>后面的 <strong>#4.#25</strong> 分别表示 <code>class_index</code> 和 <code>name_and_type_index</code> ，这两个都是常量池下标（即所在类结构在常量池的下标和字段名与字段类型在常量池的下标），引用着另外两个常量池项。顺着这个方法把所有引用的常量都找出来</p>
<p>方法举例：</p>
<p><img src="https://s2.loli.net/2023/03/26/Vu64qxME8vIzAiJ.png" alt="image-20230326134826422"></p>
<p><img src="https://s2.loli.net/2023/03/26/ZN7lXypASBuxjiF.png" alt="image-20230326134759567"></p>
<p>在刚加载好一个类的时候，<code>Class</code> 文件里的常量池和每个方法的字节码（Code属性）会被基本原样的拷贝到内存里先放着，也就是说仍然处于使用 “符号引用” 的状态，直到真的要被使用到的时候才会被解析（resolve）为直接引用</p>
<p><strong>直接引用是运行时所能直接使用的形式，即可以表现为直接指针</strong></p>
<p>举例：</p>
<p><img src="https://s2.loli.net/2023/03/26/3aW7Snkvwbe1IQz.png" alt="image-20230326135035024"></p>
<p>补充：Jvm中多态的体现：</p>
<p><img src="https://s2.loli.net/2023/03/26/PDgwFVlxao1uXh8.png" alt="image-20230326135241107"></p>
<h3 id="运行时常量池">运行时常量池</h3>
<p>存放编译期生成的各种字面量和符号引用</p>
<p>字面量：</p>
<p>字面量是源代码中的固定值的表示法，即<strong>通过字面我们就能知道其值的含义</strong>。字面量包括<strong>整数、浮点数和字符串字面量</strong>。</p>
<p>符号引用：</p>
<p>符号引用是一种符号名称，它被用来定位在运行时需要使用的类、方法或字段。而直接引用则是一个指向具体内存地址的指针，用于直接访问类、方法或字段。</p>
<p><img src="https://s2.loli.net/2023/04/06/nlB4SEF27HvPWhK.png" alt="image-20230406164746644"></p>
<h3 id="符号引用和直接引用举例：">符号引用和直接引用举例：</h3>
<p>符号引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个类中引用MyClass.myMethod时，会生成符号引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">mc.myMethod();</span><br></pre></td></tr></table></figure>
<p>在运行时，JVM会根据符号引用找到MyClass类及其myMethod方法，并将其转换为直接引用，以便在内存中直接访问。</p>
<p>直接引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>在访问数组中的某个元素时，会生成直接引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>在运行时，JVM会使用直接引用来访问数组中的第3个元素（下标从0开始），即arr[2]，并将其赋值给变量x</p>
<h3 id="字符串常量池">字符串常量池</h3>
<p>是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line">String aa = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line">String bb = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="JVM中类的加载过程（类的生命周期）">JVM中类的加载过程（类的生命周期）</h2>
<p><img src="https://s2.loli.net/2023/02/23/fmYEjcO83WFhlLG.png" alt="image-20230223095349477"></p>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong></p>
<p>​	jdk 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的</p>
<p><strong>加载：</strong></p>
<ol>
<li>将 class 文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</li>
</ol>
<p><strong>验证</strong>：</p>
<p><strong>文件格式，元数据，字节码，符号引用</strong>，确保加载的类符合 JVM 规范和安全</p>
<p><strong>准备：</strong></p>
<p>为<strong>类变量分配内存</strong>并且<strong>设置类变量初始值</strong></p>
<p>为<strong>static变量在方法区中分配内存空间</strong>，<strong>设置变量的初始值(0或null)  <strong>，例如 static int a = 3 （注意：准备阶段只设置类中的</strong>静态变量</strong>（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）,不包含final修饰的静态变量,因为final变量在编译时分配</p>
<p><strong>解析：</strong></p>
<p>虚拟机将常量池内的<strong>符号引用替换为直接引用</strong>的过程</p>
<blockquote>
<p>在Java语言中，符号引用（Symbolic Reference）指的是一种使用符号名称来标识一个类、接口、字段或方法的方式。与C语言类似，Java中的符号引用也是在编译时或运行时解析的。符号引用是Java虚拟机（JVM）使用的一种内部数据结构，用于定位并加载类或接口，并访问字段或方法。</p>
<p><strong>例如，如果在Java程序中声明了一个类<code>MyClass</code>，那么在程序中可以使用符号<code>MyClass</code>来引用它，而不需要知道<code>MyClass</code>的实际位置。编译器会将符号<code>MyClass</code>转换成对应的类的描述符，然后在运行时根据类的描述符来加载类，并访问其中的字段或方法。</strong></p>
<p>符号引用在Java中起着非常重要的作用，它使得Java程序可以在运行时动态加载类，实现灵活的类加载和重载机制。同时，符号引用还可以使Java程序更加安全，因为Java虚拟机可以检查符号引用指向的对象是否合法，并且在运行时根据对象的实际类型进行调用</p>
</blockquote>
<blockquote>
<p>在Java语言中，直接引用（Direct Reference）指的是一种直接指向对象在内存中的实际地址的引用。在Java中，直接引用主要用于本地方法和JNI（Java Native Interface）方法中，它允许Java程序直接访问本地资源或调用本地库。</p>
<p>与符号引用不同，直接引用是一个具体的内存地址，它指向对象在堆内存中的实际位置。在Java中，直接引用的使用受到严格的限制，只有本地方法和JNI方法才能够使用直接引用，Java程序的其他部分都不能直接使用直接引用。这是因为Java的安全机制要求所有的对象访问都必须通过Java虚拟机来进行，以确保程序的安全性和稳定性。</p>
<p>需要注意的是，在Java中，直接引用并不是对象本身，而是指向对象的一个指针，它只有在本地方法或JNI方法中才能使用。在Java程序中，大部分情况下使用的是符号引用，符号引用是一种更高层次的引用，它提供了更加抽象和安全的对象访问方式。</p>
</blockquote>
<p><strong>初始化：</strong></p>
<p><strong>对静态变量赋值、并执行静态代码块</strong></p>
<p>初始化的方式：静态代码块初始化，构造器中初始化，声明类变量时指定初始值</p>
<p>初始化其实就是执行类构造器方法的<code>()</code>的过程，而且要保证执行前父类的<code>()</code>方法执行完毕。这个方法由编译器收集，顺序执行所			有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的0变			成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最			终值会为静态代码块中的赋值。</p>
<p>初始化时机：</p>
<ol>
<li>**创建类的实例。**为某个类创建实例的方式包括：①使用new操作符来创建实例；②通过反射来创建实例；③通过反序列化的方式来创建实例。</li>
<li><strong>调用某个类的类方法（静态方法）</strong>。</li>
<li><strong>访问某个类或接口的类变量，或为该类变量赋值</strong>。</li>
<li><strong>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</strong>。如Class.forName(“Test”)，如果系统还未初始化Test类，则这行代码将会导致该Test类被初始化，并返回Test类对应的java.lang.Class对象。</li>
<li>**初始化某个类的子类。**当初始化某个类的子类时，该子类的所有父类都会被初始化。</li>
<li>**直接使用java.exe命令来运行某个主类。**当运行某个主类时，程序会先初始化该主类。</li>
</ol>
<h2 id="对象的创建过程">对象的创建过程</h2>
<h3 id="总结：">总结：</h3>
<ol>
<li>
<p><strong>类加载检查</strong></p>
<p>因为每一个对象都是类的实例，虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>
</li>
<li>
<p><strong>内存分配</strong></p>
<ul>
<li>指针碰撞 ：
<ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ：
<ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p><strong>内存分配的并发问题：</strong></p>
<ul>
<li>
<p><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></p>
</li>
<li>
<p><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</p>
</li>
</ul>
</li>
<li>
<p><strong>初始化默认值（零值）</strong></p>
<p>保证对象实例的字段在Java代码中可以在不赋初值的情况下使用</p>
</li>
<li>
<p><strong>设置对象头（markword和KClassPointer）</strong></p>
<ul>
<li>标记该对象是哪个类的实例</li>
<li>对象的hash码</li>
<li>对象所处的分代年龄</li>
<li>是否启用偏向锁</li>
</ul>
</li>
<li>
<p><strong>执行初始化init()方法</strong></p>
<p>执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p>
</li>
</ol>
<h3 id="举例：-2">举例：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">int</span> staicVariabl=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span>   <span class="keyword">int</span>  objVariabl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态初始代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staicVariabl=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象初始化代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        objVariabl=<span class="number">88</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        objVariabl=<span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person=<span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person person=new Person()</p>
<ol>
<li>
<p>构建对象</p>
<p>main线程在栈中申请栈空间，并生成一个栈帧，里面局部变量表中包含有person。</p>
<p>然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM<strong>堆中</strong>申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。</p>
<p><img src="https://s2.loli.net/2023/03/07/4lI1GQ79CbYDjMN.png" alt="image-20230307165405107"></p>
</li>
<li>
<p>初始化对象</p>
<p>执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法（init 方法执行完后objVariabl=88，构造方法执行完后objVariabl=99)</p>
<p><img src="https://s2.loli.net/2023/03/07/k8etDogCbURqz7Z.png" alt="image-20230307165433251"></p>
</li>
<li>
<p>引用对象</p>
<p>对象实例化完毕后，再把栈中的person对象引用地址指向Person对象在堆内存中的地址。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/07/yeTJQg5EFCpPSjf.png" alt="image-20230307165840944"></p>
<h2 id="双亲委派机制">双亲委派机制</h2>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成</p>
<p>保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改</p>
<p>具体而言，即为在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器</p>
<p><img src="https://s2.loli.net/2023/02/26/Suh9KNIkd1RCBpH.png" alt="image-20230226164403300"></p>
<h2 id="对象的创建过程-2">对象的创建过程</h2>
<h3 id="Step1-类加载检查">Step1:类加载检查</h3>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="Step2-分配内存">Step2:分配内存</h3>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞 ：
<ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ：
<ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="Step3-初始化零值">Step3:初始化零值</h3>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="Step4-设置对象头">Step4:设置对象头</h3>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="Step5-执行-init-方法">Step5:执行 init 方法</h3>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p>
<h2 id="内存泄露场景">内存泄露场景</h2>
<ol>
<li>**实例变量作用域不合理：**如果只需要一个变量作为局部变量，在方法结束就不使用它了，但是把他设置为实例变量，此时如果该类的实例对象生命周期很长也会导致该变量无法回收发生内存泄漏（因为实例对象引用了它）</li>
<li><strong>ThreadLocal中回收key以后可能会发生</strong>，因为Value是强引用，不会主动GC</li>
<li>**不关闭资源引发内存泄漏：**数据库连接、网络连接、IO连接在使用后忘记关闭，GC无法回收它们，会发生内存泄漏</li>
<li>使用散列表时，充当Key 对象的哈希值被改变导致内存泄漏（key 使用逻辑不可变对象，关键域不能被修改）</li>
</ol>
<h2 id="进程和线程区别">进程和线程区别</h2>
<p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位</strong>，在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p>
<p>线程切换时保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong></p>
<ul>
<li>线程是CPU执行、CPU时间分配的基本单位</li>
<li>进程其他系统资源（内存），一系列的系统资源组成的集合</li>
</ul>
<h2 id="线程调度">线程调度</h2>
<p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复</p>
<h2 id="线程的状态">线程的状态</h2>
<ol>
<li>新建（New）</li>
<li>运⾏（Runnable）</li>
<li>阻塞（Blocked）</li>
<li>⽆限期等待（Waiting）</li>
<li>限期等待（Time Waiting）</li>
<li>结束（Terminated）</li>
</ol>
<h2 id="进程的状态">进程的状态</h2>
<ol>
<li>创建状态</li>
<li>就绪状态</li>
<li>运行状态</li>
<li>阻塞状态/等待状态</li>
<li>结束状态</li>
</ol>
<h2 id="进程最多包含多少个线程">进程最多包含多少个线程</h2>
<p>默认情况下，一个线程的栈要预留1M的内存空间，而一个进程中可用的内存空间只有2G，所以理论上一个进程中最多可以开2048个线程。但是内存当然不可能完全拿来作线程的栈，所以实际数目要比这个值要小。</p>
<h2 id="线程的通信方式">线程的通信方式</h2>
<ol>
<li>互斥量：采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，Java 中的synchronized 关键词和各种 Lock</li>
<li>信号量：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最⼤线程数量</li>
<li>事件：通过通知操作的⽅式来保持多线程同步</li>
</ol>
<h2 id="进程的通信方式">进程的通信方式</h2>
<ol>
<li>管道</li>
<li>信号</li>
<li>信号量</li>
<li>消息队列</li>
<li>共享内存</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/26/zSeI9PfidF2g6Wx.png" alt="image-20230226134700122"></p>
<h2 id="sleep和wait的区别">sleep和wait的区别</h2>
<ol>
<li>
<p><strong>wait方法和sleep方法的使用场景不同。</strong></p>
<p>wait方法是Object类的一个方法，通常在同步代码块中使用，用于使线程进入等待状态，直到另一个线程调用了该对象的notify或notifyAll方法来唤醒等待的线程。</p>
<p>sleep方法是Thread类的一个静态方法，用于让线程休眠指定的时间，然后自动唤醒。</p>
</li>
<li>
<p><strong>wait方法和sleep方法的作用不同。</strong></p>
<p>wait方法是用于线程间的协作，<strong>当线程调用wait方法时，它会释放锁并进入等待状态</strong>，等待其他线程调用notify或notifyAll方法唤醒它。wait方法是用于实现线程之间的同步。</p>
<p>sleep方法是用于让线程休眠一段时间，让其他线程有机会执行。<strong>sleep方法不会释放锁</strong>，当线程调用sleep方法时，它仍然持有锁。</p>
</li>
<li>
<p><strong>wait方法和sleep方法的异常不同。</strong></p>
<p>当线程调用wait方法时，如果没有其他线程调用notify或notifyAll方法来唤醒它，它会一直等待下去，直到超时或线程被中断。如果线程被中断，会抛出InterruptedException异常。</p>
<p>当线程调用sleep方法时，它也可能被中断，但中断时不会抛出异常，只是设置中断标志位。如果需要在sleep方法中响应中断，需要在sleep方法中检查中断标志位并进行相应处理。</p>
</li>
</ol>
<p>总之，wait方法和sleep方法都可以用于控制线程的执行，但<strong>wait方法更多的是用于线程间的协作，而sleep方法更多的是用于让线程休眠一段时间。</strong></p>
<h2 id="线程代码举例">线程代码举例</h2>
<p><img src="https://s2.loli.net/2023/03/08/pcZQtYEd5vAmWsI.png" alt="image-20230308104622011"></p>
<h2 id="使线程阻塞的方式">使线程阻塞的方式</h2>
<p>加锁 ----&gt; 线程阻塞</p>
<ol>
<li>
<p>wait()：必须搭配synchronized关键字</p>
<p><img src="https://s2.loli.net/2023/03/08/SOkBTnLbdcjCru2.png" alt="image-20230308105439461"></p>
</li>
<li>
<p>sleep()：只能中断才能唤醒</p>
</li>
<li>
<p>park()：</p>
</li>
<li>
<p>while(true){}</p>
<p><img src="https://s2.loli.net/2023/03/08/ORpoa319QxflsW2.png" alt="image-20230308110533727"></p>
</li>
</ol>
<p>需要加上CAS</p>
<p><img src="https://s2.loli.net/2023/03/08/iv7LBM4Ijk3funJ.png" alt="image-20230308110840024"></p>
<p><img src="https://s2.loli.net/2023/03/08/JNUiSLTn1XPesmW.png" alt="image-20230308111345194"></p>
<h2 id="创建线程的方式">创建线程的方式</h2>
<ol>
<li>
<p>写⼀个类<strong>继承⼦Thread类</strong>，重写run方法</p>
<p>单继承具有局限性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式一：继承Thread类，重写run()方法，调用start()开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run()方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码——————&quot;</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//main()线程，主线程</span></span><br><span class="line">        <span class="comment">//创建一个对象</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">//调用start()方法</span></span><br><span class="line">        testThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写⼀个类<strong>实现Runable接口</strong>，重写run⽅法</p>
<p>避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式2:实现runnable接口,重写run方法，执行线程丢入runnable接口实现类，调用start()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建runnable接口的实现类对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启我们的线程，代理</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(testThread3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;学习&quot;</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写⼀个类<strong>实现Callable接口</strong>，重写call⽅法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个类，重写call()方法，</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在上班-----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = executorService.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = executorService.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = executorService.submit(t3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        Boolean r1 = result1.get();</span><br><span class="line">        Boolean r2 = result2.get();</span><br><span class="line">        Boolean r3 = result3.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使⽤线程池</p>
</li>
</ol>
<h2 id="如何监控java线程池的利用率">如何监控java线程池的利用率</h2>
<ol>
<li>**监控线程池中活跃线程的数量：**线程池中活跃线程的数量反映了线程池的当前利用率，如果活跃线程数过高，说明线程池的负载较大，可能需要增加线程池的大小或优化任务调度策略。可以通过使用Java线程池提供的getActiveCount方法获取当前线程池中的活跃线程数量。</li>
<li>**监控线程池的任务队列长度：**线程池中任务队列长度的大小也反映了线程池的当前利用率。如果任务队列长度过高，说明线程池的负载较大，可能需要调整任务队列的大小或增加线程池的大小。可以通过使用Java线程池提供的getQueue方法获取当前任务队列的长度。</li>
<li>**监控线程池的执行时间：**线程池的执行时间也可以反映线程池的利用率。可以通过记录任务的开始时间和结束时间，并计算任务的执行时间来监控线程池的执行时间。如果线程池的执行时间过长，说明线程池的负载较大，可能需要增加线程池的大小或优化任务调度策略。</li>
<li>**使用JMX进行监控：**Java线程池可以通过JMX（Java Management Extensions）进行监控，可以使用JConsole或VisualVM等工具来监控线程池的利用率。在JMX中，可以监控线程池的活跃线程数、任务队列长度、线程池大小等信息。</li>
</ol>
<h2 id="多线程的实现方式">多线程的实现方式</h2>
<h2 id="如何中断一个正在运行中的线程">如何中断一个正在运行中的线程</h2>
<p><img src="https://s2.loli.net/2023/03/27/71y83esawPfxMrq.png" alt="image-20230327232931664"></p>
<h2 id="线程池的状态">线程池的状态</h2>
<ol>
<li>
<p>运行**(RUNNING)**</p>
</li>
<li>
<p><strong>SHUTDOWN</strong></p>
<p>线程池处于SHUTDOWN状态时，不接收新任务，但能处理已添加的任务，通过调用线程池的shutdown()接口</p>
</li>
<li>
<p><strong>STOP</strong></p>
<p>线程池处于STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务，调用线程池的shutdownNow()接口</p>
</li>
<li>
<p><strong>TIDYING</strong></p>
</li>
<li>
<p><strong>TERMINATED</strong></p>
</li>
</ol>
<h2 id="线程池有哪些参数，分别的含义">线程池有哪些参数，分别的含义</h2>
<p>七大核心参数</p>
<ol>
<li>
<p>**corePoolSize：**核⼼线程数</p>
</li>
<li>
<p><strong>maximumPoolSize：</strong> 线程池中最⼤线程数</p>
</li>
<li>
<p>**keepAliveTime：**多余空闲线程数的存活时间，当前线程数⼤于corePoolSize，并且等待时间⼤于keepAliveTime，多于线程或被销毁直到剩下corePoolSize为⽌。</p>
</li>
<li>
<p><strong>TimeUnit unit：</strong> keepAliveTime的单位。</p>
</li>
<li>
<p>**workQueue：**任务队列，被提交但未必执⾏的任务。</p>
</li>
<li>
<p>**threadFactory：**⽤于创建线程池中⼯作线程的线程⼯⼚，⼀般⽤默认的。</p>
</li>
<li>
<p>**handler：**拒绝策略，当堵塞队列满了并且⼯作线程⼤于线程池的最⼤线程数（maximumPoolSize）</p>
<p><img src="https://s2.loli.net/2023/02/26/5wG61dFTamER3M8.png" alt="image-20230226153805288"></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/26/u3yJVo8TY7SZWXg.png" alt="image-20230226153857717"></p>
<h2 id="创建线程池的方式">创建线程池的方式</h2>
<ol>
<li><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建</strong></li>
<li><strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建</strong>（阿里手册不允许）</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;田先生您好&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadpool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadPollDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEP_GAP=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> AtomicInteger taskNo=<span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TargetTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            taskName=<span class="string">&quot;task-&quot;</span>+taskNo;</span><br><span class="line">            taskNo.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(taskName+<span class="string">&quot; is doing...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GAP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(taskName+<span class="string">&quot; end...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool=Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">//创建含有3个线程的线程池</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> TargetTask());</span><br><span class="line">            pool.submit(<span class="keyword">new</span> TargetTask());</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool=Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">ExecutorService pool=Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<h2 id="线程池的种类">线程池的种类</h2>
<ol>
<li>
<p>**固定线程数线程池（FixedThreadPool）：**线程池中的线程数量是固定的，不会随着任务数量的增加而增加。</p>
<p>特点：</p>
<ul>
<li>如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量</li>
<li>线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程</li>
<li>在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要任务长期执行的场景</li>
<li>CPU密集型任务</li>
</ul>
<p>缺点：</p>
<ul>
<li>内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽</li>
</ul>
</li>
<li>
<p>**可变大小线程池（CachedThreadPool）：**线程池中的线程数量会根据任务数量的变化而变化，当任务数量增加时，会自动增加线程数量，当任务数量减少时，会自动减少线程数量。</p>
<p>特点：</p>
<ul>
<li>在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务</li>
<li>线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小</li>
<li>如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要快速处理突发性强、耗时较短的任务场景，如Netty的NIO处理场景、REST API接口的瞬时削峰场景</li>
</ul>
<p>缺点：</p>
<ul>
<li>线程池没有最大线程数量限制，如果大量的异步任务执行目标实例同时提交，可能会因创建线程过多而导致资源耗尽</li>
</ul>
</li>
<li>
<p>**定时线程池（ScheduledThreadPool）：**该线程池可以根据延迟时间或定时时间来执行任务。</p>
</li>
<li>
<p>**单线程池（SingleThreadPool）：**线程池中只有一个线程，该线程依次执行任务，保证所有任务的执行顺序按照提交的顺序执行。</p>
<p>特点：</p>
<ul>
<li>单线程化的线程池中的任务是按照提交的次序顺序执行的</li>
<li>只有一个线程的线程池</li>
<li>池中的唯一线程的存活时间是无限的</li>
<li>当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是无界的</li>
</ul>
<p>适用场景：</p>
<ul>
<li>任务按照提交次序，一个任务一个任务地逐个执行的场景</li>
</ul>
</li>
<li>
<p>**ForkJoin线程池（ForkJoinPool）：**该线程池是一种特殊的线程池，主要用于执行可分解的、递归的、并行的任务，例如归并排序、MapReduce等。</p>
</li>
</ol>
<p>在高并发、频繁提交任务的场景中，可以选择 <code>CachedThreadPool</code> 或 <code>FixedThreadPool</code>；在需要执行定时任务的场景中，可以选择 <code>ScheduledThreadPool</code>；在需要按照一定顺序执行任务的场景中，可以选择 <code>SingleThreadPool</code></p>
<h2 id="怎样重写java线程池">怎样重写java线程池</h2>
<p>继承ThreadPoolExecutor类并重写其中的方法</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在执行任务之前调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Task is about to be executed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在执行任务之后调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Task has been executed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程池关闭时调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ThreadPool has been terminated.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用自定义线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyThreadPool threadPool = <span class="keyword">new</span> MyThreadPool(<span class="number">2</span>, <span class="number">5</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Task is being executed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="线程池的拒绝策略">线程池的拒绝策略</h2>
<ol>
<li>**DiscardPolicy()：**当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失</li>
<li>**DiscardOldestPolicy()：**丢弃队列中等待最久的任务，然后把当前任务加入队列中。</li>
<li>**AbortPolicy()：**丢弃任务并抛出 RejectedExecutionException 异常(默认)。</li>
<li>**CallerRunsPolicy()：**当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。</li>
</ol>
<h2 id="线程池线程的个数">线程池线程的个数</h2>
<p><strong>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 CPU数+1</strong></p>
<p><strong>如果是IO密集型任务，参考值可以设置为 2CPU数</strong></p>
<p>CPU密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。也就是说n+1是一个经验值</p>
<p>对于包含I/O操作或者其他阻塞的任务，由于线程不会一直执行，因此线程池的数量应该更多</p>
<p>估算公式：</p>
<p><em><em>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）</em> CPU数目</em>*</p>
<h2 id="阻塞队列有哪些">阻塞队列有哪些</h2>
<ol>
<li><strong>ArrayBlockingQueue：<strong>基于</strong>数组</strong>实现的有界阻塞队列，具有<strong>固定容量</strong>、先进先出、阻塞队列和线程安全等特点。<strong>在生产者放入数据和消费者获取数据，都是共用同一个锁对象，无法并行</strong></li>
<li><strong>LinkedBlockingQueue：<strong>基于</strong>链表</strong>实现的可选有界阻塞队列，<strong>可以指定容量，如果未指定容量则默认容量为 Integer.MAX_VALUE</strong>，同样具有先进先出、阻塞队列和线程安全等特点。其对于生产者端和消费者端分别<strong>采用了独立的锁</strong>来控制数据同步，这也意味着在高并发的情况下<strong>生产者和消费者可以并行地操作队列中的数据</strong>，以此来提高整个队列的并发性能</li>
<li>**DelayQueue：**元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li>
<li>**SynchronousQueue：**没有容量的阻塞队列，每个插入操作必须等待另一个线程的删除操作，同样具有阻塞队列和线程安全等特点。是一种无缓冲的等待队列，相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区），不存储元素的阻塞队列，也即单个元素的队列</li>
<li>**PriorityBlockingQueue：**基于堆实现的无界阻塞队列，可以自定义元素的优先级，按照优先级排序，同样具有阻塞队列和线程安全等特点。支持优先级排序的无界阻塞队列，不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</li>
</ol>
<p>方法：</p>
<p><img src="https://s2.loli.net/2023/04/09/EfbixUHwuJWmN5z.png" alt="image-20230409185209255"></p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建阻塞队列 </span></span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//加入元素</span></span><br><span class="line">System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>)); <span class="comment">//成功为true，失败为false</span></span><br><span class="line"><span class="comment">//检查元素</span></span><br><span class="line">System.out.println(blockingQueue.element());</span><br><span class="line"><span class="comment">//取出元素</span></span><br><span class="line">System.out.println(blockingQueue.remove()); <span class="comment">//先进先出</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放:</span></span><br><span class="line">put(E); <span class="comment">//一直等待</span></span><br><span class="line">offer(E, <span class="keyword">long</span>, TimeUnit); <span class="comment">//等待一定时间，返回boolean</span></span><br><span class="line">offer(E); <span class="comment">//不等待，返回boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取：</span></span><br><span class="line">take(); <span class="comment">// 一直等待</span></span><br><span class="line">poll(<span class="keyword">long</span>, TimeUnit); <span class="comment">// 等待一定时间，没有返回null</span></span><br><span class="line">poll(); <span class="comment">// 不等待，没有返回null</span></span><br></pre></td></tr></table></figure>
<h2 id="ArrayBlockingQueue的特点">ArrayBlockingQueue的特点</h2>
<ol>
<li><strong>有界限制</strong>：ArrayBlockingQueue 有一个指定的容量，当队列已满时，继续向队列中添加元素的线程将被阻塞，直到队列中有空闲空间。</li>
<li><strong>先进先出</strong>：ArrayBlockingQueue 遵循先进先出的原则，也就是说，队列中的元素将按照它们被添加到队列中的顺序进行处理。</li>
<li><strong>阻塞队列</strong>：当队列为空时，从队列中获取元素的线程将被阻塞，直到队列中有可用元素。同样地，当队列已满时，向队列中添加元素的线程将被阻塞，直到队列中有空闲空间。</li>
<li><strong>线程安全</strong>：ArrayBlockingQueue 是线程安全的，多个线程可以同时访问它，而不会导致数据的不一致性或其他线程安全问题。</li>
</ol>
<h2 id="介绍强引用、软引用、弱引用、虚引用">介绍强引用、软引用、弱引用、虚引用</h2>
<p>包含虚引用与软引用和弱引用的区别、使用软引用能带来的好处</p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>
<h2 id="虚引用的作用">虚引用的作用</h2>
<p>唯⼀的⽤处：能在对象被GC时收到系统通知</p>
<p>虚引⽤必须和引⽤队列 （ReferenceQueue）联合使⽤。当垃圾回收器准备回收⼀个对象时，如果发现它还有虚引⽤，就会在回收对象的内存之前，把这个虚引⽤加⼊到与之关联的引⽤队列中</p>
<h2 id="如何判断一个常量是废弃常量">如何判断一个常量是废弃常量</h2>
<p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池了。</p>
<h2 id="如何判断一个类是无用的类">如何判断一个类是无用的类</h2>
<ul>
<li>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
</li>
<li>
<p>加载该类的 <code>ClassLoader</code> 已经被回收。</p>
</li>
<li>
<p>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<h2 id="HotSpot-为什么要分为新生代和老年代？">HotSpot 为什么要分为新生代和老年代？</h2>
<p>一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</p>
<h2 id="如何判断对象是否死亡（两种方法）">如何判断对象是否死亡（两种方法）</h2>
<h3 id="引用计数法">引用计数法</h3>
<p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的</li>
</ul>
<p>缺点：<em><em>它很难解决对象之间相互循环引用的问题</em>，</em>*，因为缺乏全局对象图，只维护了局部信息</p>
<h3 id="可达性分析算法">可达性分析算法</h3>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收</p>
<p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象</p>
<p><img src="https://s2.loli.net/2023/02/22/kh4lgQZp7cCorUT.png" alt="image-20230222205338789"></p>
<h2 id="哪些对象可以作为-GC-Roots">哪些对象可以作为 GC Roots</h2>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
<li>已启动且未停止的 Java 线程</li>
</ul>
<p>当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行</p>
<h2 id="垃圾收集有哪些算法，各自的特点？">垃圾收集有哪些算法，各自的特点？</h2>
<ul>
<li>
<p>标记清除算法</p>
</li>
<li>
<p>标记复制算法</p>
</li>
<li>
<p>标记整理算法</p>
</li>
<li>
<p>分代收集算法</p>
</li>
</ul>
<h2 id="常见的垃圾回收器有哪些？">常见的垃圾回收器有哪些？</h2>
<ul>
<li>
<p>Serial 收集器：单线程+STW</p>
</li>
<li>
<p>ParNew 收集器：<strong>是 Serial 收集器的多线程版本，新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p>
</li>
<li>
<p>Parallel Scavenge 收集器：<strong>关注点是吞吐量</strong>（吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值），<strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p>
</li>
<li>
<p>CMS收集器(Concurrent Mark Sweep)：<strong>关注点是响应时间</strong>，<strong>是并发收集器</strong>，实现<strong>标记-清除”算法</strong></p>
<p>缺点：</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</li>
</ul>
</li>
<li>
<p>G1收集器：使用多个CPU缩短STW停顿时间；局部是<strong>标记复制算法</strong>；可预测的停顿</p>
<p>G1垃圾回收器抛弃了分代的概念，将堆内存划分为⼤⼩固定的⼏个独⽴区域，并维护⼀个优先级列表，在垃圾回收过程中根据系统允许的最长垃圾回收时间，优先回收垃圾最多的区域。</p>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 	Region(这也就是它的名字 Garbage-First 的由来)</strong></p>
</li>
</ul>
<h2 id="HotSpot默认的垃圾回收器">HotSpot默认的垃圾回收器</h2>
<p>垃圾回收器讲解：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2031199">HotSpot 提供的垃圾收集器</a></p>
<p><strong>小于等于jdk8是paraella gc，大于等于9是g1</strong></p>
<h2 id="CMS垃圾回收器">CMS垃圾回收器</h2>
<p>CMS是老年代回收器，<strong>只能回收老年代的对象</strong>，在收集过程中可以与用户线程并发操作</p>
<ul>
<li>优点：<strong>并发收集、低停顿。</strong><br>
其实最主要的是CMS把收集过程中步骤拆分了，而最耗时的操作都是并发执行，自然就会低停顿了。</li>
<li>缺点：<strong>产生大量空间碎片</strong>（可以通过配置重新整理，但是加长停顿时间）、并发阶段会<strong>降低吞吐量</strong>。<strong>无法处理浮动垃圾</strong>。<br>
CMS采用的是标记-清除算法，所以会产生大量的空间碎片。</li>
</ul>
<p>基于标记清除算法</p>
<ol>
<li>
<p><strong>初始标记阶段</strong>只标记GC Root关联的对象，速度很快（更改对象头MarkWord的GC标记字段）</p>
</li>
<li>
<p>在<strong>并发标记阶段</strong>，因为是用户线程和GC线程同时在跑，所以采用的是<strong>三色标记</strong>的方式进行垃圾标记</p>
<ul>
<li><strong>白色</strong>：对象的默认颜色，从GC Root开始扫描，如果对象是不可达对象的话就是白色，也就是垃圾对象，在并发清理的时候会清理掉。</li>
<li><strong>灰色</strong>：当前对象已经被扫描过，但是当前对象所依赖的其他对象还没有被扫描。</li>
<li><strong>黑色</strong>：当前对象和它所依赖的对象都已经被扫描过，不会对黑色对象和引用的对象再次进行扫描。</li>
</ul>
<p>三色标记的问题：漏标&amp;多标</p>
<p>漏标的解决方案<br>
CMS使用增量更新的方式解决三色标记漏标问题。<br>
增量更新：<br>
将新增的引用维护到一个集合里面，将引用的源头变成灰色，等待重新标记阶段再重新进行一次扫描。比如：当D的引用指向了C，则会将C变成灰色，并将C放在一个新增引用的集合里面；在重新标记阶段会将C作为根节点继续向下扫描。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/27/AV2zXgBioClyFLr.png" alt="image-20230327144652948"></p>
<h2 id="G1垃圾回收器-Garbage-First">G1垃圾回收器(Garbage-First)</h2>
<p>讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/123483286">G1垃圾收集器详解</a></p>
<p><strong>以极高概率满足GC停顿时间的同时</strong>,还<strong>兼具高吞吐量的性能特征</strong></p>
<h3 id="优点：">优点：</h3>
<ul>
<li>
<p><strong>并行和并发</strong></p>
</li>
<li>
<p><strong>分代收集</strong></p>
<p>和之前的各类回收器不同,它<strong>同时兼顾年轻代和老年代</strong>。对比其他回收器,或者工作在年轻代,或者工作在老年代</p>
</li>
<li>
<p><strong>空间整合</strong></p>
</li>
</ul>
<ol>
<li>
<p>G1是一个并行回收器,它<strong>把堆内存分割为很多不相关的区域(region物理上不连续),把堆分为2048个区域</strong>,每一个region的大小是1 - 32M不等,必须是<strong>2的整数次幂</strong>。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等</p>
</li>
<li>
<p>每次根据允许的收集时间,<strong>优先回收价值最大的Region</strong>(每次回收完以后都有一个空闲的region,在后台维护一个优先列表)，侧重点在于回收垃圾最大量的区间(Region)</p>
</li>
<li>
<p>还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了,它们都是一部分Region (不需要连续)的集合。<strong>通过Region的动态分配方式实现逻辑上的连续。</strong></p>
</li>
<li>
<p><strong>Humongous内存区域</strong>：主要用于存储大对象，如果<strong>超过0.5个region, 就放到H</strong></p>
<p><strong>对于堆中的大对象，默认直接会被分配到老年代</strong>，但是如果它是<strong>一个短期存在的大对象，就会对垃圾收集器造成负面影响</strong>。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/27/VuDv9BFJMSiXLft.png" alt="image-20230327152815036"></p>
<p><strong>G1 GC的垃圾回收过程主要包括如下三个环节：</strong></p>
<ul>
<li>年轻代GC (Young GC)</li>
<li>老年代并发标记过程 (Concurrent Marking)</li>
<li>混合回收(Mixed GC)</li>
</ul>
<h3 id="回收过程：">回收过程：</h3>
<ol>
<li>
<p><strong>初始标记（Initial Mark）：<strong>该阶段标记所有根对象（如线程栈、静态变量等）以及直接引用的对象，并将这些对象标记为垃圾收集器的关注点。</strong>（会STW）</strong></p>
</li>
<li>
<p>**并发标记（Concurrent Marking）：**此阶段与Java应用程序并行运行，G1垃圾收集器在堆中遍历对象图，标记所有被引用的对象，包括从根对象到所有可达对象的路径。这个阶段的标记是非常耗时的，但可以并发执行，不会影响应用程序的正常运行。</p>
</li>
<li>
<p><strong>最终标记（Final Marking）：<strong>该阶段标记在并发标记期间新分配的对象，标记它们是否为可到达的，并对它们进行记录。</strong>（会STW）</strong></p>
</li>
<li>
<p>**筛选回收（Live Data Counting and Evacuation）：**在这个阶段，G1垃圾回收器根据回收的目标来选择需要回收的区域。选择可回收区域的依据包括：**该区域中的垃圾数量是否超过阈值，该区域的垃圾对象的时间分布是否合适，是否有其他区域可以更优先回收等。**然后，G1垃圾回收器将存活的对象从可回收区域中复制到其他区域，这个过程也被称为“筛选回收”。</p>
</li>
<li>
<p>**混合回收（Mixed Garbage Collection）：**该阶段是一种增量回收策略，G1垃圾回收器将一部分未回收的区域进行混合回收。这些区域中包含了一些垃圾，但是回收它们可能会占用太多的时间和资源。所以，G1垃圾回收器会根据各个区域中垃圾的数量和所占空间比例的大小，来决定选择哪些区域进行混合回收。在混合回收期间，应用程序仍然可以运行，但是可能会有一些停顿，因为混合回收是在堆中进行的。</p>
<p>具体来说，G1垃圾回收器在混合回收期间会同时执行标记、复制和清理三个操作，以回收一部分包含垃圾对象的区域。在标记阶段，垃圾回收器会标记所有存活对象，并将它们从垃圾对象中区分出来。在复制阶段，垃圾回收器会将所有存活对象从可回收区域中复制到其他区域。最后，在清理阶段，垃圾回收器会释放已经复制出来的区域中的垃圾对象占用的内存空间。由于混合回收是在堆中进行的，因此它可能会对应用程序造成一些停顿，但是这种停顿的时间通常都比传统的垃圾回收器短，而且可以通过调整垃圾回收器的参数来控制和优化。</p>
</li>
</ol>
<p>相关参数：</p>
<ol>
<li>
<p>**-XX:+UseG1GC:**手动指定使用G1收集器执行内存回收任务（JDK9后不用设置，默认就是G1）</p>
</li>
<li>
<p>**-XX:G1HeapRegionSize:*<em>设置每个Region的大小。值*<em>是2的幂,范围是1MB到32MB之间</em></em>,目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000</p>
</li>
<li>
<p>**-XX:MaxGCPauseMillis:*<em>设置期望达到的*<em>最大GC停顿时间指标</em></em>(JVM会尽力实现,但不保证达到)。默认值是200ms（如果这个值设置很小,如20ms,那么它收集的region会少,这样长时间后,堆内存会满。产生FullGC,FullGC会出现STW,反而影响用户体验)</p>
</li>
<li>
<p>**-XX:ParallelGCThread:**设置STW时GC线程数的值。最多设置为8</p>
</li>
<li>
<p>**-XX:ConcGCThreads:**设置并发标记的线程数。<strong>将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右</strong></p>
</li>
<li>
<p>**-XX:InitiatingHeapOccupancyPercent:**设置触发并发GC周期的Java堆占用率阈值。<strong>超过此值,就触发GC</strong>。默认值是45</p>
</li>
</ol>
<h2 id="怎样减少Full-GC的次数">怎样减少Full GC的次数</h2>
<ol>
<li>**增加堆内存大小：**Full GC通常是由于堆内存不足而触发的。如果堆内存过小，会导致频繁的Full GC。可以通过增加堆内存大小来避免这种情况。</li>
<li>**优化代码：**优化代码可以减少对象的创建和销毁，从而减少Full GC的次数。例如，可以避免过度使用字符串连接操作、使用静态变量代替非静态变量等。</li>
<li><strong>避免大对象的创建：<strong>大对象的创建会导致内存碎片的产生，从而增加Full GC的次数。可以考虑</strong>使用对象池技术或者减少一次性创建大对象的次数</strong>来避免这种情况。</li>
<li><strong>调整垃圾收集器的参数：<strong>可以根据应用程序的特点调整垃圾收集器的参数，例如</strong>Young Generation的大小、Survivor Space的比例、Full GC的阈值</strong>等，以减少Full GC的次数。</li>
<li><strong>尽量避免长时间停顿：<strong>Full GC会导致应用程序长时间停顿，影响用户体验。可以通过</strong>调整垃圾收集器的参数、优化代码、避免大对象的创建</strong>等方法来尽量避免长时间停顿。</li>
</ol>
<h2 id="常见的-GC-调优思路">常见的 GC 调优思路</h2>
<ol>
<li>
<p>降低 Minor GC 频率</p>
<p><strong>增大新生代空间</strong></p>
</li>
<li>
<p>降低 Full GC 的频率</p>
<ul>
<li>减少创建大对象</li>
<li>增大堆内存空间</li>
</ul>
</li>
</ol>
<h2 id="JVM调优">JVM调优</h2>
<ol>
<li>调整最大堆内存和最小堆内存（-Xms，-Xmx）</li>
<li>调整新生代和老年代的比值（-XX：NewRatio）</li>
<li>调整survivor区和Eden区的比值（一般为8:1:1）（-XX：SurvivorRatio）</li>
<li>设置年轻代和老年代的大小</li>
</ol>
<h2 id="出现内存泄漏怎样排查">出现内存泄漏怎样排查</h2>
<ol>
<li>用jstat命令查看虚拟机中各个内存的使用情况和GC情况</li>
<li>使用dump工具将当前内存dump下来，如果dump比较大，可以使用轻量级在线分析工具jmap</li>
<li>使用mat工具进行分析</li>
</ol>
<h1>JUC</h1>
<h2 id="AtomicInteger">AtomicInteger</h2>
<p>是Java中的一个原子变量类，用于在多线程环境下进行原子操作。它提供了一些原子操作方法，可以保证在多线程并发操作时，不会发生线程安全问题。</p>
<p>AtomicInteger使用<strong>CAS操作</strong>来保证原子性。CAS操作是基于CPU硬件支持的原子指令实现的，因此能够保证操作的原子性。AtomicInteger还使用了一些其他的技术来保证线程安全和高性能，如<strong>volatile关键字和Unsafe类</strong>。volatile关键字可以保证线程之间的可见性，即<strong>一个线程对共享变量的修改可以被其他线程立即看到</strong>；而Unsafe类是一种Java中不安全的操作类，<strong>可以直接操作内存，提高性能。</strong></p>
<p><code>AtomicInteger</code> 的常用方法：</p>
<ol>
<li><code>int get()</code>：获取当前的值。</li>
<li><code>void set(int newValue)</code>：设置新的值。</li>
<li><code>int getAndSet(int newValue)</code>：设置新的值，并返回旧值。</li>
<li><code>boolean compareAndSet(int expect, int update)</code>：比较并设置新值，如果当前值等于期望值，则更新值并返回 true；否则返回 false。</li>
<li><code>int getAndIncrement()</code>：获取当前值并增加1。</li>
<li><code>int getAndDecrement()</code>：获取当前值并减少1。</li>
<li><code>int incrementAndGet()</code>：增加1并获取当前值。</li>
<li><code>int decrementAndGet()</code>：减少1并获取当前值。</li>
</ol>
<p>使用 <code>AtomicInteger</code> 类时，需要注意以下几点：</p>
<ol>
<li><code>AtomicInteger</code> 类是线程安全的，因此可以在多线程环境下使用。</li>
<li><code>AtomicInteger</code> 类的原子操作方法是<strong>基于硬件级别的底层实现</strong>，因此性能非常高。</li>
<li><code>AtomicInteger</code> 类并不适合所有场景，如果只需要对单个变量进行操作，而不需要对多个变量进行操作，那么使用 <code>synchronized</code> 或者 <code>volatile</code> 关键字也可以实现线程安全。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ThreadLocal是怎么实现的">ThreadLocal是怎么实现的</h2>
<p>ThreadLocal底层是通过ThreadLocalmap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值，不同于synchronized的互斥效果，它是隔离性，各个线程操作自己的数据，还可用于单线程间的全区共享</p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</p>
<p><img src="https://s2.loli.net/2023/03/11/b78yjB9LqzZrx62.png" alt="image-20230311180958325"></p>
<h2 id="ThreadLocal带来的问题及解决">ThreadLocal带来的问题及解决</h2>
<p>内存泄漏：ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的<strong>弱引⽤</strong>,⽽ value 是<strong>强引⽤</strong>，解决：<strong>手动remove</strong></p>
<h2 id="AQS">AQS</h2>
<p>抽象队列同步器（AbstractQueuedSynchronizer，简称AQS）是Java并发包中提供的一种同步机制，它可以用于实现各种类型的同步器，如ReentrantLock、Semaphore、CountDownLatch等。</p>
<blockquote>
<p>AQS的原理⼤概是这样的，给每个共享资源都设置⼀个共享锁，线程在需要访问共享资源时⾸先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使⽤该共享资源，如果没有获取到共享锁，该线程被放⼊到等待队列中，等待下⼀次资源调度。</p>
<p>AQS只是⼀个框架（模板模式），只定义了⼀个接⼜，具体资源的获取、释放都交由⾃定义同步器去实现。不同的⾃定义同步器争取⽤共享资源的⽅式也不同，⾃定义同步器在实现时只需实现共享资源state的获取与释放⽅式即可，⾄于具体线程等待队列的维护，如获取资源失败⼊队、唤醒出队等，AQS已经在顶层实现好，不需要具体的同步器在做处理</p>
</blockquote>
<p>使用AQS实现一个自定义同步器的一般步骤如下：</p>
<ol>
<li>继承AQS类，并实现必要的方法。通常，你需要至少实现以下方法：</li>
</ol>
<ul>
<li>tryAcquire(int): 尝试获取同步状态，返回值表示获取成功或失败。</li>
<li>tryRelease(int): 尝试释放同步状态，返回值表示释放成功或失败。</li>
<li>tryAcquireShared(int): 尝试获取共享同步状态，返回值表示获取成功或失败。</li>
<li>tryReleaseShared(int): 尝试释放共享同步状态，返回值表示释放成功或失败。</li>
<li>isHeldExclusively(): 返回当前同步器是否被当前线程独占。</li>
</ul>
<ol>
<li>在自定义同步器中调用AQS提供的底层同步状态管理方法，如getState()、setState()、compareAndSetState()等，以及同步方法的模板实现，如acquire()、release()、acquireShared()、releaseShared()等。</li>
<li>在自定义同步器中提供高层同步方法，如lock()、unlock()、await()、signal()等，这些方法一般会调用AQS提供的同步方法的模板实现。</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JAVA中锁机制以及使用场景">JAVA中锁机制以及使用场景</h2>
<ol>
<li>
<p>synchronized 锁</p>
<p><code>synchronized</code> 是 Java 中最常见的锁机制之一，它可以用来实现方法级别的同步和代码块级别的同步。<code>synchronized</code> 修饰的代码块或方法在同一时刻只能被一个线程访问，其他线程需要等待锁的释放才能继续执行。适用于同步控制块或方法，只有在竞争不激烈的情况下才能获得良好的性能。</p>
</li>
<li>
<p>ReentrantLock 锁</p>
<p><code>ReentrantLock</code> 是 Java 中可重入锁的一种实现，它提供了比 <code>synchronized</code> 更多的功能，比如可中断、可限时、公平锁等。ReentrantLock 是一种可重入的互斥锁，即同一个线程可以多次获得同一把锁，同时只有一个线程能持有该锁。适用于需要更加灵活的同步控制场景，例如需要等待一段时间或者能够中断等情况。</p>
</li>
<li>
<p>ReadWriteLock 锁</p>
<p><code>ReadWriteLock</code> 是一种读写锁，它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。读写锁可以提高并发读的性能，适用于读多写少的场景，例如缓存、数据池等。</p>
</li>
<li>
<p>AtomicInteger 类</p>
<p><code>AtomicInteger</code> 是 Java 中的原子类，它可以在不使用锁的情况下实现线程安全的操作，例如原子的自增、自减、比较交换等。适用于对共享变量进行简单的操作，例如计数器、标记等。</p>
</li>
</ol>
<h2 id="CountdownLatch和Semaphore的实现">CountdownLatch和Semaphore的实现</h2>
<p>CountDownLatch是Java中的一个同步工具类，可以帮助线程协调和等待。在使用CountDownLatch时，我们可以设置一个计数器，然后让多个线程并行执行，<strong>当所有线程完成任务后，计数器减为0，主线程才能继续执行。</strong></p>
<p>Semaphore是Java中的一个同步工具类，它可以控制同时访问某个资源的线程数目，以达到限流的效果。在使用Semaphore时，我们可以设置允许访问资源的线程数目，当达到该数目时，后续线程需要等待已有线程释放资源后才能访问。</p>
<p><strong>CountdownLatch用于保证线程的执行顺序，Semaphore用于控制并发数，表示同时允许最多多少个线程使用该信号量</strong></p>
<p><strong>CountdownLatch：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>); <span class="comment">// 创建CountDownLatch对象，初始计数器为3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(latch, <span class="string">&quot;Worker1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(latch, <span class="string">&quot;Worker2&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(latch, <span class="string">&quot;Worker3&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await(); <span class="comment">// 等待三个线程执行完成</span></span><br><span class="line">            System.out.println(<span class="string">&quot;All workers have finished their work!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is working...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">5000</span>)); <span class="comment">// 模拟工作耗时</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; has finished its work.&quot;</span>);</span><br><span class="line">        latch.countDown(); <span class="comment">// 计数器减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Worker2 is working...</span><br><span class="line">Worker3 is working...</span><br><span class="line">Worker1 is working...</span><br><span class="line">Worker3 has finished its work.</span><br><span class="line">Worker2 has finished its work.</span><br><span class="line">Worker1 has finished its work.</span><br><span class="line">All workers have finished their work!</span><br></pre></td></tr></table></figure>
<p><strong>Semaphore：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>); <span class="comment">// 创建Semaphore对象，初始许可证数量为2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建五个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker2&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker3&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker4&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker5&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Semaphore semaphore, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取一个许可证</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot; is working...&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">5000</span>)); <span class="comment">// 模拟工作耗时</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot; has finished its work.&quot;</span>);</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放一个许可证</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker1 is working...</span><br><span class="line">Worker2 is working...</span><br><span class="line">Worker2 has finished its work.</span><br><span class="line">Worker3 is working...</span><br><span class="line">Worker1 has finished its work.</span><br><span class="line">Worker4 is working...</span><br><span class="line">Worker3 has finished its work.</span><br><span class="line">Worker5 is working...</span><br><span class="line">Worker4 has finished its work.</span><br><span class="line">Worker5 has finished its work.</span><br></pre></td></tr></table></figure>
<h2 id="ReentrantLock源码">ReentrantLock源码</h2>
<img src="https://s2.loli.net/2023/04/06/HIOuvm9TCzxPaVb.png" alt="image" style="zoom:80%;" />
<h3 id="非公平锁：">非公平锁：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先竞争锁，若能竞争成功，则占有锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      <span class="comment">//将独占线程成员变量设置为当前线程，表示占有锁资源的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>NonfairSync类的acquire方法的流程图如下：</p>
<blockquote>
<p>整体逻辑是，通过getState()获取state状态值，判断是否已为0。若state等于0了，说明此时锁资源处于无锁状态，那么，当前线程就可以直接再执行一遍CAS原子抢锁操作，若CAS成功，说明已成功抢占锁。若state不为0，再判断当前线程是否与占有资源的锁为同一个线程，若同一个线程，那么就进行重入锁操作，即ReentrantLock支持同一个线程对资源的重复加锁，每次加锁，就对state值加1，解锁时，就对state解锁，直至减到0最后释放锁。</p>
<p>若!tryAcquire(arg)为false，就不会再执行后面代码。反之，若!tryAcquire(arg)为true，说明抢占锁失败了或者不属于重入锁，那么就会继续后续acquireQueued(addWaiter(Node.EXCLUSIVE), arg))代码的执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquire的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程引用</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取AQS的state状态值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//若state等于0了，说明锁处于无被占用状态，可被当前线程抢占</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//再次尝试通过CAS抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//将独占线程成员变量设置为当前线程，表示占有锁资源的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前线程是否与占有锁资源的线程为同一个线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="comment">//每次重入锁，state就会加1  </span></span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/04/06/wCEgZbxBjldpSYO.png" alt="image"></p>
<h3 id="公平锁">公平锁</h3>
<p>lock</p>
<p>acquires</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquires：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程引用</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取AQS的state状态值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//若state等于0了，说明锁处于无被占用状态，可被当前线程抢占</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//再次尝试通过CAS抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (！hasQueuedPredecessors() &amp;&amp; </span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//将独占线程成员变量设置为当前线程，表示占有锁资源的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前线程是否与占有锁资源的线程为同一个线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="comment">//每次重入锁，state就会加1  </span></span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasQueuedPredecessors()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在两种情况：</p>
<ol>
<li>
<p>第一种情况，h != t为false，说明head和tail节点都为null或者h和t都指向一个假节点head，这两种情况都说明了，此时的同步队列还没有初始化，简单点理解，就是<strong>在当前线程之前，还没有出现线程去抢占锁，因此，此时，锁是空闲的， 同时当前线程算上最早到来的线程之一</strong>（高并发场景下同一时刻可能存在N个线程同时到来），<strong>就可以通过CAS竞争锁</strong>。</p>
</li>
<li>
<p>第二种情况，h != t为true但(s = h.next) == null || s.thread != Thread.currentThread()为false，当头节点head和尾节点都不为空且指向不是同一节点，就说明同步队列已经初始化，此时至少存在两个以上节点，那么head.next节点必定不为空，即(s = h.next) == null会为false，若s.thread != Thread.currentThread()为false，说明假节点head的next节点刚好与当前线程为同一节点，也就意味着，<strong>当前线程排在队列最前面，排在前面的可以在锁空闲时获取锁资源，就可以执行compareAndSetState(0, acquires)去抢占锁资源。</strong></p>
</li>
</ol>
<p>若同步队列已经初始化，且当前线程又不是在假节点head的next节点，就只能去后面排队等待获取锁了.</p>
<h2 id="synchronized和lock锁的区别">synchronized和lock锁的区别</h2>
<ul>
<li>来源：<br>
lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</li>
<li>异常是否释放锁：<br>
synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</li>
<li>是否响应中断：<br>
lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</li>
<li>是否知道获取锁：<br>
Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</li>
<li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li>
<li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li>
<li>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，</li>
</ul>
<h2 id="synchronized-和-Reentrantlock的区别">synchronized 和 Reentrantlock的区别</h2>
<h3 id="相似点：">相似点：</h3>
<ol>
<li>都是加锁方式同步，并且是阻塞式同步</li>
<li>都是可重入锁</li>
<li>都保证了可见性和互斥性</li>
</ol>
<h3 id="区别：">区别：</h3>
<ol>
<li>synchronized是java中的关键字，而Reentrantlock是lock下的实现类，是API层面的锁</li>
<li>synchronized是非公平锁，Reentrantlock默认是非公平锁，但是也可以设置为公平锁</li>
<li>synchronized隐式释放锁，Reentrantlock显示获取锁和释放锁</li>
<li>Reentrantlock等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，可以避免synchronized的死锁。</li>
<li>Reentrantlock可以绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象</li>
</ol>
<h3 id="区别版本2">区别版本2</h3>
<p><strong>Chatgpt：</strong></p>
<p><code>Synchronized</code> 和 <code>ReentrantLock</code> 都是用来实现线程同步的机制，它们的作用是保证多个线程访问共享资源时的互斥性，从而避免数据竞争和不一致性的问题。它们的主要区别如下：</p>
<ol>
<li><strong>使用方式不同：</strong><code>Synchronized</code> 是 Java 中内置的关键字，通过在方法或代码块中添加 <code>synchronized</code> 关键字来实现线程同步。而 <code>ReentrantLock</code> 则是一个类，需要通过创建对象来使用。</li>
<li><strong>粒度不同：</strong><code>Synchronized</code> 的粒度较粗，只能对整个方法或代码块进行加锁，不能灵活控制锁的范围。而 <code>ReentrantLock</code> 的粒度较细，可以通过 <code>lock()</code> 和 <code>unlock()</code> 方法控制锁的获取和释放，从而灵活控制锁的范围。</li>
<li><strong>可中断性不同：</strong><code>ReentrantLock</code> 支持<strong>可中断锁和非可中断锁</strong>两种模式。在可中断锁模式下，线程在等待锁时可以被其他线程中断，从而避免了死锁问题。而 <code>Synchronized</code> 则不支持可中断锁模式。</li>
<li><strong>公平性不同：</strong><code>ReentrantLock</code> 支持公平锁和非公平锁两种模式。在公平锁模式下，锁的获取是按照线程请求的顺序进行的，可以避免饥饿问题。而 <code>Synchronized</code> 则是非公平锁模式。</li>
<li><strong>性能不同：</strong><code>ReentrantLock</code> 在高并发情况下的性能相对较好，因为它采用了 CAS 操作和自旋锁等优化方式来提高锁的竞争效率。而 <code>Synchronized</code> 的性能相对较低，因为它采用了操作系统提供的互斥锁来实现线程同步，涉及用户态和内核态的切换开销较大。</li>
</ol>
<h3 id="区别版本3">区别版本3</h3>
<p><img src="https://s2.loli.net/2023/03/10/D4TCFPvm2ptshUd.png" alt="image-20230310143817042"></p>
<p>区别</p>
<p><img src="https://s2.loli.net/2023/03/10/Z3kJh7zAXvNjDU5.png" alt="image-20230310143905383"></p>
<h2 id="ReentrantLock和Synchronized的底层实现">ReentrantLock和Synchronized的底层实现</h2>
<h3 id="ReentrantLock">ReentrantLock</h3>
<p>讲解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhujiqian/p/16898222.html">图解ReentrantLock底层公平锁和非公平锁实现原理</a></p>
<p>通过State+AQS实现</p>
<p>重入：同一个线程里面，有多次lock，state都会++</p>
<p><strong>公平锁：</strong></p>
<ol>
<li>尝试去加锁，先拿到自己的线程</li>
<li>看是否需要排队，不需要，则直接compareAndSetState去抢一次state</li>
<li>加锁的时候也会去判断是否需要重入（current == getExclusiveOwnerThread）</li>
<li>如果没有加成功，那就请求入队，addwaiter方法，入队不成功也会一直循环的</li>
<li>没成功的就会park，只有当前排队的线程node是头节点才会去改state</li>
<li>锁空出来，就会把队列第一个unpark</li>
</ol>
<p><strong>非公平锁：</strong></p>
<ol>
<li>直接加锁</li>
<li>如果没加成功，那就再尝试加一次</li>
<li>如果还没有成功，那就排队</li>
</ol>
<p>两者都只重写了lock方法，没有重写unlock方法，二者统一为release</p>
<p>使用举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="synchronized">synchronized</h3>
<p>讲解：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xyy1028/article/details/106042888">synchronized原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dreambyday/article/details/128767442?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-128767442-blog-106430463.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-128767442-blog-106430463.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=3">synchronized底层原理</a></li>
<li><a target="_blank" rel="noopener" href="https://medlen.blog.csdn.net/article/details/88384493?spm=1001.2101.3001.6650.13&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-13-88384493-blog-128767442.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-13-88384493-blog-128767442.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=19">synchronized底层实现原理及锁优化</a></li>
</ol>
<p><strong>实现原理：</strong></p>
<blockquote>
<p>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。</p>
<p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
</blockquote>
<p>实现了<strong>可见性和原子性</strong>：</p>
<ul>
<li>
<p><strong>可见性：synchronized每次加锁释放锁都会刷新工作内存，将更新完的数据写回到主内存中，然后从主内存中重新读取最新的数据</strong></p>
<blockquote>
<p>当线程释放锁时，JMM会把该线程对应的工作内存中的共享变量刷新到主内存中<br>
当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量，这样保证了内存的可见性</p>
</blockquote>
</li>
<li>
<p><strong>原子性：同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入，synchronized依靠两个字节码指令monitorenter和monitorexit，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问。</strong></p>
</li>
</ul>
<p>锁升级：MarkWord</p>
<h3 id="Monitor对象">Monitor对象</h3>
<p>在Java中，Monitor是一个同步机制，它是基于对象级别的锁（Object-level Lock）实现的。每个Java对象都有一个Monitor，它可以用于控制对象的访问，防止并发线程对对象进行不合适的访问。</p>
<p>具体来说，一个对象可以被视为一个监视器，也就是一个被多个线程共享的对象，通过<code>synchronized</code>关键字，线程可以进入到该对象的临界区，从而访问共享资源。同时，<code>Monitor</code>对象还可以实现等待和通知机制，即当线程在一个<code>Monitor</code>对象上等待时，其它线程可以通知该线程唤醒并继续执行。</p>
<p>Monitor主要有以下两个作用：</p>
<ol>
<li>保护共享资源：当多个线程访问同一个共享资源时，使用Monitor可以防止它们之间的竞争条件（Race Condition）。</li>
<li>提供线程间的通信机制：使用Monitor可以让线程在互斥的情况下进行相互等待和通知。</li>
</ol>
<p>在Java中，使用synchronized关键字可以获取对象的Monitor，从而实现同步。使用synchronized关键字声明的方法或代码块，在运行时只允许一个线程进入，其他线程必须等待。</p>
<h2 id="synchronized锁升级的过程">synchronized锁升级的过程</h2>
<p><img src="https://s2.loli.net/2023/04/07/bGYMnZBNLksx42S.png" alt="image-20230407155203902"></p>
<h3 id="偏向锁">偏向锁</h3>
<p>经过大量研究发现，<strong>大多数情况下锁是不存在多线程竞争的，而且总是会由同一线程多次获得</strong>，因此为了减少同一线程加锁解锁的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作即可再次获取锁，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以对于没有锁竞争的场合，偏向锁有很好的优化效果，但是在有多线程竞争锁的场合，偏向锁就失效了，这种场合下不应该使用偏向锁，将会优先升级为轻量级锁。</p>
<p>工作过程：</p>
<p>当 线程a 访问代码块并获取锁对象时，会通过 CAS 在 Mark Word 中记录偏向的锁的 threadID，因为偏向锁不会主动释放锁，因此以后再次获取锁的时候，需要比较当前线程的 threadID 和 Mark Word 中的threadID是否一致，如果一致，则无需使用CAS来加锁、解锁；如果不一致，则是因为有其他线程如 线程b 来竞争该锁，而偏向锁时不会主动释放锁，因此 Mark Word 存储的还是 线程a 的threadID，那么需要查看 Mark Word 中记录的 线程a 是否存活，如果没有存活，那么锁对象被重置为无锁状态，线程b 可以竞争将其设置为偏向锁；如果存活，那么立刻查找 线程a 的栈帧信息，如果还是需要继续持有这个锁，那么暂停当前 线程a，撤销偏向锁，升级为轻量级锁，如果 线程a 不再使用该锁，那么将锁状态设为无锁状态，重新偏向新的线程。</p>
<h3 id="轻量级锁">轻量级锁</h3>
<p>轻量级锁是由偏向锁升级而来，<strong>它考虑的情况是竞争锁的线程不多，而且线程持有锁的时间也不长的情景</strong>。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，性能的浪费就太大了，因此这个时候就干脆不阻塞这个线程，让它CAS自旋等待锁释放。</p>
<p>轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，轻量级锁在加锁过程中，用到了自旋锁来避免因为多线程的竞争而把线程马上在操作系统层面挂起的情况。</p>
<p>例如：线程a 获取轻量级锁时会先把锁对象的 Mark Word 复制一份到 线程a 的栈帧中存储锁记录的 LockRecord 中，然后使用cas操作把对象头的 Mark Word 的内容替换为 线程a 的 LockRecord 地址，并将Lock record里的owner指针指向对象的 Mark Word，如果在 线程a 复制对象头的同时（在 线程a cas之前），线程b 也准备获取锁，复制了对象头到 线程b 的锁记录空间中，但是在 线程b cas 的时候，发现 线程a 已经把对象头替换了，则 线程b 获取锁失败，那么 线程b 就尝试使用自旋锁来等待 线程a 释放锁。</p>
<h3 id="自旋锁">自旋锁</h3>
<p>虚拟机为了避免多线程的竞争而使线程马上在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程过于浪费性能，因此自旋锁会假设在较短的时间内，当前的线程便可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环原地等待（自旋），默认情况下自旋的次数是 10 次，在经过若干次循环后，如果得到锁，就顺利进入临界区。但是如果自旋次数到了持锁线程还还没有释放锁，或者持锁线程还在执行，下个线程还在自旋等待，这时又有第三个线程过来竞争这个锁，那就会将线程在操作系统层面挂起，这就是自旋锁提升效率的优化方式。如果自旋结束还是成功获取锁，则升级为重量级锁了。</p>
<p>不过需要注意的是，自旋会消耗 cpu。所以轻量级锁适用于那些同步代码块执行的很快的场景。</p>
<h3 id="自适应自旋锁">自适应自旋锁</h3>
<p>在 JDK1.6 之后，引入了自适应自旋锁，自适应意味着<strong>自旋的次数不是固定不变的，而是根据同一个锁上一次自旋的时间和拥有锁线程的状态来决定，目的是最大的提高处理器资源利用率</strong>。</p>
<p>对于某个锁，如果线程通过自旋成功获得过该锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h3 id="重量级锁">重量级锁</h3>
<p><strong>当轻量级锁膨胀到重量级锁之后，意味着线程只能被真正的挂起阻塞，然后等待被唤醒。重量级锁的实现方式即为第四节所属的利用每个对象都用的</strong> <strong>monitor</strong> <strong>内置锁。</strong></p>
<h2 id="synchronized实现可见性的过程">synchronized实现可见性的过程</h2>
<ol>
<li>获得互斥锁（同步获取锁）</li>
<li>清空本地内存</li>
<li>从主内存拷贝变量的最新副本到本地内存</li>
<li>执行代码</li>
<li>将更改后的共享变量的值刷新到主内存</li>
<li>释放互斥锁</li>
</ol>
<h2 id="ReentrantLock-锁可限时功能">ReentrantLock 锁可限时功能</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 等待 2 秒尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                <span class="comment">// do something...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理中断异常</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized加在普通方法和静态方法有什么区别">synchronized加在普通方法和静态方法有什么区别</h2>
<ol>
<li>普通方法：使用<code>synchronized</code>关键字修饰的普通方法会锁住当前对象实例，即锁住当前对象的实例变量，当一个线程进入该方法时，其他线程无法访问该对象的其他<code>synchronized</code>方法，但是可以访问非<code>synchronized</code>方法。</li>
<li>静态方法：使用 <code>synchronized</code> 关键字修饰的静态方法会锁住当前类的 Class 对象，即锁住该类的所有实例。当一个线程进入该方法时，其他线程无法同时访问该类的其他<code>static synchronized</code>方法，但是可以访问该类的非<code>static synchronized</code>方法。</li>
</ol>
<h2 id="ReentrantLock的公平锁和非公平锁优缺点">ReentrantLock的公平锁和非公平锁优缺点</h2>
<p>公平锁优点：</p>
<ul>
<li>公平锁会按照请求锁的顺序来获取锁，避免了饥饿现象，即线程永远无法获取锁的情况。</li>
<li>公平锁的执行顺序比较合理，<strong>可以保证线程按照其提交请求的顺序执行</strong>。</li>
</ul>
<p>公平锁缺点：</p>
<ul>
<li>公平锁在竞争激烈的情况下，<strong>会导致线程上下文切换的频繁，降低了系统的吞吐量</strong>。</li>
<li>公平锁<strong>需要维护一个等待队列，增加了系统开销。</strong></li>
</ul>
<p>非公平锁优点：</p>
<ul>
<li>非公平锁的执行效率比公平锁高，因为<strong>避免了上下文切换的开销</strong>。</li>
<li>非公平锁可以通过“插队”来获取锁，<strong>如果前面的线程已经释放了锁，后面的线程可以直接获取锁，减少了等待的时间</strong>。</li>
</ul>
<p>非公平锁缺点：</p>
<ul>
<li>非公平锁的<strong>执行顺序是不确定的</strong>，可能会<strong>出现某些线程一直获取不到锁的情况，从而产生饥饿现象</strong>。</li>
</ul>
<h2 id="volatile关键字是怎么实现的">volatile关键字是怎么实现的</h2>
<p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序</p>
<p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取</p>
<h2 id="sleep和wait的区别-2">sleep和wait的区别</h2>
<ol>
<li>sleep⽅法属于Thread类，wait⽅法属于Object类</li>
<li>在调⽤sleep⽅法的过程中，线程不会释放对象锁，⽽wait会释放对象锁，别的线程是可能获取到的</li>
<li>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong></li>
<li><strong>调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态</strong></li>
<li>wait 方法必须配合 synchronized 一起使用，不然在运行时就会抛出 IllegalMonitorStateException 的异常，而 sleep 可以单独使用，无需配合 synchronized 一起使用</li>
</ol>
<h2 id="CAS">CAS</h2>
<p>CAS指令有三个操作数，分别是内存偏移量V（可理解为内存地址），旧的预期值E，准备设置的新值N</p>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了V，则当前线程放弃更新</p>
<h3 id="CAS可能的问题：">CAS可能的问题：</h3>
<ol>
<li><strong>ABA问题</strong>：解决用版本号或时间戳</li>
<li><strong>循环时间长开销大</strong>：CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销，解决用pause指令</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，解决在jdk1.5后：可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作</li>
</ol>
<h2 id="乐观锁和悲观锁">乐观锁和悲观锁</h2>
<p>悲观锁和乐观锁并不是某个具体的“锁”⽽是⼀种并发编程的基本概念</p>
<h3 id="悲观锁">悲观锁</h3>
<p><strong>定义：</strong></p>
<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放</p>
<p>即：<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong></p>
<p><strong>使用场景：</strong></p>
<p>悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能</p>
<h3 id="乐观锁">乐观锁</h3>
<p><strong>定义：</strong></p>
<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</p>
<p><strong>使用场景：</strong></p>
<p>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量</p>
<p><strong>实现：</strong></p>
<ol>
<li>
<p><strong>版本号机制：</strong></p>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功</p>
</li>
<li>
<p><strong>CAS算法</strong></p>
</li>
</ol>
<h1>计网</h1>
<h2 id="常用状态码">常用状态码</h2>
<p>301,302,500，501，502，401,402,403,404</p>
<p><img src="https://s2.loli.net/2023/02/25/RNLkfzU2HGlWge5.png" alt=""></p>
<p><img src="https://s2.loli.net/2023/02/25/LRerzM46Z9tX2Il.png" alt="image-20230225204425405"></p>
<p><img src="https://s2.loli.net/2023/02/25/YvlgQ5eIPfXKFhd.png" alt="image-20230225204414914"></p>
<h2 id="常见的请求头">常见的请求头</h2>
<p>HTTP请求头是在HTTP请求中发送的附加信息</p>
<ol>
<li>User-Agent：指定发送请求的客户端类型和版本。</li>
<li>Accept：指定客户端可接受的内容类型（MIME类型）。</li>
<li>Content-Type：指定发送请求的实体的媒体类型。</li>
<li>Authorization：包含用于身份验证的凭据，如基本身份验证或Bearer令牌。</li>
<li>Cookie：包含在先前的响应中设置的Cookie，用于维护会话状态。</li>
<li>Referer：指示从哪个URL发送请求。</li>
<li>If-Modified-Since：指定一个日期，服务器将只返回在该日期之后更新的资源。</li>
<li>Cache-Control：指定请求/响应链中的缓存行为。</li>
<li>Connection：指定是否在请求后保持打开状态，以允许在同一连接上发送多个请求/响应对。</li>
<li>Host：指定服务器的主机名和端口号</li>
</ol>
<h2 id="OSI七层模型">OSI七层模型</h2>
<ol>
<li>**应用层：**各种应用程序协议，比如 HTTP、HTTPS、FTP、SOCKS 安全套接字协议、DNS 域名系统、GDP 网关发现协议等等</li>
<li>**表示层：**加密解密、转换翻译、压缩解压缩，比如 LPP 轻量级表示协议</li>
<li>**会话层：**不同机器上的用户建立和管理会话，比如 SSL 套接字层协议、TLS 传输层安全协议、RPC 远程过程调用协议等等</li>
<li>**传输层：**接受上一层的数据，在必要的时候对数据进行分割，并将这些数据交给网络层，保证这些数据段有效到达对端，比如 TCP传输控制协议、UDP 数据报协议</li>
<li>**网络层：**控制子网的运行：逻辑编址、分组传输、路由选择，比如 IP、IPV6、SLIP 等等。数据链路层：物理寻址，同时将原始比特流转变为逻辑传输路线，比如 XTP 压缩传输协议、PPTP 点对点隧道协议等等</li>
<li>**数据链路层：**物理寻址，同时将原始比特流转变为逻辑传输路线，比如 XTP 压缩传输协议、PPTP 点对点隧道协议等等</li>
<li>**物理层：**机械、电子、定时接口通信信道上的原始比特流传输，比如 IEEE802.2 等等</li>
</ol>
<h2 id="四层网络模型">四层网络模型</h2>
<ol>
<li>**应用层：**对应于OSI七层参考模型的应用层和表达层，如HTTP,FTP,Telent(远程终端协议)  ,SWTP(简单邮件传送协议)协议</li>
<li>**传输层：**对应于OSI七层参考模型的传输层，TCP，UDP协议</li>
<li>**网际层：**ARP，RARP协议</li>
<li>**网络接口层：**用于协作IP数据在已有网络介质上传输的协议</li>
</ol>
<h2 id="HTTP1-2-3缺陷">HTTP1/2/3缺陷</h2>
<h3 id="HTTP缺陷">HTTP缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/wD7QIp951mFfC4P.png" alt="image-20230225204244708"></p>
<h3 id="HTTP1-1缺陷">HTTP1.1缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/6QyaX12SmWkGInN.png" alt="image-20230225204202208"></p>
<p>以及高延迟问题：</p>
<p><img src="https://s2.loli.net/2023/02/25/H3QOgP8r42yD9WA.png" alt="image-20230225204745802"></p>
<p><strong>HTTP2改进：二进制分帧（帧对数据进行顺序标识），数据流，多路复用（连接共享），头部压缩，服务器推送</strong></p>
<h3 id="HTTP-2缺陷">HTTP/2缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/xlym3cu2zd5VYKo.png" alt="image-20230225204104566"></p>
<p><img src="https://s2.loli.net/2023/02/25/gHqskGcOQ47jr2U.png" alt="image-20230225204925272"></p>
<p>解决用QUIC：</p>
<p><img src="https://s2.loli.net/2023/02/25/K2zqmTVJr5DZQBP.png" alt="image-20230225204856451"></p>
<h2 id="HTTP的队头阻塞">HTTP的队头阻塞</h2>
<p>多路复用，HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题， 降低了延迟，⼤幅度提⾼了连接的利⽤率</p>
<h2 id="HTTP与HTTPS的区别（细扣）">HTTP与HTTPS的区别（细扣）</h2>
<ul>
<li>https协议需要到ca申请证书</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，<strong>前者是80，后者是443</strong>。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<h2 id="TCP和UDP的区别">TCP和UDP的区别</h2>
<p><img src="https://s2.loli.net/2023/02/20/ZHiR2TzWVIXnL3A.jpg" alt=""></p>
<p><strong>应用场景：</strong></p>
<p><img src="https://s2.loli.net/2023/02/28/kmJyhqtENjOofG1.png" alt="image-20230228134610615"></p>
<h2 id="TCP怎样确认数据的完整性">TCP怎样确认数据的完整性</h2>
<ol>
<li>**序列号：**TCP将每个发送的数据包分配一个序列号，接收方通过比较序列号来确认是否收到了所有的数据包。<strong>如果接收方收到的数据包的序列号不连续，那么它会请求发送方重新发送这些数据包。</strong></li>
<li>**确认应答：**接收方会向发送方发送确认应答（ACK）消息来确认已经成功接收了数据包。发送方会在收到ACK消息后，将发送的数据包标记为已确认。<strong>如果发送方没有收到ACK消息，它会认为数据包没有被正确接收，并尝试重新发送数据包</strong>。</li>
</ol>
<h2 id="https加密过程（详细）">https加密过程（详细）</h2>
<ol>
<li>客户端发送请求：客户端向服务器发送一个HTTPS请求，请求中包含一个特殊的标识（https://），表示客户端希望与服务器进行HTTPS加密通信。</li>
<li>服务器端的SSL证书：服务器收到请求后，会向客户端发送一个SSL证书，证书包含服务器的公钥、证书颁发机构等信息。</li>
<li>客户端验证SSL证书：客户端收到服务器发送的SSL证书后，会验证证书的有效性。验证包括证书的签名是否合法、证书是否过期、证书颁发机构是否可信等，如果验证通过，客户端就可以信任服务器的公钥了。</li>
<li>客户端生成密钥：客户端生成一个随机的对称加密密钥，用于后续的通信数据加密。</li>
<li>客户端使用公钥加密密钥：客户端使用服务器发送的SSL证书中包含的公钥，将生成的对称加密密钥加密后，发送给服务器。</li>
<li>服务器使用私钥解密密钥：服务器收到客户端发送的加密密钥后，使用自己的私钥进行解密，得到对称加密密钥。</li>
<li>通信数据加密：客户端和服务器使用对称加密密钥，对通信数据进行加密和解密。这样，只有客户端和服务器之间才能够解密通信数据，保证了通信的安全性。</li>
<li>通信数据传输：客户端和服务器使用加密后的通信数据进行通信，保证了数据的机密性和完整性。</li>
</ol>
<h2 id="ping的发送和接收过程">ping的发送和接收过程</h2>
<ol>
<li>源主机先构建一个ICMP回送请求消息数据包，包含字段，类型（8），序号(用于区分连续ping的时候发出的多个数据包)以及发送时间</li>
<li>ICMP协议将数据包连同目标主机地址一起交给IP层，IP层进一步将本机IP地址作为源地址，协议字段设置为1表示是ICMP协议</li>
<li>加入MAC头，如果在本地ARP映射表中查找出对应的MAC地址，则直接使用，如果没有，则发送ARP协议查询MAC地址，获得后由数据链路层构建一个数据帧</li>
<li>主机 B 收到这个数据帧后，先检查它的⽬的 MAC 地址，并和本机的 MAC 地址对⽐，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样， IP 层检查后，将有⽤的信息提取后交给 ICMP 协议</li>
<li>主机B会构建⼀个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0 ， 序号为接收到的请求数据包中的序号，然后再发送出去给主机A，在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明⽬标主机不可达；如果接收到了 ICMP 回送响应消息，则说明⽬标主机可达。</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/r4fB1Hn59tekvgQ.png" alt="image-20230220135609934"></p>
<h2 id="如果TCP连接不成功，但是ping可以ping通，如何排查网络问题"><strong>如果TCP连接不成功，但是ping可以ping通，如何排查网络问题</strong></h2>
<ol>
<li>
<p>检查<strong>TCP端口是否开放</strong>。TCP连接需要通过目标主机的TCP端口进行连接，如果目标主机的TCP端口没有开放，则无法建立TCP连接。可以使用telnet命令或者其他网络工具来检查目标主机的TCP端口是否开放。</p>
</li>
<li>
<p>检查<strong>网络防火墙设置</strong>。网络防火墙可能会对TCP连接进行限制，需要检查网络防火墙的设置，确认是否允许该TCP连接通过。</p>
</li>
<li>
<p>检查<strong>DNS解析是否正确</strong>。如果目标主机的域名有多个IP地址，需要检查DNS解析是否正确，确认TCP连接的目标IP地址是否正确。</p>
</li>
<li>
<p>检查<strong>目标主机的TCP连接队列是否满了</strong>。如果目标主机的TCP连接队列已满，可能会导致TCP连接失败。可以尝试增加目标主机的TCP连接队列大小，或者等待目标主机释放部分TCP连接资源。</p>
<hr>
</li>
<li>
<p>检查<strong>网络负载均衡设置</strong>。如果目标主机处于负载均衡环境下，需要检查负载均衡的设置，确认是否允许该TCP连接通过。</p>
</li>
</ol>
<h2 id="浏览器输入一个url的处理过程">浏览器输入一个url的处理过程</h2>
<p><img src="https://s2.loli.net/2023/02/20/BwlAIdDYTcsaOQz.png" alt="image-20230220153505776"></p>
<ol>
<li><strong>解析URL，生成发送给Web服务器的HTTP请求信息</strong>（包含服务器名称以及数据源文件的路径名）</li>
<li><strong>通过DNS查询服务器域名对应的IP地址</strong></li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/3vGxp6Ynk2NRrlc.png" alt="image-20230220150008877"></p>
<ol start="3">
<li>
<p>通过DNS获得到IP后，把HTTP的传输工作交给操作系统中的协议栈，<strong>建立TCP连接</strong></p>
<p>包含TCP，IP(ICMP，ARP（⽤于根据 IP 地址查询相应的以太⽹ MAC 地址  ）)</p>
<p>具体包含：TCP三次握手，TCP分割数据</p>
<ul>
<li>ICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息。</li>
<li>ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址</li>
</ul>
<p>在发包时：</p>
<blockquote>
<p>先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中的地址。⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询</p>
</blockquote>
</li>
<li>
<p>分别加上HTTP报文，TCP头部，IP头部，MAC头部，MAC包头协议类型只使用0800表示IP协议或者0806表示ARP协议</p>
<p><strong>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象</strong></p>
<p><strong>⽣成了 IP 头部之后，接下来网络包还需要在 IP 头部的前⾯加上 MAC 头部</strong></p>
<p>这里可以直接：<strong>服务器处理该HTTP请求，返回一个HTML文件；浏览器解析该HTML文件，并且显示在浏览器端</strong></p>
</li>
<li>
<p>通过网卡传播，转换为电信号</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/CcEYbg25nMVQJ78.png" alt="image-20230220153152419"></p>
<ol start="6">
<li>
<p>通过交换机</p>
<ul>
<li>交换机⼯作在 MAC 层，是基于以太⽹设计的，也称为⼆层⽹络设备</li>
<li>交换机的端⼝不具有 MAC 地址</li>
<li>将包存⼊缓冲区后，接下来需要查询⼀下这个包的接收⽅ MAC 地址是否已经在 MAC 地址表中有记录了，如果有则直接进行转发，如果没有，则转发到除源端口外的所有端口上</li>
</ul>
</li>
<li>
<p>通过路由器</p>
<p>路由器是基于 IP 设计的，俗称<strong>三层网络设备</strong>，路由器的各个端⼝都具有 MAC 地址和 IP 地址</p>
</li>
<li>
<p>服务器的永久重定向响应</p>
</li>
<li>
<p>服务器处理HTTP请求，并返回HTTP响应，浏览器进行页面渲染</p>
</li>
<li>
<p>断开TCP连接</p>
</li>
</ol>
<h2 id="DNS解析的过程">DNS解析的过程</h2>
<ol>
<li>⾸先会在本地的hosts⽂件中查找是否有这个⽹址的映射关系，如果有则直接调⽤这个IP的映射进⾏访问，</li>
<li>如果没有则会去本地DNS解析缓存查找是否有这个网址的映射关系，如果有则返回</li>
<li>如果没有，则去根服务器查询该网址对应的 IP 地址</li>
<li>根服务器返回顶级域名服务器的网址，然后本地 DNS 服务器去顶级域名服务器查询该网址对应的 IP 地址</li>
</ol>
<h2 id="三次握手过程">三次握手过程</h2>
<ul>
<li>
<p>第一个报文：SYN报文：客户端随机初始化32位序列号client_isn，并进入SYN_SEND状态，等待服务器确认</p>
</li>
<li>
<p>第二个报文：SYN+ACK报文：服务端随机初始化32位序列号server_isn，确认应答号为收到的客户端ISN+1，服务器进入SYN_RECV状态</p>
</li>
<li>
<p>第三个报文：ACK报文：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK，确认应答号为收到服务端的ISN+1，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/28/NSvI7JmfVXDhwHY.png" alt="image-20230228141655187"></p>
<h2 id="四次挥手过程">四次挥手过程</h2>
<ul>
<li>客户端发送FIN报文，客户端进入FIN_WAIT_1状态</li>
<li>服务端收到后发送ACK应答报文，并进入CLOSED_WAIT状态</li>
<li>客户端收到ACK后进入FIN_WAIT_2状态</li>
<li>等服务端处理完数据，会向客户端发送FIN报文，并进入LAST_ACK状态</li>
<li>客户端收到FIN报文后，回一个ACK应答报文，并进入TIME_WAIT状态</li>
<li>服务器收到ACK报文后，进入CLOSED状态</li>
<li>客户端在经过2MSL时间后，自动进入CLOSED状态</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/28/pyobLrQEltsVn3Z.png" alt="image-20230228141632925"></p>
<h2 id="TCP-三次握手，两次、四次不行吗">TCP 三次握手，两次、四次不行吗</h2>
<ul>
<li>三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）</li>
<li>三次握⼿才可以同步双⽅的初始序列号</li>
<li>三次握⼿才可以避免资源浪费</li>
</ul>
<p>**「两次握⼿」：**⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；</p>
<p>**「四次握⼿」：**三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数</p>
<h2 id="TIME-WAIT-状态是做什么用的">TIME_WAIT 状态是做什么用的</h2>
<p>⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都自然消失，再出现的数据包⼀定都是新建立连接所产⽣的</p>
<p>**报文最大生存时间  **：2MSL</p>
<h2 id="为什么是2MSL">为什么是2MSL</h2>
<p><strong>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间</strong></p>
<h2 id="拥塞控制算法">拥塞控制算法</h2>
<ol>
<li>
<p>慢启动</p>
</li>
<li>
<p>拥塞避免</p>
</li>
<li>
<p>拥塞发⽣</p>
</li>
<li>
<p>快速恢复</p>
</li>
</ol>
<h2 id="TCP是如何保证高可靠的">TCP是如何保证高可靠的</h2>
<ul>
<li>流式传输</li>
<li>一对一传输</li>
<li>重传机制：超时重传+快速重传+SACK+D-SACK</li>
<li>滑动窗口</li>
<li>拥塞控制：慢启动，拥塞避免，拥塞发生，快速回复</li>
<li>流量控制</li>
<li>三次握手、四次挥手</li>
</ul>
<h2 id="ping-基于什么协议">ping 基于什么协议</h2>
<p>ICMP协议</p>
<h2 id="网络层和传输层有什么区别">网络层和传输层有什么区别</h2>
<ol>
<li>网络层和传输层的位置不同。网络层位于OSI模型的第三层，主要负责处理网络间的数据传输和路由；而传输层位于第四层，主要负责端到端的数据传输和可靠性保证。</li>
<li>网络层和传输层的协议不同。网络层使用的协议有IP（Internet Protocol，互联网协议）、ICMP（Internet Control Message Protocol，互联网控制报文协议）等，传输层使用的协议有TCP（Transmission Control Protocol，传输控制协议）、UDP（User Datagram Protocol，用户数据报协议）等。</li>
<li>网络层和传输层的功能不同。网络层的主要功能是负责将数据包从源节点传输到目的节点，实现跨网络的数据传输和路由选择；而传输层的主要功能是提供端到端的数据传输和可靠性保证，确保数据的完整性、可靠性和有序性。</li>
<li>网络层和传输层的数据单位不同。网络层的数据单位是IP数据包，它包含了源IP地址、目的IP地址和数据；而传输层的数据单位是TCP数据段或UDP数据包，它们包含了端口号、序号、确认号等信息。</li>
</ol>
<h2 id="ARP协议？工作机制介绍一下">ARP协议？工作机制介绍一下</h2>
<p>ARP协议是一种用于将IP地址解析为MAC地址的协议</p>
<ol>
<li>当主机A需要向主机B发送数据时，首先会检查自己的ARP缓存中是否已经有了B的MAC地址。如果有，直接发送数据包；如果没有，执行下一步。</li>
<li>主机A会发送一个ARP请求广播消息，该消息包含了主机A的MAC地址和IP地址以及需要解析的目标IP地址（即主机B的IP地址），并将该消息发送到本地网络中的所有主机。</li>
<li>当主机B收到ARP请求消息时，会检查消息中的目标IP地址是否是自己的IP地址。如果是，就会向主机A发送一个ARP响应消息，该消息包含了主机B的MAC地址和IP地址，并将该消息直接发送给主机A。</li>
<li>当主机A收到ARP响应消息时，就可以得到主机B的MAC地址了。主机A将该地址存储到自己的ARP缓存中，并使用该地址发送数据包到主机B。</li>
</ol>
<p>需要注意的是，ARP协议只能在本地网络中进行地址解析，如果需要向其他网络的主机发送数据，就需要进行路由和转发操作，需要使用其他协议，例如IP和路由协议等。</p>
<h2 id="session和cookie的区别">session和cookie的区别</h2>
<ol>
<li>存储位置：Cookie是保存在客户端浏览器中的，而Session是保存在服务器端的。</li>
<li>安全性：Cookie的存储位置是在客户端，容易被窃取或篡改，从而引发安全问题，而Session的存储位置是在服务器端，相对安全。</li>
<li>存储容量：Cookie的存储容量有限，通常只能存储几KB的数据，而Session的存储容量相对较大，可以存储几MB的数据。</li>
<li>浏览器对于单个Cookie的大小有限制（4kb），且对同一个域名下的总Cookie数量也有限制（20个）,而Session没有数据大小限制</li>
<li>生命周期：Cookie可以设置过期时间，可以在客户端保存一段时间，即使关闭了浏览器也可以再次访问，而Session通常在客户端关闭浏览器后失效。</li>
<li>使用方式：Cookie可以被JavaScript读取和设置，可以在客户端进行处理，而Session只能在服务器端进行处理。</li>
<li>功能：Cookie通常用于记住用户的偏好设置和登录状态等信息，而Session通常用于在不同页面间共享数据和维护会话状态等。</li>
</ol>
<p>补充：分布式环境下的session：</p>
<ol>
<li>任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</li>
</ol>
<h2 id="如果客户端禁用Cookie，怎么保持Session同步">如果客户端禁用Cookie，怎么保持Session同步</h2>
<ol>
<li>在URL中传递Session ID：Web应用程序可以将Session ID作为URL的一部分来传递，例如 <a target="_blank" rel="noopener" href="https://example.com/page?sessionid=123456%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%8D%B3%E4%BD%BF%E7%A6%81%E7%94%A8%E4%BA%86Cookie%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87URL%E6%9D%A5%E4%BC%A0%E9%80%92Session">https://example.com/page?sessionid=123456，这样即使禁用了Cookie，也可以通过URL来传递Session</a> ID，从而实现Session同步。但这种方法会增加URL的复杂度和长度，容易被拦截、泄露和篡改</li>
<li>在表单隐藏字段中传递Session ID：Web应用程序可以在HTML表单的隐藏字段中传递Session ID，例如 &lt;input type=“hidden” name=“sessionid” value=“123456”&gt;，这样即使禁用了Cookie，也可以通过表单提交来传递Session ID，从而实现Session同步。但这种方法需要修改所有的表单，增加了代码维护成本。</li>
<li>使用IP地址和浏览器指纹识别：Web应用程序可以使用客户端IP地址和浏览器指纹等信息来识别客户端，从而实现Session同步。但这种方法存在误判和误识别的风险，同时也容易受到欺骗和攻击。</li>
<li>使用其他存储方式：Web应用程序可以使用其他存储方式来保存Session，例如使用数据库、文件系统、内存缓存等。这种方法可以实现Session同步，但也增加了服务器负担和存储成本，并且需要考虑并发访问和数据一致性等问题。</li>
</ol>
<h1>数据库</h1>
<h2 id="Mysql存储引擎有哪些">Mysql存储引擎有哪些</h2>
<h2 id="三大范式">三大范式</h2>
<ol>
<li>每个字段都不能再拆分</li>
<li>在第⼀范式的基础上，非主键字段列完全依赖于主键</li>
<li>在第⼆范式的基础上，非主键字段列依赖于主键且不依赖于其他非主键</li>
</ol>
<h2 id="索引的分类">索引的分类</h2>
<p><img src="https://s2.loli.net/2023/02/24/rHYlZaomMWi8cvx.png" alt="image-20230224215556320"></p>
<p><img src="https://s2.loli.net/2023/02/24/AChFDe829wUI1Mg.png" alt="image-20230224215636648"></p>
<p>聚簇索引(Clustered Indexes)保证关键字的值相近的元组存储的物理位置也相同，且一个表只能有一个聚簇索引。字符串类型不建议使用聚簇索引，特别是随机字符串，因为它们会使系统进行大量的移动操作。并不是所有的存储引擎都支持聚簇索引，目前InnoDB支持。如果使用聚簇索引，最好使用AUTO_INCREMENT列作为主键，应该尽量避免使用随机的聚簇主键</p>
<h2 id="索引如何生成的">索引如何生成的</h2>
<p><img src="https://s2.loli.net/2023/02/24/HW1Uj8hqDLQ4Ez7.png" alt="image-20230224215752844"></p>
<p><img src="https://s2.loli.net/2023/02/24/GpDQY54sUzkS1dP.png" alt="image-20230224215901738"></p>
<h2 id="索引的优点和缺点">索引的优点和缺点</h2>
<p>索引是帮助Mysql高效的从磁盘中检索数据的一种数据结构，在Mysql的InnoDB引擎里面采用的是B+树的结构来实现索引和数据的存储</p>
<p>优点：</p>
<ol>
<li>通过B+树的结构来存储数据，可以大大减少数据检索时磁盘的IO次数，从而提升数据查询的性能</li>
<li>B+树索引在进行范围查找的时候，只需要找到起始节点，然后基于叶子节点的链表结构往下读取即可，查询效率较高</li>
<li>通过唯一索引约束，可以保证数据表中每一行数据的唯一性</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据的增删改，需要涉及到索引的维护，当数据量较大的情况下，索引的维护会带来较大的性能开销</li>
<li>一个表中允许存在一个聚簇索引和多个非聚簇索引，但是索引数不能创建太多，否则造成的索引维护成本过高</li>
<li>创建索引的时候，需要考虑到索引字段值的分散性，如果字段的重复数据过多，创建索引反而会带来性能降低</li>
</ol>
<h2 id="创建索引需要注意的点">创建索引需要注意的点</h2>
<ol>
<li>选择选择性高的，即重复度低的列创建索引，比如性别不适合而身份证号适合</li>
<li>选择经常用于查询的列创建索引</li>
<li>多表关联查询时作为关联条件的列适合创建索引</li>
<li>值会频繁变化的列不适合建索引</li>
<li>⼀张表上不要建太多的索引，太多的话会严重影响数据增删改的性能。也会耗费很⼤的磁盘空间</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/24/DqhCnjtN5PAHGY2.png" alt="image-20230324230009913"></p>
<h2 id="联合索引">联合索引</h2>
<p>多个字段组合一起作为索引，它支持最左前缀原则即最左匹配原则，</p>
<h2 id="最左匹配原则">最左匹配原则</h2>
<p>如果想使用联合索引，联合索引的最左边的列必须作为过滤条件，否则联合索引不会生效，mysql会⼀直向右匹配直⾄遇到范围查询(&gt;、&lt;、between、like)就停⽌匹配</p>
<h2 id="覆盖索引">覆盖索引</h2>
<p>不是索引结构，可以理解为是一种优化手段</p>
<p>因为在使⽤辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据</p>
<p>从辅助索引中查询得到记录，⽽不需要通过聚族索引查询获得，MySQL 中将其称为覆盖索引</p>
<p>好处：<strong>不需要查询出包含整⾏记录的所有信息，因此可以减少大量的 I/O 操作</strong></p>
<p>距离：</p>
<p>​		假设我们只需要查询商品的名称、价格信息，我们有什么⽅式来避免回表呢？我们可以建⽴⼀个组合索引，即商品编码、名称、价格作为⼀个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从⽽避免回表</p>
<h2 id="索引在更新-插入后究竟何时更新">索引在更新/插入后究竟何时更新</h2>
<p>是在更新/插入查询返回之前，还是在查询返回之后的某个时间，还是在执行使用索引的查询时？</p>
<ol>
<li>第一部分是在索引中插入/更新/删除条目。一旦记录发生更改，索引就会立即更新，并且此过程会阻塞查询直到完成。</li>
</ol>
<h2 id="什么情况下建立索引，什么情况不建立索引">什么情况下建立索引，什么情况不建立索引</h2>
<h3 id="适合建索引的情况">适合建索引的情况</h3>
<ol>
<li>
<p>频繁作为where条件语句查询字段</p>
</li>
<li>
<p>关联字段需要建立索引</p>
</li>
<li>
<p>排序字段可以建立索引</p>
</li>
<li>
<p>分组字段可以建立索引(因为分组前提是排序)</p>
</li>
<li>
<p>统计字段可以建立索引（如.count(),max()）</p>
</li>
</ol>
<h3 id="不适合建索引的情况">不适合建索引的情况</h3>
<ol>
<li>
<p>频繁更新的字段不适合建立索引</p>
</li>
<li>
<p>where条件中用不到的字段不适合建立索引</p>
</li>
<li>
<p>可以确定表数据比较少不需要建立索引</p>
</li>
<li>
<p>数据重复且发布比较均匀的字段不适合建索引（如性别，真假值）</p>
</li>
<li>
<p>参与列计算的列不适合建索引</p>
</li>
</ol>
<h2 id="数据库的索引对应的什么文件">数据库的索引对应的什么文件</h2>
<p>.idb：表示数据文件</p>
<p>frm：表示表的定义文件，即表结构信息文件</p>
<h2 id="为什么MySQL数据库使用B-树不使用B树">为什么MySQL数据库使用B+树不使用B树</h2>
<p>当存储同数量级的数据的时候，B+树的⾼度⽐B树的⾼度⼩，这样的话进程IO操作的次数就少，效果就⾼。因为B+树的所有⾮叶⼦节点只存索引，数据存在叶⼦节点，⼀般3层的树⾼度，即可存千万级别的数据，⽽B数不⾏</p>
<p>B+树：</p>
<ol>
<li>
<p>非叶子结点不存储data，只存储索引，可以放更多的索引</p>
<p>data存：索引所在行的偏移地址或者行中所有列的数据</p>
</li>
<li>
<p>叶子节点包含所有索引字段</p>
</li>
<li>
<p>叶子节点用指针连接，提高区间的访问性能</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/08/uImSp7VvAFiZbBy.png" alt="image-20230308204237150"></p>
<p>InnoDB中：</p>
<ol>
<li>表必须建主键，并且推荐使用整型的自增主键</li>
<li>聚集索引-叶子节点包含了完整的数据记录</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/08/Z1YUDE4MreA6CvL.png" alt="image-20230308210906180"></p>
<h2 id="数据库索引为什么用B-树不用哈希、红黑树">数据库索引为什么用B+树不用哈希、红黑树</h2>
<p>平衡二叉树（AVL）：所有左右子树高度差不能超过1，查找效率固定为O(logn)，插入时，最多只需要1次旋转，删除时，需要维护整条路径</p>
<p>红黑树：追求大致的平衡，确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍</p>
<p>B树查询时间复杂度在1到树高之间，B+树的查询复杂度则稳定为树高</p>
<img src="https://s2.loli.net/2023/04/04/FREWPniw9Jxr2Be.png" alt="image-20230404104530262" style="zoom:67%;" />
<hr>
<p>不用二叉树：顺序插入时，会形成一个链表，查询性能大大降低，大数据量情况下，层级较深，检索速度慢（解决，使用红黑树，因为是自平衡二叉树）</p>
<p>不用红黑树：大数据量情况下，层级较深，检索速度慢</p>
<p>不用B树（多路平衡查找树）：插入时中间元素会发生向上裂变，但是缺点是每个节点会存储数据，利用不够充分</p>
<p><img src="https://s2.loli.net/2023/02/24/achAUCkrNx3EuTK.png" alt="image-20230224214811313"></p>
<p>不用hash：</p>
<p><img src="https://s2.loli.net/2023/02/24/gSEuB2awq5P4bOk.png" alt="image-20230224215420443"></p>
<p>B+树：在裂变的同时叶子节点还存有值，即所有节点都会存在于叶子节点中，并且叶子节点还有单向链表，Mysql中进行了优化，增加了一个指向相邻叶子节点的链表指针，提高了区间访问性能</p>
<p>总结：</p>
<p><img src="https://s2.loli.net/2023/02/24/JWDU6OykbZQji1u.png" alt="image-20230224215524002"></p>
<h2 id="3层千万数据的计算">3层千万数据的计算</h2>
<p><img src="https://s2.loli.net/2023/02/24/nA1kdmhj2Pu3fsv.png" alt="image-20230224215839309"></p>
<h2 id="Mysql数据库挂掉怎么备份和恢复">Mysql数据库挂掉怎么备份和恢复</h2>
<h2 id="Mysql-索引很慢，怎么排查，怎么处理">Mysql 索引很慢，怎么排查，怎么处理</h2>
<p>虽然命中索引，但SQL效率仍然慢，可能有哪些原因？</p>
<ol>
<li>索引字段重复值或者空值太多。</li>
<li>查询条件范围太广返回结果数太多，全索引扫描。</li>
<li>没有利用到覆盖索引，造成大量回表。</li>
<li>查询字段过多，并且包含大字段。</li>
<li>索引字段数据分布太随机，回表不多也会引起大量随机io。</li>
<li>统计信息不准。</li>
<li>表的单行数据值很大，需要较多io。</li>
<li>表中包含多个索引， 命中的索引不是最优的索引。</li>
</ol>
<h2 id="索引失效的场景">索引失效的场景</h2>
<p><img src="https://s2.loli.net/2023/02/26/a1SBGAW3rfKmeiw.png" alt="image-20230226101837093"></p>
<p>可能导致失效的原因：</p>
<ol>
<li><strong>对索引字段进行了运算或者使用了函数</strong></li>
<li><strong>查询中的数据类型和字段类型不一致（需要进行转换的时候）</strong></li>
<li><strong>违反了索引的最左匹配原则</strong></li>
<li><strong>数据量较少，全表扫描更快</strong></li>
</ol>
<h2 id="Mysql如何分库分表">Mysql如何分库分表</h2>
<p>shardingJDBC/Mycat</p>
<h2 id="Mysql的锁">Mysql的锁</h2>
<p>全局锁</p>
<p>表级锁：</p>
<ul>
<li>表锁
<ul>
<li>表共享读锁</li>
<li>表独占写锁</li>
</ul>
</li>
<li>元数据锁：MDL，加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性</strong></li>
<li>意向锁：为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，<strong>使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</strong>
<ul>
<li>意向共享锁（IS）：意向共享锁与表读锁是兼容的，由语句<strong>select … lock in share mode</strong>添加</li>
<li>意向排它锁（IX）：意向排他锁与表读锁、写锁都是互斥的，由<strong>insert、update、delete、select…for update</strong>添加</li>
</ul>
</li>
</ul>
<p>行锁：</p>
<ul>
<li>
<p>行锁：在RC，RR级别下支持</p>
<ul>
<li>
<p>S为共享锁</p>
<p>防止不可重复读，因为当事务对数据加上共享锁后，其他事务就只能对该数据进行读操作，不能进行修改操作，因此也就避免了不可重复读的问题（不可重复读：前后两次读取的结果不一样）</p>
</li>
<li>
<p>X为排他锁</p>
</li>
</ul>
</li>
<li>
<p>间隙锁：防止产生幻读的，在RR隔离级别下支持</p>
</li>
<li>
<p>临键锁：行锁和间隙锁组合，在RR级别下支持</p>
</li>
</ul>
<p>在RR隔离级别中，innodb使用<strong>next-key锁</strong>进行搜索和索引扫描，防止幻读，定位到索引区间后，降级为<strong>间隙锁</strong></p>
<h2 id="数据库的乐观锁和悲观锁">数据库的乐观锁和悲观锁</h2>
<p>**数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和一致性以及数据库的统一性。**乐观锁和悲观锁是并发控制主要采用的技术手段。</p>
<p>悲观锁：假定会发生并发冲突，会对操作的数据进行加锁，直到提交事务，才会释放锁，其他事务才能进行修改。实现方式：<strong>使用数据库中的锁机制。</strong></p>
<p>例如：当前读操作：<strong>它读取的记录都是数据库中当前的最新版本（要能读到所有已经提交的记录的最新值），会对当前读取的数据进行加锁，防止其他事务修改数据</strong></p>
<p>select … lock in share mode  当前读，加读锁 ，也叫共享锁<br>
select … for update 当前读，加写锁，又叫排他锁<br>
innoDB 里面 update (排他锁)、insert (排他锁)、delete (排他锁)，都会自动给涉及的语句添加写锁。<br>
串行化事务的隔离级别<br>
实现方式：next-key（行记录锁+间隙锁）即临键锁，是前开后闭区间。</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过。给表增加version字段，在修改提交之前检查version与原来取到的version值是否相等，若相等，表示没有其他事务对数据进行修改，可以更新，否则，数据为脏数据，不能更新。实现方式：乐观锁一般使用<strong>版本号机制或CAS算法</strong>实现。</p>
<p>例如：MVCC</p>
<h2 id="Mysql死锁如何解决">Mysql死锁如何解决</h2>
<p><strong>产生条件：</strong></p>
<ol>
<li>互斥条件：共享资源x,y只能被一个线程占有</li>
<li>请求和保持条件：线程t1已经获得了共享资源x，在等待共享资源y的时候不释放共享资源x</li>
<li>不可抢占条件：其余线程不能去抢占线程t1已经占有的资源</li>
<li>循环等待条件：线程t1等待线程t2释放资源，线程t2也等待线程t1释放资源</li>
</ol>
<p>**原因：**死锁的关键在于：两个(或以上)的Session加锁的顺序不一致</p>
<p><strong>解决关键：</strong>（让不同的session加锁有次序），上面的条件1为特征，无法破坏，其余三点都可以外部干预进行破坏</p>
<ul>
<li>解决条件2：第一次执行的时候一次性申请所有的共享资源</li>
<li>解决条件3：如果申请不到就主动释放它占有的资源</li>
<li>解决条件4：按照顺序申请锁资源，相当于给资源一个编号</li>
</ul>
<p>**如何找到：**可以调用jstack命令，导出线程的dump日志，然后定位到具体的死锁程序代码</p>
<p><strong>如何避免：</strong></p>
<ul>
<li>事务尽可能小，不要将复杂逻辑放进一个事务里。</li>
<li>涉及多行记录时，约定不同事务以相同顺序访问。</li>
<li>业务中要及时提交或者回滚事务，可减少死锁产生的概率。</li>
<li>表要有合适的索引。</li>
<li>可尝试将隔离级别改为 RC</li>
</ul>
<h2 id="如何优化锁">如何优化锁</h2>
<ol>
<li>
<p><strong>尽量使用较低的隔离级别。</strong></p>
</li>
<li>
<p>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</p>
</li>
<li>
<p><strong>选择合理的事务大小，小事务发生锁冲突的几率也更小。</strong></p>
</li>
<li>
<p>**给记录集显示加锁时，最好一次性请求足够级别的锁。**比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</p>
</li>
<li>
<p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</p>
</li>
<li>
<p><strong>除非必须，查询时不要显示加锁。</strong> MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；</p>
</li>
</ol>
<h2 id="写sql需要注意的点，SQL调优">写sql需要注意的点，SQL调优</h2>
<ol>
<li>尽量不要用select * ，尽量覆盖索引，在二级索引下就能查到想要的</li>
<li>尽量减少子查询，使用关联查询（left join,right join,inner join）替代</li>
<li>小表查询大表时尽量用in不要用exists</li>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>
<li>用limit限制返回的条数，避免内存溢出</li>
<li>缩小数据集的条件要放前面</li>
<li>update的时候如果不走索引，会把行级锁升级为表级锁，这样会大大降低并发性</li>
</ol>
<hr>
<ol>
<li>主键顺序导入：插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能，一般都让主键id自增</li>
<li>一个SQL不会操作两张表，在程序中作为参数的传递，永远单表查询</li>
<li>批量插入代替循环插入，使用batch批处理：orderMapper.insertBatch(list)</li>
<li>当pageNo比较大的时候，查询效率变低，所以可以用上次查询的最大id或者order by的那个字段的最大值或者最小值来做一个条件的过滤</li>
</ol>
<h2 id="百万级别的数据优化">百万级别的数据优化</h2>
<ol>
<li>
<p>最左前缀原则</p>
</li>
<li>
<p>不要对索引做以下处理</p>
<p>计算：+、-、*、/、！=、is null、is not null、or</p>
<p>函数：sum()、round()</p>
<p>手动/自动类型转换：id = “1”</p>
</li>
<li>
<p>索引不要放在范围查询右边，范围之后索引都失效</p>
</li>
<li>
<p>减少select * 的使用</p>
</li>
<li>
<p>like模糊搜索</p>
</li>
<li>
<p>order by优化：少用文件内排序，尽可能通过覆盖索引使其使用索引排序</p>
</li>
</ol>
<h2 id="嵌套查询和嵌套结果的区别">嵌套查询和嵌套结果的区别</h2>
<h2 id="慢查询">慢查询</h2>
<p><img src="https://s2.loli.net/2023/02/26/Nkl2bneTUWYH9m6.png" alt="image-20230226101225801"></p>
<h2 id="Mysql-limit">Mysql limit</h2>
<p>limit x,y的含义是：扫描x条，然后往后扫描截取y条</p>
<h2 id="事务的四大特性">事务的四大特性</h2>
<ol>
<li>
<p>原子性(A)：undo log实现</p>
</li>
<li>
<p>一致性©</p>
<p>事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。</p>
</li>
<li>
<p><strong>隔离性(I)：加锁以及MVCC实现</strong></p>
<p>在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</p>
</li>
<li>
<p><strong>持久性(D)：redo log实现</strong></p>
</li>
</ol>
<h2 id="日志">日志</h2>
<p>Redo-Log保证已提交事务的持久性，undo是用于消除未提交事务的影响</p>
<p><img src="https://s2.loli.net/2023/03/01/cqUmuotCl2OP8MR.png" alt="image-20230301094518509"></p>
<p>binLog是逻辑日志，RedoLog是物理日志</p>
<h2 id="MVCC（RC与RR）">MVCC（RC与RR）</h2>
<p>多版本并发控制（MVCC=Multi-Version Concurrency Control），是一种用来解决读 - 写冲突的无锁并发控制。**也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。**版本与事务时间戳关联，<strong>读操作只读该事务开始前的数据库的快照（复制了一份数据）</strong>。这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，<strong>避免了脏读和不可重复读</strong></p>
<p><strong>重点为：版本链+undo回滚日志+对比规则</strong></p>
<p>read view中四变量：</p>
<ul>
<li>活跃事务（活跃事务就是没提交的事务）集合；</li>
<li>当前事务id</li>
<li>集合中的最小值；</li>
<li>集合中最大值的下个值</li>
</ul>
<p>当执行查询sql时会生成一致性视图read-view</p>
<p>RC隔离级别下每次执行快照读时生成readview，所以第一次没提交读不到，第二次提交了，生成了新的快照读就读到了，故会出现不可重复读的问题</p>
<p>RR可重复读级别下所有的select都会使用同一个read-view</p>
<p><strong>即只读自己事务前已经commit的事务，加上自己事务未提交的事务，别人同时做的未提交操作，和后面commit事务就不读了</strong></p>
<p>m_ids表示还没有提交的事务的列表</p>
<p><img src="https://s2.loli.net/2023/03/14/notulHYyIpLFca2.png" alt="image-20230314100408986"></p>
<p><img src="https://s2.loli.net/2023/03/06/byeINEqtK6JxkLa.png" alt="image-20230306155955830"></p>
<p><img src="https://s2.loli.net/2023/03/14/gvHiQx1m5ujNOES.png" alt="image-20230314100438155"></p>
<p><strong>其他任何情况都要一直沿着版本链查询undo日志，直到符合这三个条件为止</strong></p>
<p>数组中是未提交事务，外面的是当前最大的事务id（包含已提交的）</p>
<p>快照读是MVCC负责的，当前读是通过锁</p>
<p>幻读通过加间隙锁解决幻读</p>
<p>注：</p>
<ol>
<li>
<p><strong>当前读就是显式加锁的 SQL 语句（lock in share mode 或 for update）</strong><br>
例如：select * from T where id=10 for update;<br>
此外 insert update 和 delete 这些隐式加锁的语句也是使用当前读。</p>
</li>
<li>
<p><strong>没有显示加锁的查询语句就是快照读了。</strong></p>
<p>例如：select * from T where id=10;</p>
</li>
</ol>
<h2 id="Redo-Log和Undo-Log的区别">Redo Log和Undo Log的区别</h2>
<ol>
<li>
<p>redo log是<strong>InnoDB引擎</strong>特有的；binlog是<strong>MySQL的Server层</strong>实现的，所有引擎都可以使用；</p>
</li>
<li>
<p>redo log是<strong>物理日志</strong>，记录的是“<strong>在某个数据页上做了什么修改</strong>”；binlog是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给ID=2这的c字段加1 ” ；</p>
</li>
<li>
<p>redo log是循环写的，空间固定会用完；binlog是可以追加写的。“追加写”是指binlog文件写到定大小后会切换到下个，并不会覆盖以前的日志 ；</p>
</li>
<li>
<p>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用；</p>
</li>
</ol>
<p>Redo Log：</p>
<p><strong>先写日志，再写磁盘</strong></p>
<p><strong>redo log 的大小是固定的，前面的内容会被覆盖，一旦写满，就会触发 redo log 到磁盘的同步，以便腾出空间记录后面的修改</strong></p>
<hr>
<p><strong>redo log 是先 prepare 状态，等 binlog 写完之后，才是 commit 状态，这种方式就叫”两阶段提交”。</strong></p>
<p><img src="https://s2.loli.net/2023/04/06/DeobKhPFQxMENzA.png" alt="image-20230406222916598"></p>
<h2 id="left-join-和-right-join-的区别">left join 和 right join 的区别</h2>
<p>左(外)连接</p>
<p>右(外)连接</p>
<h2 id="内连接和外连接的区别">内连接和外连接的区别</h2>
<p>内连接：只查询公共部分</p>
<p>外连接：不光公共部分，还有左或右的独立部分</p>
<h2 id="in-、where-和-exist-怎么用">in 、where 和 exist 怎么用</h2>
<p>原则：<strong>小表驱动大表的原则</strong></p>
<ol>
<li>
<p><strong>in</strong></p>
<p>如：select * from A where id in (select id from B)</p>
<p>in()中的查询只执行一次，<strong>它查询出B中的所有的id并缓存起来，然后检查A表中查询出的id在缓存中是否存在</strong>，如果存在则将A的查询数据加入到结果集中，直到遍历完A表中所有的结果集为止。当B表的数据较大时不适合使用in()查询，因为它会将B表中的数据全部遍历一次</p>
<p><strong>结论：IN()查询适合B表数据比A表数据小的情况，IN()查询是从缓存中取数据</strong></p>
</li>
<li>
<p><strong>exist</strong></p>
<p>如：select * from A where exists(select id from b <a target="_blank" rel="noopener" href="http://whereB.id">whereB.id</a> = <a target="_blank" rel="noopener" href="http://A.id">A.id</a>)</p>
<p>EXISTS()查询是将主查询的结果集,即<strong>外表查询的结果,放到子查询中做验证</strong>，根据验证结果是true或false来决定主查询数据结果是否得以保存</p>
<p>结论：<strong>当B表的数据比A表的数据大时适合使用EXISTS()查询，因为它不用遍历B操作，只执行一次查询就OK了</strong></p>
</li>
</ol>
<h2 id="buffer-pool的原理">buffer pool的原理</h2>
<p>Buffer pool是MySQL中的一个缓存区，用于存储磁盘上的表和索引数据。当MySQL需要读取磁盘上的数据时，它会首先查找buffer pool中是否已经有了这些数据，如果有，直接从buffer pool中读取，如果没有，则从磁盘中读取，并将数据存储到buffer pool中，以便后续访问。<strong>它可以显著提高MySQL的查询性能和吞吐量。</strong></p>
<p>参数：innodb_buffer_pool_size</p>
<h1>操作系统</h1>
<h2 id="Linux查看磁盘IO占用情况">Linux查看磁盘IO占用情况</h2>
<ol>
<li>
<p>top  监控整体服务器</p>
</li>
<li>
<p>pidstat 统计各个进程的磁盘IO，还可以监控cpu和内存</p>
</li>
<li>
<p>iotop 类似top命令，不过iotop是只监控io相关的进程</p>
</li>
<li>
<p>vmstat 监控io活跃的进程，还可以监控内存，cpu相关</p>
<p>vmstat 2 3表示每隔2秒输出一次，一共输出3次</p>
</li>
</ol>
<h2 id="查看java进程">查看java进程</h2>
<ol>
<li>
<p>ps -ef | grep java</p>
<p>停止进程：kill -9 java进程序号或者pkill - 9 java</p>
</li>
<li>
<p>jps -q：只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</p>
<p>jps -m：输出传递给main 方法的参数</p>
<p>jps -l：输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</p>
<p>jps -m：输出传递给JVM的参数</p>
</li>
</ol>
<h2 id="Linux查看端口占用情况">Linux查看端口占用情况</h2>
<p>用于显示tcp，udp的端口和进程等相关情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 8080或者netstat -tln | grep 8080</span><br></pre></td></tr></table></figure>
<h2 id="linux系统命令，看系统上有哪些连接">linux系统命令，看系统上有哪些连接</h2>
<p>查看网络状态：</p>
<p>netstat -antp</p>
<p>查看进程信息：</p>
<p>ps：ps命令用于报告当前系统的进程状态。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。可以搭配kill指令随时中断、删除不必要的程序</p>
<p>top：以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次</p>
<h2 id="Linux下查看某一个进程所占用的内存">Linux下查看某一个进程所占用的内存</h2>
<ol>
<li>首先可以通过ps命令找到进程id，比如：ps -ef|grep flink，可以看到flink task这个程序的进程id（假设为8678）</li>
<li>top -p 8678</li>
</ol>
<p>或者直接：ps -aux|grep flink</p>
<blockquote>
<p>a：显示当前终端下的所有进程信息，包括其他用户的进程。</p>
<p>u：使用以用户为主的格式输出进程信息。</p>
<p>x：显示当前用户在所有终端下的进程</p>
</blockquote>
<h2 id="怎样排查CPU占用情况">怎样排查CPU占用情况</h2>
<ol>
<li>**使用top命令：**这是一个Linux和Unix操作系统中的基本命令，可以实时监视系统中的进程和资源使用情况。在终端中输入“top”即可启动该命令，并可以按P键按CPU使用率进行排序。</li>
<li>**使用htop命令：**与top类似，但提供了更丰富的交互式界面和更多的功能，例如可以使用颜色标识不同进程的CPU使用情况。在终端中输入“htop”即可启动该命令。</li>
<li>**使用ps命令：**该命令可以列出当前系统中运行的所有进程。可以使用“ps aux”命令查看所有进程的详细信息，包括CPU和内存使用情况。</li>
<li>**使用pidstat命令：**该命令可以提供有关进程的实时CPU使用率和其他系统资源的详细信息。在终端中输入“pidstat -u”可以查看进程的CPU使用情况。</li>
<li>使用perf工具：该工具可以提供更详细的性能分析和调试信息，包括进程的CPU使用率和其他系统资源的详细信息。在终端中输入“perf stat -p [pid]”可以查看特定进程的CPU使用情况。</li>
</ol>
<h1>场景题</h1>
<h2 id="100M内存，10G大小的字符串文件，怎样筛选出频率出现次数前十次的字符串">100M内存，10G大小的字符串文件，怎样筛选出频率出现次数前十次的字符串</h2>
<ol>
<li>使用外部排序（External Sort）将文件分成多个小文件，每个小文件的大小不超过100M。外部排序算法允许在内存不足的情况下对大型文件进行排序。具体而言，它会将文件分成多个部分，然后在内存中对这些部分进行排序，最后将它们合并成一个有序的文件。</li>
<li>对于每个小文件，使用哈希表（Hash Table）来统计每个字符串出现的频率。</li>
<li>将所有小文件的哈希表合并成一个大的哈希表，同时保留每个字符串的频率信息。</li>
<li>遍历哈希表中的所有键值对，将它们存入一个最小堆中，同时保持堆的大小为 10。具体地，如果堆的大小小于 10，则直接将当前键值对插入堆中；否则，将当前键值对与堆顶的键值对进行比较，如果当前键值对的值大于堆顶的键值对的值，则将堆顶弹出，然后将当前键值对插入堆中。</li>
<li>最后，从堆中取出所有元素，按照出现次数从大到小的顺序输出字符串即可。</li>
</ol>
<h2 id="什么是轮询">什么是轮询</h2>
<p>轮询是一种常见的网络通信方式，它是指一个程序或者线程定期地检查一个或多个资源的状态，以便及时获取更新或者响应用户请求的一种方式。在轮询中，程序会反复地查询某些状态信息，直到获取到期望的结果为止。</p>
<p>在网络编程中，轮询通常用于客户端和服务器之间的通信，例如客户端轮询服务器的状态，以便获取最新的数据或者响应用户的请求。轮询可以基于时间间隔、事件触发、消息队列等方式实现。</p>
<p>轮询可以分为主动轮询和被动轮询。主动轮询是指客户端主动向服务器发送请求，查询服务器的状态，以获取最新的数据。被动轮询是指服务器定期地向客户端发送更新消息，以便客户端获取最新的数据。被动轮询通常使用长轮询技术实现，即客户端向服务器发送一个长期的请求，服务器在有更新时立即响应，客户端在接收到响应后再发送下一个请求。</p>
<p>轮询的优点是实现简单、易于理解和部署，缺点是资源浪费和响应时间较长。由于轮询需要不断地查询状态信息，因此会占用一定的带宽和系统资源。此外，如果状态更新不频繁或者网络延迟较大，轮询可能会导致响应时间较长，影响用户体验。为了解决这些问题，可以使用其他更高效的通信方式，例如长连接、推送通知等。</p>
<h2 id="服务器优化">服务器优化</h2>
<ol>
<li>负载均衡 在服务器端可以设置负载均衡，将客户端的请求分配到不同的服务器上，避免单一服务器负荷过大，导致登录响应时间变慢或者登录失败。可以使用一些负载均衡工具，例如Nginx、HAProxy等。</li>
<li>分布式架构 采用分布式架构，将用户数据、登录服务器等服务分布到不同的物理节点上，减轻单节点的负荷，提高系统的稳定性和可用性。</li>
<li>缓存 将常用的id缓存到内存中，避免频繁访问数据库，减少服务器的负担，提高id申请的可用性。</li>
<li>异步处理 对于客户端登录请求，可以采用异步处理方式，避免请求阻塞导致系统负载过大。可以使用一些异步处理工具，例如Celery等。</li>
<li>引入限流机制 为了避免大量的客户端同时登录，可以采用限流机制，对客户端的请求进行限制，例如限制每秒最多只能接收多少个请求。</li>
</ol>
<h2 id="怎样设计一个秒杀系统">怎样设计一个秒杀系统</h2>
<ol>
<li>
<p>高并发的瞬时流量问题</p>
<p>通过逐层流量过滤，限流等方式进行瞬时流量的削峰</p>
</li>
<li>
<p>热点数据问题</p>
<p>引入分布式缓存及本地缓存</p>
</li>
<li>
<p>数据量大的问题</p>
</li>
<li>
<p>库存的正确扣减问题（不能出现超买超卖）</p>
</li>
<li>
<p>避免黄牛抢购问题</p>
</li>
<li>
<p>用户重复下单问题</p>
<p>通过幂等控制</p>
</li>
<li>
<p>秒杀对于普通交易的影响</p>
</li>
</ol>
<h2 id="超卖问题">超卖问题</h2>
<p>加锁（JVM级别进程锁，所以不能跨线程）—&gt;分布式锁—&gt;jedis中的SETNX命令</p>
<p>初始思路：</p>
<p><img src="https://s2.loli.net/2023/04/03/z59sGBOA16pgynH.png" alt="image-20230403202531309"></p>
<p>问题：可能会出现宕机问题，或者死锁问题</p>
<p>改进：</p>
<p><img src="https://s2.loli.net/2023/04/03/CJdHswea5yKjG4L.png" alt="image-20230403203144378"></p>
<p>问题：可能会没加上锁，先加上然后别的请求释放了</p>
<p>改进：给锁加个ID</p>
<p><img src="https://s2.loli.net/2023/04/03/ruATFKqZ1cdbDXp.png" alt="image-20230403204540936"></p>
<p>再改进：redisson框架，在分布式场景下更好</p>
<img src="https://s2.loli.net/2023/04/03/QC3XIAL6iYstrvp.png" alt="image-20230403205056039" style="zoom:67%;" />
<p><img src="https://s2.loli.net/2023/04/03/8hJmAwrPpDVFyY6.png" alt="image-20230403205045697"></p>
<p>问题：可能会有主从节点切换时锁丢失问题，因为不管synchronized或者ReentrantLock都是只作用于自己机器的JVM中，对其他机器的JVM无效。相当于两台不同的机器使用的是不同的两把锁，导致锁失效。</p>
<p>改进：LUA脚本，原子性操作，或者使用分布式锁</p>
<p><img src="https://s2.loli.net/2023/04/07/BgEcU4AIsnxvfYR.png" alt="image-20230407104738180"></p>
<h2 id="怎样防止前端重复提交">怎样防止前端重复提交</h2>
<ol>
<li>
<p>客户端标识</p>
<p>客户端可以设置一个表示，表明这个请求已经提交了，并且在接下来的请求中判断该表示，如果为真 ，则不再处理这个请求</p>
</li>
<li>
<p>客户端存储</p>
<p>客户端也可以使用localStorage等客户端存储方式来记录表单是否已经提交，如果已经提交，则不再处理该请求。</p>
</li>
<li>
<p><strong>禁用提交按钮</strong></p>
<p>在表单提交后，禁用提交按钮，避免用户多次点击。</p>
</li>
<li>
<p><strong>使用定时器设置一段时间内禁用提交按钮</strong></p>
</li>
<li>
<p><strong>服务端利用token机制</strong></p>
<p>在表单渲染时，生成一个唯一的 Token 并隐藏在表单中；在表单提交时，服务器端验证 Token 的有效性，如果无效或已使用，则视为重复提交</p>
</li>
<li>
<p><strong>session</strong></p>
<p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p>
<p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p>
</li>
<li>
<p><strong>提交完成后页面重定向</strong></p>
</li>
<li>
<p><strong>使用AOP自定义切入实现</strong></p>
<p>实现原理：</p>
<ol>
<li>自定义防止重复提交标记（@AvoidRepeatableCommit）。</li>
<li>对需要防止重复提交的Congtroller里的mapping方法加上该注解。</li>
<li>新增Aspect切入点，为@AvoidRepeatableCommit加入切入点。</li>
<li>每次提交表单时，Aspect都会保存当前key到reids（须设置过期时间）。</li>
<li>重复提交时Aspect会判断当前redis是否有该key，若有则拦截。</li>
</ol>
</li>
</ol>
<h2 id="单点登录">单点登录</h2>
<p>指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的系统。简而言之，多个系统（模块），统一登陆。</p>
<p><img src="https://s2.loli.net/2023/04/09/HfWZzKgLw29l1bm.png" alt="image-20230409170204206"></p>
<p><strong>原理：</strong></p>
<p>sso需要一个独立的认证中心，所有子系统都通过认证中心的登录入口进行登录，登录时带上自己的地址，子系统只接受认证中心的授权，授权通过令牌（token）实现，sso认证中心验证用户的用户名密码正确，创建全局会话和token，token作为参数发送给各个子系统，子系统拿到token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p>
<p><strong>实现方式：</strong></p>
<p>Cookies，Session同步，分布式Session</p>
<p><strong>ChatGPT：</strong></p>
<blockquote>
<p>单点登录（Single Sign-On，SSO）是指用户只需要进行一次登录，就可以访问多个应用系统或者服务的一种认证机制。在Java应用程序中，可以通过以下方式来实现单点登录：</p>
<p>1.使用统一认证服务（CAS）：CAS是一种开源的单点登录解决方案，它可以集成到Java应用程序中，通过一个统一的认证中心来管理用户的登录状态。在CAS中，用户在第一次登录时，需要输入用户名和密码，认证成功后，CAS会为用户颁发一个令牌（Ticket），然后将令牌返回给客户端。当用户访问其他应用系统时，客户端会将令牌带上，然后向CAS验证令牌的有效性，如果令牌有效，则允许用户访问系统，否则提示用户重新登录。</p>
<p>2.使用集成认证协议：Java应用程序可以通过集成一些开放认证协议，如OAuth2和OpenID Connect等，来实现单点登录。这些协议都提供了统一认证流程和标准接口，可以实现多种应用系统的单点登录。</p>
<p>3.使用会话管理：Java Web应用程序可以使用会话管理技术来实现单点登录。具体来说，当用户进行登录操作时，可以将用户的登录信息保存到会话中，然后在其他应用系统中使用同一会话ID来识别用户的登录状态。这种方式的缺点是会话容易过期或被篡改，需要进行安全措施。</p>
<p>无论采用哪种方式，实现单点登录都需要考虑安全性问题，如令牌泄露、重放攻击、伪造令牌等，需要采取一些措施来防范这些风险。</p>
</blockquote>
<h2 id="处理重复请求">处理重复请求</h2>
<p><strong>问题：一个用户下单点外卖，此时进入了高铁隧道没信号了，于是多点了几下，如何处理这种重复的请求？</strong></p>
<p><strong>回答：</strong></p>
<p>处理重复请求的方式通常有两种：前端处理和后端处理。</p>
<p>前端处理可以在客户端实现，例如在用户多次点击下单按钮时，禁用该按钮并显示“正在下单，请稍等”等提示信息，避免用户重复提交请求。此方法相对简单，但依赖于客户端的实现，也不能完全避免用户在多个设备或多个浏览器窗口中进行操作的情况。</p>
<p>后端处理可以在服务端实现，例如对于重复请求进行去重或者设置幂等性。去重的方式可以使用缓存或者数据库进行存储，当收到一个请求时，先检查缓存或者数据库中是否已经存在相同的请求，如果已经存在，则不再处理该请求。设置幂等性可以<strong>为每个请求生成一个唯一标识符</strong>，在服务端处理请求时，检查该标识符是否已经被处理过，如果已经被处理过，则不再处理该请求。这种方法相对复杂，但可以有效地避免重复请求。</p>
<h2 id="超时订单处理">超时订单处理</h2>
<ol>
<li>
<p>延时队列</p>
<ul>
<li>把订单插入DelayQueue中，以超时时间作为排序条件，将订单按照超时时间从小到大排序。</li>
<li>起一个线程不停轮询队列的头部，如果订单的超时时间到了，就出队进行超时处理，并更新订单状态到数据库中。</li>
<li>为了防止机器重启导致内存中的DelayQueue数据丢失，每次机器启动的时候，需要从数据库中初始化未结束的订单，加入到DelayQueue中。</li>
</ul>
<p>缺点：占用内存，没法分布式处理，只能在集群中选一台leader处理，效率低，不适用订单量较大的场景</p>
</li>
<li>
<p>RabbitMQ延时消息</p>
</li>
<li>
<p>RocketMQ定时消息</p>
</li>
<li>
<p>Redis过期监听</p>
</li>
<li>
<p>阿里：分布式调度平台：SchedulerX</p>
</li>
</ol>
<h2 id="多人扫码点餐">多人扫码点餐</h2>
<p><strong>问题：多人来到店里点餐，多个人扫描同一个码，如何确保他们的操作的原子性？对谁进行加锁？</strong></p>
<p><strong>回答：</strong></p>
<p>对于多人来到店里点餐，多个人扫描同一个码的情况，我们可以采用<strong>分布式锁</strong>来确保它们的操作的原子性。分布式锁可以保证多个客户端之间的互斥，确保同一时间只有一个客户端可以执行相关操作。</p>
<p>常见的分布式锁的实现方式包括基于<strong>数据库、Redis、ZooKeeper</strong>等实现方式。</p>
<p><strong>Redis实现分布式锁示例：</strong></p>
<p>在Redis中，我们可以使用SET命令设置一个key，当该key不存在时设置成功，并返回成功标志；当该key已经存在时，设置失败，返回失败标志。因此，我们可以将一个唯一的key作为锁的标识，客户端在执行操作前先尝试获取该锁，获取成功后进行操作，操作完成后再释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String lockKey = <span class="string">&quot;order_lock_key&quot;</span>; <span class="comment">// 锁的标识</span></span><br><span class="line">    String lockValue = UUID.randomUUID().toString(); <span class="comment">// 锁的值</span></span><br><span class="line">    <span class="keyword">boolean</span> lock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁，等待时间为10秒</span></span><br><span class="line">        lock = redisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 执行操作</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，抛出异常或者重试</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">            redisTemplate.delete(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们首先生成一个唯一的锁的标识，然后尝试使用Redis的setIfAbsent命令获取锁。如果获取成功，说明当前客户端获得了锁，可以执行操作。如果获取失败，说明锁已经被其他客户端获取，当前客户端可以抛出异常或者进行重试等处理。在操作完成后，客户端需要释放锁。</p>
<p>需要注意的是，在使用分布式锁时，我们需要考虑锁的超时时间和锁的重入问题。为了避免锁的超时时间过短导致锁被释放，我们需要设置一个合适的锁的超时时间。为了避免锁的重入问题，我们需要在获取锁的时候设置一个唯一的锁的标识，并在释放锁的时候检查该标识是否与当前锁的值相等，只有相等才能释放锁。</p>
<hr>
<p><strong>数据库实现分布式锁示例：</strong></p>
<p>基于MySQL乐观锁方式来完成：</p>
<p>1.创建锁表：首先，在数据库中创建一个锁表，用于存储锁的信息，包括锁名称、锁状态、锁的持有者、锁的过期时间等字段。</p>
<p>2.获取锁：当需要获取锁时，应用程序通过执行SQL语句向锁表中插入一条记录，<strong>将程序的编号（insert）存入tb_program表</strong>，如果插入成功，表示获取锁成功，否则获取锁失败。（<strong>当program_nu相同的其他程序进行insert时，由于主键冲突会导致insert失败，则代表获取锁失败。</strong>）</p>
<p>3.释放锁：当锁的持有者需要释放锁时，应用程序通过执行SQL语句删除锁表中对应的记录，表示释放锁。</p>
<p>4.设置超时：为了防止死锁和长时间占用锁资源，应用程序在获取锁时可以设置一个超时时间，如果在指定的时间内没有成功获取锁，则认为获取锁失败。</p>
<p>5.保证原子性：在多个应用程序之间同时获取锁时，需要使用事务来保证操作的原子性，即在获取锁和释放锁的过程中，需要保证所有相关的操作都在同一个事务中进行，以确保数据的一致性。</p>
<p>需要注意的是，通过数据库实现分布式锁会增加数据库的负担，因此应该合理控制锁的数量和持有时间，避免对数据库性能造成影响。此外，在高并发场景下，需要考虑优化数据库的性能，如采用分库分表、读写分离等方式。</p>
<h2 id="如果客户端与服务端的连接出现故障，怎么排查">如果客户端与服务端的连接出现故障，怎么排查</h2>
<ol>
<li>**确认故障：**首先，需要确认是否存在连接故障。您可以尝试在不同的网络环境下尝试连接，或者使用其他设备进行连接。如果这些尝试都失败了，那么很可能是存在连接故障。</li>
<li>**检查网络连接：**确保客户端和服务端都有可用的网络连接。可以使用 ping 命令测试网络连接是否正常。如果网络连接存在问题，则需要检查网络设备、防火墙或代理服务器等方面是否存在故障。</li>
<li>**检查服务端状态：**检查服务端是否在运行状态，是否有足够的资源（例如 CPU、内存等），是否有运行时错误等。您可以查看服务端的日志来了解更多信息。</li>
<li>**检查客户端配置：**确保客户端的配置正确。例如，检查客户端是否设置了正确的端口、协议等。</li>
<li>**检查防火墙设置：**防火墙可能会阻止客户端和服务端之间的连接。您需要确保防火墙已经正确配置，允许客户端和服务端之间的通信。</li>
<li>**检查应用程序代码：**如果客户端和服务端是自己开发的应用程序，则需要检查代码是否存在错误，是否有必要的错误处理等。</li>
</ol>
<h2 id="怎样维护客户端连接服务端">怎样维护客户端连接服务端</h2>
<ol>
<li>**健康检查：**对于服务端的多个节点，可以定期进行健康检查，以便及时发现不可用的节点。可以使用各种工具或方法，如ping、端口检查、心跳检测、负载均衡等，来检查服务节点的健康状况。</li>
<li>**自动切换：**当发现某个服务节点出现故障时，客户端应该自动将请求切换到其他可用的节点。可以使用一些自动化的负载均衡机制，如DNS轮询、IP Hash、随机等方法，来实现请求的自动切换。</li>
<li>**重试机制：**当客户端请求失败时，可以考虑使用重试机制，让客户端自动重新发起请求，以提高请求的成功率。需要注意的是，在进行重试时，应该避免重复请求，以及避免对服务端造成过大的负载。</li>
<li>**日志记录：**为了方便问题排查和系统优化，客户端需要记录相关的连接和请求信息，如请求发起时间、请求响应时间、请求状态等信息。这些信息可以通过日志记录或其他方式进行收集和存储。</li>
<li>**监控系统：**通过实时监控客户端与服务端的连接和请求情况，可以及时发现连接和请求的异常情况，从而快速定位问题和解决问题。可以使用各种监控工具和系统，如Prometheus、Grafana等，来实现监控和告警功能。</li>
</ol>
<p>总之，针对客户端连接多个服务端节点的情况，需要设计和实现一些高可用、自动化、智能化的机制和工具，以提高系统的稳定性和可靠性。</p>
<h2 id="有很多服务来调用服务器，怎么去保证服务稳定性">有很多服务来调用服务器，怎么去保证服务稳定性</h2>
<ol>
<li><strong>高可用性设计：<strong>采用</strong>集群、负载均衡、容错</strong>等技术手段，保证系统的可用性。例如，使用多台服务器来部署服务，并通过负载均衡将请求分发到不同的服务器上，从而避免单点故障导致整个系统不可用；限流降级（<strong>算法：令牌桶，漏桶</strong>）</li>
<li>**异常处理机制：**在系统中设置异常处理机制，及时捕捉系统中的错误，并对错误进行处理和记录，以便及时发现和解决问题。</li>
<li><strong>监控和日志记录：<strong>建立全面的监控和日志记录系统，对系统的各项指标进行监控，包括</strong>系统负载、网络带宽、服务响应时间、错误率</strong>等等。及时收集和分析这些数据，发现系统存在的问题，预测可能会出现的故障，及时采取措施解决问题。</li>
<li><strong>自动化测试：<strong>在服务部署前进行自动化测试，包括</strong>单元测试、集成测试、系统测试</strong>等等，确保服务的稳定性和可靠性，减少潜在的问题。</li>
<li>**安全性保障：**建立完善的安全保障机制，防止恶意攻击和非法访问，包括数据加密、访问控制、审计跟踪等等。</li>
</ol>
<h2 id="监控系统哪些方面">监控系统哪些方面</h2>
<ol>
<li>
<p><strong>网站故障监控：</strong></p>
<p>如果你所运行的项目出现了故障服务器要自动以短信或者邮件提醒的方式通知你，如果没有这个监控，或许等你发现时损失已经很大。</p>
</li>
<li>
<p><strong>服务器性能监控：</strong></p>
<p>其实就对服务器（计算机）CPU、内存、硬盘、负载等硬件使用多少的一个监控，如果出现了服务器硬件使用消耗过大那么就要考虑是否升级服务器配置了。</p>
</li>
<li>
<p><strong>网站安全监控：</strong></p>
<p>如果网站遭到黑客的攻击这时服务器如果有这项监控那么就会立刻通知你，这时采取相应的措施反攻击，以免自己的网站受到攻击。网站安全可以说是非常重要的，一旦黑客攻击进来你的网站数据丢失，损失就很大了。</p>
</li>
<li>
<p><strong>用户访问速度监控：</strong></p>
<p>监控所有访问本服务器的用户的访问速度。</p>
</li>
<li>
<p><strong>备份数据监控：</strong></p>
<p>查看网站的备份是否成功，哪些网站备份过、哪些没有。网站备份可以让你的数据有个保存，出现了突发问题可以立马恢复到上一个版本。所以说网站的备份大家也要注重。</p>
</li>
<li>
<p><strong>端口监控：</strong></p>
<p>服务器中端口检测也尤为重要，监控服务器开启了哪些端口哪些端口被占用，如果某些端口被一些不知名的IP或者程序占用那么就要考虑是不是服务器中了病毒，被黑客所利用。</p>
</li>
</ol>
<h1>面经</h1>
<h2 id="IO密集型任务把IO和业务逻辑分离有什么好处">IO密集型任务把IO和业务逻辑分离有什么好处</h2>
<ol>
<li>提高应用程序的响应速度：将IO和业务逻辑分离可以让应用程序更加高效地利用计算资源，以便更快地响应请求。当IO和业务逻辑被分离开来，可以使用异步编程技术来使应用程序更好地利用CPU和其他资源。这有助于提高应用程序的吞吐量和响应速度。</li>
<li>更好的可维护性：将IO和业务逻辑分离可以使代码更加模块化，易于维护和扩展。将IO操作和业务逻辑分开意味着可以在需要时更容易更改或替换IO操作，而不影响业务逻辑。这有助于确保代码的可重用性和可维护性。</li>
<li>更好的测试性：将IO和业务逻辑分离可以使单元测试更加容易。通过将IO操作模拟为模拟实现，可以在没有访问实际IO设备的情况下对业务逻辑进行测试。这有助于确保代码的正确性和可靠性。</li>
<li>更好的可伸缩性：将IO和业务逻辑分离可以使应用程序更容易扩展。当IO和业务逻辑分离时，可以更容易地将业务逻辑分布到多个服务器上，而不会影响IO性能。这有助于确保应用程序在面对不断增长的流量和负载时能够保持稳定性和可靠性。</li>
</ol>
<h1>做题</h1>
<h2 id="双线程输出">双线程输出</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doubleThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前线程必须拥有此对象的锁，才能调用某个对象的wait()方法能让当前线程阻塞，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadRunner(),<span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadRunner(),<span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//拿到锁，我们就打印,一旦打印完唤醒其他线程就休眠</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">ThreadRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+ count++);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    <span class="keyword">if</span>(count&lt;=<span class="number">100</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//如果任务没结束，唤醒其他线程，自己休眠</span></span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>笔试记录</h1>
<h2 id="阿里">阿里</h2>
<h3 id="满二叉子树的数量">满二叉子树的数量</h3>
<p>给定一颗二叉树，试求这课二叉树有多少个节点满足以该节点为根的子树是满二叉树？满二叉树指每一层都达到节点最大值。</p>
<p>第一行输入n表示节点数量，接下来n行第一个代表左儿子，第二个代表右儿子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            nums[i][<span class="number">0</span>] = in.nextInt();</span><br><span class="line">            nums[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Main().isFullTree(nums, <span class="number">1</span>)；</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(nums, nums[root - <span class="number">1</span>][<span class="number">0</span>]), height(nums, nums[root - <span class="number">1</span>][<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFullTree</span><span class="params">(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFullTree(nums, nums[root - <span class="number">1</span>][<span class="number">0</span>]) &amp;&amp; isFullTree(nums, nums[root - <span class="number">1</span>][<span class="number">1</span>]) &amp;&amp; height(nums, nums[root - <span class="number">1</span>][<span class="number">0</span>]) == height(nums, nums[root - <span class="number">1</span>][<span class="number">1</span>])) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述解法时间复杂度O(n)，空间复杂度o(log(n))</p>
<p>法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span> <span class="params">(TreeNode left, TreeNode right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    nodeList.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        nodeList.add(<span class="keyword">new</span> TreeNode(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i][<span class="number">0</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).left = nodeList.get(nums[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i][<span class="number">1</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).right = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).right = nodeList.get(nums[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三元组计数">三元组计数</h3>
<p>给定一个数组，计算有多少个三元组0&lt;=i&lt;j&lt;k&lt;n，且max(nums[i], nums[j], nums[k]) - min(nums[i], nums[j], nums[k]) = 1。</p>
<p>第一行输入n表示数组个数，第二行输入n个整数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = map.get(nums[i]);</span><br><span class="line">            <span class="keyword">int</span> high = map.get(nums[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (low == <span class="number">1</span> &amp;&amp; high == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (high &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += low * high * (high - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += high * low * (low - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乘2除2">乘2除2</h3>
<p>在n个元素的数组中选择k个元素，每个元素要么乘以2，要么除以2并向下取整，使得操作完后数组的极差尽可能小，并且输出极差。极差为最大值减去最小值。</p>
<p>第一行输入整数n和k。第二行输入n个整数表示数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queueMin = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queueMid = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queueMax = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">    <span class="keyword">int</span> minMin = Integer.MAX_VALUE, midMin = Integer.MAX_VALUE, maxMin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k ; i ++) &#123;</span><br><span class="line">        minMin = Math.min(minMin, <span class="number">2</span> * nums[i]);</span><br><span class="line">        queueMin.add(<span class="number">2</span> * nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i ++) &#123;</span><br><span class="line">        midMin = Math.min(midMin, nums[i]);</span><br><span class="line">        queueMid.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        res = Math.min(res, queueMid.peek() - midMin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = Math.min(res, Math.max(queueMin.peek(), queueMid.peek()) - Math.min(minMin, midMin));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempMin = queueMin.poll();</span><br><span class="line">        queueMid.add(tempMin / <span class="number">2</span>);</span><br><span class="line">        midMin = Math.min(midMin, tempMin / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> tempMid = queueMid.poll();</span><br><span class="line">        queueMax.add(tempMid / <span class="number">2</span>);</span><br><span class="line">        maxMin = Math.min(maxMin, tempMid / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == k - <span class="number">1</span>) &#123;</span><br><span class="line">            res = Math.min(res, Math.max(queueMid.peek(), queueMax.peek()) - Math.min(Math.min(minMin, midMin), maxMin));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = Math.min(res, Math.max(Math.max(queueMin.peek(), queueMid.peek()), queueMax.peek()) - Math.min(Math.min(minMin, midMin), maxMin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述解法时间复杂度O(nlog(n))，空间复杂度O(n)</p>
<h2 id="蚂蚁">蚂蚁</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextLine().charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        String[] str = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            str[i] = input.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        System.out.print(digui(str, alpha, n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">digui</span><span class="params">(String[] str, <span class="keyword">int</span> layer, <span class="keyword">int</span>[] alpha, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (layer == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] alpha_tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        String s = str[layer];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> ((alpha_tmp[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &amp;&amp; alpha[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                alpha[c - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                ans += digui(str, layer + <span class="number">1</span>, alpha, n);</span><br><span class="line">                alpha[c- <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            alpha_tmp[c - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">杨译茗</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://boomboom-yang.github.io/2023/04/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">https://boomboom-yang.github.io/2023/04/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://boomboom-yang.github.io" target="_blank">YYM‘s Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">面试整理</a></div><div class="post_share"><div class="social-share" data-image="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/05/22/RjklgVawrtOcuPf.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/05/22/RjklgVawrtOcuPf.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.loli.net/2021/05/22/qKAvWJgRe3IQVp5.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/05/22/qKAvWJgRe3IQVp5.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/03/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"><img class="prev-cover" src="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4375.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java力扣刷题记录</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/05/22/2KPMBkSoU3ahebr.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">杨译茗</div><div class="author-info__description">心栖梦归处，不负韶华年</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/boomboom-yang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/boomboom-yang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2476165779@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">致敬那些奋斗的岁月！永无止境！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">jdk1.8新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">8大基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">1.5.</span> <span class="toc-text">装箱与拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E7%BC%93%E5%AD%98%E6%98%AF%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%E7%9A%84"><span class="toc-number">1.6.</span> <span class="toc-text">Integer缓存是放在哪里的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">1.7.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.8.</span> <span class="toc-text">String的不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">1.8.2.</span> <span class="toc-text">好处：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">创建对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.10.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.10.2.</span> <span class="toc-text">获取class对象的方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">反射的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%EF%BC%9A"><span class="toc-number">1.10.4.</span> <span class="toc-text">反射获取：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.10.5.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.10.6.</span> <span class="toc-text">JAVA反射机制的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%92%8Cnew%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">反射和new对象的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">静态代理和动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="toc-number">1.12.1.</span> <span class="toc-text">静态代理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.12.2.</span> <span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">1.13.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.14.</span> <span class="toc-text">浅拷贝和深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.14.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.14.2.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.14.3.</span> <span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode"><span class="toc-number">1.15.</span> <span class="toc-text">两个不相等的对象有相同的hashcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals() 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95"><span class="toc-number">1.17.</span> <span class="toc-text">为什么重写 equals() 时必须重写 hashCode() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.18.</span> <span class="toc-text">集合框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.19.</span> <span class="toc-text">集合框架的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.</span> <span class="toc-text">ArrayList和数组的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E4%B8%8ELinkedList%E7%9A%84%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text">ArrayList与LinkedList的两者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.22.</span> <span class="toc-text">ArrayList初始容量以及扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.23.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84put%E6%96%B9%E6%B3%95"><span class="toc-number">1.24.</span> <span class="toc-text">HashMap的put方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.</span> <span class="toc-text">HashMap会出现的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk1-7HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="toc-number">1.26.</span> <span class="toc-text">jdk1.7HashMap为什么用头插法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8F%B3%E7%A7%BB16%E4%BD%8D"><span class="toc-number">1.27.</span> <span class="toc-text">为什么要右移16位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.28.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashcode-%E6%96%B9%E6%B3%95"><span class="toc-number">1.29.</span> <span class="toc-text">为什么重写equals()就一定要重写hashcode()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Hashmap%E6%98%AF%E6%89%A9%E5%B1%95%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B6%E4%BB%96"><span class="toc-number">1.30.</span> <span class="toc-text">为什么Hashmap是扩展为红黑树而不是其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.31.</span> <span class="toc-text">红黑树和B+树的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%8F%AF%E4%BB%A5%E9%94%AE%E5%80%BC%E5%AF%B9%E5%90%8C%E6%97%B6%E4%B8%BAnull%E5%90%97"><span class="toc-number">1.32.</span> <span class="toc-text">HashMap可以键值对同时为null吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.33.</span> <span class="toc-text">生产者和消费者模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CTomcat"><span class="toc-number">2.1.</span> <span class="toc-text">Web服务器和Tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BD%BF%E7%94%A8SpringBoot%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-number">2.2.</span> <span class="toc-text">讲讲使用SpringBoot的理由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%92%8CSpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">Spring和SpringBoot的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.4.</span> <span class="toc-text">讲讲对Spring的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-number">2.4.1.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">2.4.2.</span> <span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AutoWired%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text">@AutoWired自动装配的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">SpringBoot自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.7.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9spring-IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.8.</span> <span class="toc-text">讲讲对spring IOC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9Spring-AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.9.</span> <span class="toc-text">讲讲对Spring AOP的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9Spring-DI%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.10.</span> <span class="toc-text">讲讲对Spring DI的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E5%AF%B9Spring-MVC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.11.</span> <span class="toc-text">说下对Spring MVC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%87%86%E5%A4%87"><span class="toc-number">2.12.</span> <span class="toc-text">初始准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC"><span class="toc-number">2.12.1.</span> <span class="toc-text">JDBC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis"><span class="toc-number">2.12.2.</span> <span class="toc-text">MyBatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatisPlus"><span class="toc-number">2.12.3.</span> <span class="toc-text">MyBatisPlus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring"><span class="toc-number">2.12.4.</span> <span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot"><span class="toc-number">2.12.5.</span> <span class="toc-text">SpringBoot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSM%E5%8E%9F%E5%A7%8B%E6%95%B4%E5%90%88"><span class="toc-number">2.12.6.</span> <span class="toc-text">SSM原始整合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88MyBatis"><span class="toc-number">2.12.7.</span> <span class="toc-text">SpringBoot整合MyBatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88MyBatisPlus"><span class="toc-number">2.12.8.</span> <span class="toc-text">SpringBoot整合MyBatisPlus</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88DAO%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.13.</span> <span class="toc-text">为什么DAO层不需要实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.14.</span> <span class="toc-text">AOP术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.15.</span> <span class="toc-text">AOP的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%B8%AD-ApplicationContext-%E5%92%8C-BeanFactory-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text">Spring 中 ApplicationContext 和 BeanFactory 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.17.</span> <span class="toc-text">BeanFactory和FactoryBean的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.18.</span> <span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.19.</span> <span class="toc-text">单例模式举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.19.1.</span> <span class="toc-text">懒汉式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.19.2.</span> <span class="toc-text">饿汉式：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8BBean%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.20.</span> <span class="toc-text">单例Bean的创建步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IOC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.21.</span> <span class="toc-text">Spring IOC的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.21.1.</span> <span class="toc-text">注入 Bean 的注解有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.22.</span> <span class="toc-text">@Autowired和@Resource的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.23.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.24.</span> <span class="toc-text">Spring中Bean的作用域有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.25.</span> <span class="toc-text">循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">2.25.1.</span> <span class="toc-text">三级缓存解决不了的场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%BF%87%E7%A8%8B"><span class="toc-number">2.26.</span> <span class="toc-text">循环依赖过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABean%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.27.</span> <span class="toc-text">创建Bean实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.28.</span> <span class="toc-text">懒汉模式和饿汉模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.29.</span> <span class="toc-text">Spring中实现数据库事务的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.30.</span> <span class="toc-text">@Transactional具体实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E9%A9%ACSpring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.31.</span> <span class="toc-text">黑马Spring事务实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">2.32.</span> <span class="toc-text">spring事务的失效场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">2.33.</span> <span class="toc-text">事务失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB"><span class="toc-number">2.34.</span> <span class="toc-text">事务的传播级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.35.</span> <span class="toc-text">“#{}”和“${}”的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DI%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.36.</span> <span class="toc-text">DI的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Setter%E6%B3%A8%E5%85%A5"><span class="toc-number">2.36.1.</span> <span class="toc-text">Setter注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.36.1.1.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B1%9E%E6%80%A7"><span class="toc-number">2.36.1.2.</span> <span class="toc-text">简单属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">2.36.2.</span> <span class="toc-text">构造器注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">2.36.2.1.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B1%9E%E6%80%A7-2"><span class="toc-number">2.36.2.2.</span> <span class="toc-text">简单属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">2.36.3.</span> <span class="toc-text">自动配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">2.37.</span> <span class="toc-text">纯注解开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.38.</span> <span class="toc-text">将一个类声明为 Bean 的注解有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component%E5%92%8C-Bean%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.39.</span> <span class="toc-text">@Component和@Bean注解的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ComponentScan"><span class="toc-number">2.40.</span> <span class="toc-text">@ComponentScan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Import"><span class="toc-number">2.41.</span> <span class="toc-text">@Import</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.42.</span> <span class="toc-text">SpringBoot注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBootConfiguration-%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.42.1.</span> <span class="toc-text">@SpringBootConfiguration 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ComponentScan-%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.42.2.</span> <span class="toc-text">@ComponentScan 注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E5%92%8CJDBC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.43.</span> <span class="toc-text">Mybatis和JDBC的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.44.</span> <span class="toc-text">JDBC操作数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%A6%81%E5%81%9A%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">2.45.</span> <span class="toc-text">MyBatis新建一个查询要做那些事情？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.46.</span> <span class="toc-text">工厂模式举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log4j%E7%9A%844%E4%B8%AA%E7%BA%A7%E5%88%AB"><span class="toc-number">2.47.</span> <span class="toc-text">Log4j的4个级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E5%92%8CServlet%E5%AE%B9%E5%99%A8"><span class="toc-number">2.48.</span> <span class="toc-text">Tomcat和Servlet容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">为什么要在虚拟机中运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">同步和异步的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">并发和并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">JMM内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.</span> <span class="toc-text">JAVA内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.</span> <span class="toc-text">OOM问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E5%AF%BC%E8%87%B4"><span class="toc-number">3.7.</span> <span class="toc-text">JVM内存溢出有哪些场景会导致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%8D%A2%E6%88%90%E4%BA%86%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">3.8.</span> <span class="toc-text">JVM为什么把永久代换成了元空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%94%BE%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A0%86%E6%94%BE%E4%BB%80%E4%B9%88%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%94%BE%E5%93%AA%EF%BC%8C%E6%A0%88%E6%94%BE%E4%BB%80%E4%B9%88"><span class="toc-number">3.9.</span> <span class="toc-text">方法区放的什么，堆放什么，静态变量放哪，栈放什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.10.</span> <span class="toc-text">常量池&amp;运行时常量池&amp;字符串常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.10.1.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.10.2.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-number">3.10.3.</span> <span class="toc-text">符号引用和直接引用举例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.10.4.</span> <span class="toc-text">字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="toc-number">3.11.</span> <span class="toc-text">JVM中类的加载过程（类的生命周期）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">3.12.</span> <span class="toc-text">对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.12.1.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">3.12.2.</span> <span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">3.13.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-2"><span class="toc-number">3.14.</span> <span class="toc-text">对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="toc-number">3.14.1.</span> <span class="toc-text">Step1:类加载检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">3.14.2.</span> <span class="toc-text">Step2:分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="toc-number">3.14.3.</span> <span class="toc-text">Step3:初始化零值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">3.14.4.</span> <span class="toc-text">Step4:设置对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step5-%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95"><span class="toc-number">3.14.5.</span> <span class="toc-text">Step5:执行 init 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%9C%BA%E6%99%AF"><span class="toc-number">3.15.</span> <span class="toc-text">内存泄露场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">进程和线程区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.17.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.18.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.19.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%9A%E5%8C%85%E5%90%AB%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.20.</span> <span class="toc-text">进程最多包含多少个线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.21.</span> <span class="toc-text">线程的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.22.</span> <span class="toc-text">进程的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.23.</span> <span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.24.</span> <span class="toc-text">线程代码举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.25.</span> <span class="toc-text">使线程阻塞的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.26.</span> <span class="toc-text">创建线程的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">3.27.</span> <span class="toc-text">如何监控java线程池的利用率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.28.</span> <span class="toc-text">多线程的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.29.</span> <span class="toc-text">如何中断一个正在运行中的线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.30.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">3.31.</span> <span class="toc-text">线程池有哪些参数，分别的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.32.</span> <span class="toc-text">创建线程池的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.33.</span> <span class="toc-text">线程池的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E9%87%8D%E5%86%99java%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.34.</span> <span class="toc-text">怎样重写java线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">3.35.</span> <span class="toc-text">线程池的拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">3.36.</span> <span class="toc-text">线程池线程的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.37.</span> <span class="toc-text">阻塞队列有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.38.</span> <span class="toc-text">ArrayBlockingQueue的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">3.39.</span> <span class="toc-text">介绍强引用、软引用、弱引用、虚引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.40.</span> <span class="toc-text">虚引用的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="toc-number">3.41.</span> <span class="toc-text">如何判断一个常量是废弃常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">3.42.</span> <span class="toc-text">如何判断一个类是无用的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-number">3.43.</span> <span class="toc-text">HotSpot 为什么要分为新生代和老年代？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1%EF%BC%88%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">3.44.</span> <span class="toc-text">如何判断对象是否死亡（两种方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.44.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.44.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-GC-Roots"><span class="toc-number">3.45.</span> <span class="toc-text">哪些对象可以作为 GC Roots</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">3.46.</span> <span class="toc-text">垃圾收集有哪些算法，各自的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.47.</span> <span class="toc-text">常见的垃圾回收器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.48.</span> <span class="toc-text">HotSpot默认的垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.49.</span> <span class="toc-text">CMS垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-Garbage-First"><span class="toc-number">3.50.</span> <span class="toc-text">G1垃圾回收器(Garbage-First)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">3.50.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.50.2.</span> <span class="toc-text">回收过程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%87%8F%E5%B0%91Full-GC%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">3.51.</span> <span class="toc-text">怎样减少Full GC的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-GC-%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF"><span class="toc-number">3.52.</span> <span class="toc-text">常见的 GC 调优思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">3.53.</span> <span class="toc-text">JVM调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%8E%E6%A0%B7%E6%8E%92%E6%9F%A5"><span class="toc-number">3.54.</span> <span class="toc-text">出现内存泄漏怎样排查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">4.1.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">4.2.</span> <span class="toc-text">ThreadLocal是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">4.3.</span> <span class="toc-text">ThreadLocal带来的问题及解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">4.4.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E4%B8%AD%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.</span> <span class="toc-text">JAVA中锁机制以及使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountdownLatch%E5%92%8CSemaphore%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.</span> <span class="toc-text">CountdownLatch和Semaphore的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E6%BA%90%E7%A0%81"><span class="toc-number">4.7.</span> <span class="toc-text">ReentrantLock源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9A"><span class="toc-number">4.7.1.</span> <span class="toc-text">非公平锁：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.7.2.</span> <span class="toc-text">公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%92%8Clock%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.</span> <span class="toc-text">synchronized和lock锁的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%92%8C-Reentrantlock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">synchronized 和 Reentrantlock的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E7%82%B9%EF%BC%9A"><span class="toc-number">4.9.1.</span> <span class="toc-text">相似点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">4.9.2.</span> <span class="toc-text">区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E7%89%88%E6%9C%AC2"><span class="toc-number">4.9.3.</span> <span class="toc-text">区别版本2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E7%89%88%E6%9C%AC3"><span class="toc-number">4.9.4.</span> <span class="toc-text">区别版本3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E5%92%8CSynchronized%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.10.</span> <span class="toc-text">ReentrantLock和Synchronized的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">4.10.1.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">4.10.2.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.10.3.</span> <span class="toc-text">Monitor对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.11.</span> <span class="toc-text">synchronized锁升级的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">4.11.1.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">4.11.2.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.11.3.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.11.4.</span> <span class="toc-text">自适应自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">4.11.5.</span> <span class="toc-text">重量级锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.12.</span> <span class="toc-text">synchronized实现可见性的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-%E9%94%81%E5%8F%AF%E9%99%90%E6%97%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">4.13.</span> <span class="toc-text">ReentrantLock 锁可限时功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%8A%A0%E5%9C%A8%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.14.</span> <span class="toc-text">synchronized加在普通方法和静态方法有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.15.</span> <span class="toc-text">ReentrantLock的公平锁和非公平锁优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">4.16.</span> <span class="toc-text">volatile关键字是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB-2"><span class="toc-number">4.17.</span> <span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">4.18.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">4.18.1.</span> <span class="toc-text">CAS可能的问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.19.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.19.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.19.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">常用状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">5.2.</span> <span class="toc-text">常见的请求头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">四层网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-2-3%E7%BC%BA%E9%99%B7"><span class="toc-number">5.5.</span> <span class="toc-text">HTTP1&#x2F;2&#x2F;3缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%BA%E9%99%B7"><span class="toc-number">5.5.1.</span> <span class="toc-text">HTTP缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1%E7%BC%BA%E9%99%B7"><span class="toc-number">5.5.2.</span> <span class="toc-text">HTTP1.1缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2%E7%BC%BA%E9%99%B7"><span class="toc-number">5.5.3.</span> <span class="toc-text">HTTP&#x2F;2缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">5.6.</span> <span class="toc-text">HTTP的队头阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BB%86%E6%89%A3%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">HTTP与HTTPS的区别（细扣）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.8.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%80%8E%E6%A0%B7%E7%A1%AE%E8%AE%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.9.</span> <span class="toc-text">TCP怎样确认数据的完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-number">5.10.</span> <span class="toc-text">https加密过程（详细）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">5.11.</span> <span class="toc-text">ping的发送和接收过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CTCP%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E4%BD%86%E6%98%AFping%E5%8F%AF%E4%BB%A5ping%E9%80%9A%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98"><span class="toc-number">5.12.</span> <span class="toc-text">如果TCP连接不成功，但是ping可以ping通，如何排查网络问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">5.13.</span> <span class="toc-text">浏览器输入一个url的处理过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.14.</span> <span class="toc-text">DNS解析的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">5.15.</span> <span class="toc-text">三次握手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">5.16.</span> <span class="toc-text">四次挥手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97"><span class="toc-number">5.17.</span> <span class="toc-text">TCP 三次握手，两次、四次不行吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIME-WAIT-%E7%8A%B6%E6%80%81%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">5.18.</span> <span class="toc-text">TIME_WAIT 状态是做什么用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2MSL"><span class="toc-number">5.19.</span> <span class="toc-text">为什么是2MSL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">5.20.</span> <span class="toc-text">拥塞控制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84"><span class="toc-number">5.21.</span> <span class="toc-text">TCP是如何保证高可靠的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping-%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.22.</span> <span class="toc-text">ping 基于什么协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.23.</span> <span class="toc-text">网络层和传输层有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">5.24.</span> <span class="toc-text">ARP协议？工作机制介绍一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.25.</span> <span class="toc-text">session和cookie的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%81%E7%94%A8Cookie%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81Session%E5%90%8C%E6%AD%A5"><span class="toc-number">5.26.</span> <span class="toc-text">如果客户端禁用Cookie，怎么保持Session同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.1.</span> <span class="toc-text">Mysql存储引擎有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84"><span class="toc-number">6.4.</span> <span class="toc-text">索引如何生成的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">6.5.</span> <span class="toc-text">索引的优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">6.6.</span> <span class="toc-text">创建索引需要注意的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">6.7.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">6.8.</span> <span class="toc-text">最左匹配原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">6.9.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%9C%A8%E6%9B%B4%E6%96%B0-%E6%8F%92%E5%85%A5%E5%90%8E%E7%A9%B6%E7%AB%9F%E4%BD%95%E6%97%B6%E6%9B%B4%E6%96%B0"><span class="toc-number">6.10.</span> <span class="toc-text">索引在更新&#x2F;插入后究竟何时更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8D%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">6.11.</span> <span class="toc-text">什么情况下建立索引，什么情况不建立索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.11.1.</span> <span class="toc-text">适合建索引的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.11.2.</span> <span class="toc-text">不适合建索引的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6"><span class="toc-number">6.12.</span> <span class="toc-text">数据库的索引对应的什么文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%B8%8D%E4%BD%BF%E7%94%A8B%E6%A0%91"><span class="toc-number">6.13.</span> <span class="toc-text">为什么MySQL数据库使用B+树不使用B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E4%B8%8D%E7%94%A8%E5%93%88%E5%B8%8C%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">6.14.</span> <span class="toc-text">数据库索引为什么用B+树不用哈希、红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%B1%82%E5%8D%83%E4%B8%87%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">6.15.</span> <span class="toc-text">3层千万数据的计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%82%E6%8E%89%E6%80%8E%E4%B9%88%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">6.16.</span> <span class="toc-text">Mysql数据库挂掉怎么备份和恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql-%E7%B4%A2%E5%BC%95%E5%BE%88%E6%85%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">6.17.</span> <span class="toc-text">Mysql 索引很慢，怎么排查，怎么处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.18.</span> <span class="toc-text">索引失效的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E5%A6%82%E4%BD%95%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">6.19.</span> <span class="toc-text">Mysql如何分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E7%9A%84%E9%94%81"><span class="toc-number">6.20.</span> <span class="toc-text">Mysql的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">6.21.</span> <span class="toc-text">数据库的乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">6.22.</span> <span class="toc-text">Mysql死锁如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%94%81"><span class="toc-number">6.23.</span> <span class="toc-text">如何优化锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99sql%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%8CSQL%E8%B0%83%E4%BC%98"><span class="toc-number">6.24.</span> <span class="toc-text">写sql需要注意的点，SQL调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96"><span class="toc-number">6.25.</span> <span class="toc-text">百万级别的数据优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.26.</span> <span class="toc-text">嵌套查询和嵌套结果的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.27.</span> <span class="toc-text">慢查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql-limit"><span class="toc-number">6.28.</span> <span class="toc-text">Mysql limit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">6.29.</span> <span class="toc-text">事务的四大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">6.30.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%EF%BC%88RC%E4%B8%8ERR%EF%BC%89"><span class="toc-number">6.31.</span> <span class="toc-text">MVCC（RC与RR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redo-Log%E5%92%8CUndo-Log%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.32.</span> <span class="toc-text">Redo Log和Undo Log的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#left-join-%E5%92%8C-right-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.33.</span> <span class="toc-text">left join 和 right join 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.34.</span> <span class="toc-text">内连接和外连接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in-%E3%80%81where-%E5%92%8C-exist-%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">6.35.</span> <span class="toc-text">in 、where 和 exist 怎么用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer-pool%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.36.</span> <span class="toc-text">buffer pool的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98IO%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">7.1.</span> <span class="toc-text">Linux查看磁盘IO占用情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bjava%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">查看java进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">7.3.</span> <span class="toc-text">Linux查看端口占用情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%EF%BC%8C%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9E%E6%8E%A5"><span class="toc-number">7.4.</span> <span class="toc-text">linux系统命令，看系统上有哪些连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%80%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">7.5.</span> <span class="toc-text">Linux下查看某一个进程所占用的内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E6%8E%92%E6%9F%A5CPU%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">7.6.</span> <span class="toc-text">怎样排查CPU占用情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#100M%E5%86%85%E5%AD%98%EF%BC%8C10G%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E4%BB%B6%EF%BC%8C%E6%80%8E%E6%A0%B7%E7%AD%9B%E9%80%89%E5%87%BA%E9%A2%91%E7%8E%87%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%89%8D%E5%8D%81%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.1.</span> <span class="toc-text">100M内存，10G大小的字符串文件，怎样筛选出频率出现次数前十次的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E8%AF%A2"><span class="toc-number">8.2.</span> <span class="toc-text">什么是轮询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">服务器优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.4.</span> <span class="toc-text">怎样设计一个秒杀系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.</span> <span class="toc-text">超卖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E9%98%B2%E6%AD%A2%E5%89%8D%E7%AB%AF%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4"><span class="toc-number">8.6.</span> <span class="toc-text">怎样防止前端重复提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">8.7.</span> <span class="toc-text">单点登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82"><span class="toc-number">8.8.</span> <span class="toc-text">处理重复请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E8%AE%A2%E5%8D%95%E5%A4%84%E7%90%86"><span class="toc-number">8.9.</span> <span class="toc-text">超时订单处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%BA%BA%E6%89%AB%E7%A0%81%E7%82%B9%E9%A4%90"><span class="toc-number">8.10.</span> <span class="toc-text">多人扫码点餐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5"><span class="toc-number">8.11.</span> <span class="toc-text">如果客户端与服务端的连接出现故障，怎么排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E7%BB%B4%E6%8A%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">8.12.</span> <span class="toc-text">怎样维护客户端连接服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BE%88%E5%A4%9A%E6%9C%8D%E5%8A%A1%E6%9D%A5%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8E%BB%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">8.13.</span> <span class="toc-text">有很多服务来调用服务器，怎么去保证服务稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-number">8.14.</span> <span class="toc-text">监控系统哪些方面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E6%8A%8AIO%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">9.1.</span> <span class="toc-text">IO密集型任务把IO和业务逻辑分离有什么好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">做题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%87%BA"><span class="toc-number">10.1.</span> <span class="toc-text">双线程输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">笔试记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E9%87%8C"><span class="toc-number">11.1.</span> <span class="toc-text">阿里</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">11.1.1.</span> <span class="toc-text">满二叉子树的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E8%AE%A1%E6%95%B0"><span class="toc-number">11.1.2.</span> <span class="toc-text">三元组计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%982%E9%99%A42"><span class="toc-number">11.1.3.</span> <span class="toc-text">乘2除2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9A%82%E8%9A%81"><span class="toc-number">11.2.</span> <span class="toc-text">蚂蚁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="面试知识点整理"><img src="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试知识点整理"/></a><div class="content"><a class="title" href="/2023/04/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="面试知识点整理">面试知识点整理</a><time datetime="2023-04-06T16:35:18.000Z" title="发表于 2023-04-07 00:35:18">2023-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="Java力扣刷题记录"><img src="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4375.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java力扣刷题记录"/></a><div class="content"><a class="title" href="/2023/03/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="Java力扣刷题记录">Java力扣刷题记录</a><time datetime="2023-03-14T15:08:53.000Z" title="发表于 2023-03-14 23:08:53">2023-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL基础学习笔记"><img src="https://images.unsplash.com/photo-1655438819488-69bfb10a6c21?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL基础学习笔记"/></a><div class="content"><a class="title" href="/2023/02/12/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL基础学习笔记">MySQL基础学习笔记</a><time datetime="2023-02-12T08:45:54.000Z" title="发表于 2023-02-12 16:45:54">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/" title="瑞吉外卖项目"><img src="https://cdn.stocksnap.io/img-thumbs/960w/coastal-sunset_GYJOTKPBW3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖项目"/></a><div class="content"><a class="title" href="/2023/02/12/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/" title="瑞吉外卖项目">瑞吉外卖项目</a><time datetime="2023-02-12T08:45:32.000Z" title="发表于 2023-02-12 16:45:32">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/05/SSM%E5%AD%A6%E4%B9%A0/" title="SSM学习"><img src="https://cdn.stocksnap.io/img-thumbs/960w/nature-landscape_S1W7ELWFFR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM学习"/></a><div class="content"><a class="title" href="/2023/02/05/SSM%E5%AD%A6%E4%B9%A0/" title="SSM学习">SSM学习</a><time datetime="2023-02-05T03:55:19.000Z" title="发表于 2023-02-05 11:55:19">2023-02-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 杨译茗</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,欢迎来到我的世界！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'twikoo-4g298nsce5004c8a',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'twikoo-4g298nsce5004c8a',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="6748041442" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>