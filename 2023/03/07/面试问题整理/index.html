<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试问题整理 | YYM‘s Blog</title><meta name="keywords" content="面试题目整理"><meta name="author" content="杨译茗"><meta name="copyright" content="杨译茗"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring 讲讲对Spring的理解 IOC 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理 AOP AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问题整理">
<meta property="og:url" content="https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="YYM‘s Blog">
<meta property="og:description" content="Spring 讲讲对Spring的理解 IOC 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理 AOP AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-03-07T10:17:37.000Z">
<meta property="article:modified_time" content="2023-03-07T10:23:27.941Z">
<meta property="article:author" content="杨译茗">
<meta property="article:tag" content="面试题目整理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="https://i.loli.net/2021/05/22/yRLpfi8dHGJktEc.png"><link rel="canonical" href="https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?df75c0fdf4d51c6436007e2cf0312f5c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试问题整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-07 18:23:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet"href="/css/icon.css"media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/05/22/2KPMBkSoU3ahebr.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-dragon"></i><span> 电影</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-spider"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YYM‘s Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-dragon"></i><span> 电影</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-spider"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试问题整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-07T10:17:37.000Z" title="发表于 2023-03-07 18:17:37">2023-03-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-07T10:23:27.941Z" title="更新于 2023-03-07 18:23:27">2023-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0-JAVA-%E9%9D%A2%E8%AF%95/">-学习 -JAVA -面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试问题整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Spring</h1>
<h2 id="讲讲对Spring的理解">讲讲对Spring的理解</h2>
<h3 id="IOC">IOC</h3>
<p>是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</p>
<h3 id="AOP">AOP</h3>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</p>
<p>能够在已有方法，属性，代码块的基础上批量进行功能的增强</p>
<h2 id="AOP-2">AOP</h2>
<p>在不惊动原始设计的基础上为其进行功能增强，即无入侵式编程，<strong>可以将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统代码的重复代码和降低模块间的耦合度</strong></p>
<p>AOP有两种实现方式：静态代理和动态代理</p>
<ul>
<li>
<p>静态代理：代理类在编译阶段生成，在编译阶段将通知植入Java字节码中，也称编译时增强，AspectJ使用的是静态代理，静态代理的缺点就是代理对象需要与目标对象实现一样的接口，并且实现接口的方法会有冗余代码，同时，一旦接口增加方法，目标对象与代理对象都要维护</p>
</li>
<li>
<p>动态代理：在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类，具体来说，如果为Spring的某个bean配置的切面，那创建bean的时候，实际上创建的是这个bean的一个代理对象，后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。有两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理</p>
<ul>
<li>
<p>JDK动态代理：如果目标实现了接口，SpringAOP会选择使用JDK动态代理目标类，JDK动态代理的代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口，JDK动态代理的核心是InvocationHandler接口（拦截器）和Proxy类，如果某个类没有实现接口，那这个类就不能用JDK动态代理</p>
</li>
<li>
<p>CGLib动态代理：如果目标类没有实现接口，那么AOP会选择使用CGLib来动态代理目标类，全称为Code Generation Library，可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类，CGLib是通过继承的方式实现的动态代理，因此如果某个类被标记为final，那么他是无法使用CGLib做动态代理的，CGLib的优点是目标类不需要实现特定的接口，更加灵活</p>
</li>
</ul>
</li>
</ul>
<p>连接点，切入点+通知——&gt;切面</p>
<p><img src="https://s2.loli.net/2023/02/27/fAgWX5jlR6usExo.png" alt="image-20230227210834126"></p>
<p><img src="https://s2.loli.net/2023/02/27/5wOEWZj3JHqUvat.png" alt="image-20230227211059048"></p>
<p><img src="https://s2.loli.net/2023/02/27/hvkNTAYqu6241tV.png" alt="image-20230227211109637"></p>
<h2 id="Spring事务">Spring事务</h2>
<p>三步：</p>
<p><img src="https://s2.loli.net/2023/02/27/z8RwDFpUWo3CX4T.png" alt="image-20230227212149992"></p>
<p>②设置事务管理器</p>
<p><img src="https://s2.loli.net/2023/02/27/EVohKeBqst8y4L9.png" alt=""></p>
<p>③开启注解式事务驱动</p>
<p><img src="https://s2.loli.net/2023/02/27/flvdZTyRtQFOuN6.png" alt="image-20230227211918009"></p>
<p>@Transactional一般放在接口里不放在实现类里，为了降低耦合</p>
<h2 id="spring事务的失效场景">spring事务的失效场景</h2>
<h2 id="“-”和“-”的区别">“#{}”和“${}”的区别</h2>
<p>答：都是Mybatis里面提供的两种实现动态SQL的方式，可以把参数传递到XML里面，#等同于JDBC里面的“？”占位符，PreparedStatement，“#”可以防止SQL注入，属于动态参数，，适合于动态传递表名，动态设置排序字段，而使用“$”相当于直接把参数拼接到了原式SQL里面，Mybatis不会对它进行任何的特殊处理</p>
<h2 id="BeanFactory和FactoryBean的区别">BeanFactory和FactoryBean的区别</h2>
<p>答：BeanFactory是一个Factory，是IOC容器的顶级接口，是IOC容器最基础的实现，同时也是访问Spring容器的根接口，主要是负责Bean的创建和访问，里面有一个getBean方法，同时BeanFactory还能完成对Bean的依赖注入的功能，即DI</p>
<p>FactoryBean是一个特殊的Bean，是一个工厂Bean，如果配置了FactoryBean接口，那就可以通过不同的配置类，去返回不同类型的Bean，一个比较核心的方法是getObject。如果要使用Bean工厂，可以手动实现一个实现FactoryBean接口的一个类。</p>
<p>通过getObject方法返回一个对象，当用户使用容器本身时，可以使用转义字符<code>”&amp;”</code>来得到FactoryBean本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身，如果beanName没有加&amp;，则获取的是泛型T的对象，如果加了&amp;，获取的是实现了FactoryBean接口本身的对象</p>
<p><img src="https://s2.loli.net/2023/02/19/gYbyu1kczq8DGI7.png" alt="image-20230219155355502"></p>
<h2 id="DI的方式">DI的方式</h2>
<h3 id="Setter注入">Setter注入</h3>
<h4 id="引用类型">引用类型</h4>
<p>property标签，name属性+ref属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单属性">简单属性</h4>
<p>property标签，name属性+value属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造器注入">构造器注入</h3>
<h4 id="引用类型-2">引用类型</h4>
<p>constructor-arg标签，name属性+ref属性</p>
<p>其中name是构造器的形参，所以耦合度较高</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单属性-2">简单属性</h4>
<p>constructor-arg标签，name属性+value属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自动配置">自动配置</h3>
<ul>
<li>==按类型（常用）==：要求类型匹配必须唯一</li>
<li>按名称</li>
<li><img src="https://s2.loli.net/2023/02/27/rfscMWoCx4HjmSn.png" alt="image-20230227204257803"></li>
</ul>
<h2 id="纯注解开发">纯注解开发</h2>
<p>新建一个config包下的SpringConfig，这样就不用配置了，然后加上@Configuration，再写上@ComponentScan</p>
<p><img src="https://s2.loli.net/2023/02/27/HDKvaVkbyATXoNx.png" alt="image-20230227204844510"></p>
<p>然后换为注解开发加载配置类：</p>
<p><img src="https://s2.loli.net/2023/02/27/sVH4yKon73DMXO5.png" alt="image-20230227204919629"></p>
<p><img src="https://s2.loli.net/2023/02/27/xnrgtjTJBGquAf7.png" alt="image-20230227204949788"></p>
<p>在类中比如BookDaoImpl加上@Component，等价于<bean></p>
<p><img src="https://s2.loli.net/2023/02/27/7VmpXDKyAzxrvfC.png" alt="image-20230227205137500"></p>
<p>如果有多个相同类型的Bean，则：</p>
<p>@Autowired：使用暴力反射，故无需setter方法</p>
<p>@Qualifier(“Bean名称”)</p>
<p>如果是简单类型注入，则@Value</p>
<p>如果是外部properties注入，则先把SpringConfig加上@PropertySource(“jdbc.properties”)，然后改为@Value(“${name}”)，即可把properties里面的name注入</p>
<h2 id="Spring中Bean的作用域有哪些">Spring中Bean的作用域有哪些</h2>
<ol>
<li>Spring 中 Bean 的作用域通常有下面几种：
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean</li>
</ul>
</li>
</ol>
<h2 id="将一个类声明为-Bean-的注解有哪些">将一个类声明为 Bean 的注解有哪些?</h2>
<p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要<strong>想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类</strong>,可以采用以下注解实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
<h2 id="Component和-Bean注解的区别">@Component和@Bean注解的区别</h2>
<p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p>
<blockquote>
<p>@Bean表示当前方法返回值是一个bean（黑马），一般用于管理第三方Bean，然后用@Import注解手动加入配置类到核心配置</p>
</blockquote>
<p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p>
<p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p>
<h2 id="Spring-IOC的工作流程">Spring IOC的工作流程</h2>
<p>IOC全称为Inversion of control，即控制反转，核心思想是把对象的管理权限交给了容器，好处是降低了对象与对象之间的耦合性</p>
<p><img src="https://s2.loli.net/2023/02/20/npTWvUomzHVul5t.png" alt="image-20230220185143785"></p>
<blockquote>
<p>声明Bean的方式：</p>
<ol>
<li>xml文件中使用<bean></li>
<li>@Service/@Repository/@Component</li>
<li>@Configuration-@Bean(在Configuration配置类里面通过Bean注解去声明)</li>
</ol>
<p>Spring在启动的时候会解析这些Bean，然后保存到IOC容器里面</p>
</blockquote>
<p>IOC的工作流程：</p>
<ol>
<li><strong>IOC容器的初始化阶段</strong>：通过解析和加载后生成的BeanDefinition，然后将BeanDefinition注册到IOC容器里面，把BeanDefinition保存到一个Map集合里面</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/zIx5vlCdG7O3XLb.png" alt="image-20230220191350435"></p>
<ol start="2">
<li><strong>完成Bean的初始化和依赖注入</strong>：会完成两个事情，第一个是通过反射去针对没有设置lazy-init属性的单例bean进行初始化，第二个是完成bean的依赖注入</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/X4nriPvkWbZI3dg.png" alt="image-20230220191642673"></p>
<p><strong>Bean的使用</strong>：通过BeanFactory.getBean()或者@Autowired</p>
<p><img src="https://s2.loli.net/2023/02/20/954EgFj8wWmeCUt.png" alt="image-20230220191810758"></p>
<h3 id="注入-Bean-的注解有哪些？">注入 Bean 的注解有哪些？</h3>
<p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="Autowired和-Resource的区别">@Autowired和@Resource的区别</h2>
<p><img src="https://s2.loli.net/2023/02/22/bYGiImM8p279zaj.png" alt="image-20230222181632905"></p>
<p>@AutoWired先根据属性的类型去Spring容器中找Bean对象，如果找到多个，就会根据名字去确定其中一个，如果根据名字没有找到则会报错；@Resouce会先根据名字取Spring容器中找Bean对象，如果没有则会按照属性，如果还没有则会报错，另外，可以指定@Resouce的name，如果配置了name，则只会找到这个叫name的Bean对象，如果没有找到，就会直接报错，不会再根据类型去找了，@AutoWired是Spring层面提供的，是和Spring强绑定的，@Resouce是JDK层面提供的</p>
<h2 id="Mybatis和JDBC的区别">Mybatis和JDBC的区别</h2>
<h1>JVM</h1>
<h2 id="JAVA运行时数据区域">JAVA运行时数据区域</h2>
<ol>
<li>堆：存放对象实例，分为新生代和老年代，其中新⽣代又分为Eden区，From Survivor和To Survivor区，⽐例是8:1:1</li>
<li>方法区：存储已经被虚拟机加载的类信息，常量，静态变量（永久代，jkd1.8后改为元空间）</li>
<li>虚拟机栈：局部变量表，操作数栈，动态链接，方法返回地址</li>
<li>程序计数器：保存下一条需要执行的字节码指令（可以为空）</li>
<li>本地方法栈：与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</li>
</ol>
<ul>
<li>
<p><strong>成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</strong></p>
<ul>
<li>要想在该方法中使用成员变量，必须使用关键字this</li>
</ul>
</li>
<li>
<p><strong>静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;类体重定义的name&quot;</span>;			<span class="comment">//类中的成员变量并赋值</span></span><br><span class="line"> </span><br><span class="line">	People()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;类体方法中定义的name&quot;</span>;		<span class="comment">//在方法speak中定义和成员变量名字相同的name并赋值</span></span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name);		<span class="comment">//通过this来访问类中的成员变量</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThis</span> </span>&#123;                              <span class="comment">//源文件中只能有一个类是public类，并且源文件的名字必须与这个类的名字完全相同，如                                                      //果没有public类，那么源文件的名字只要和某个类的名字相同就可以了。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">		People myPeople = <span class="keyword">new</span> People();</span><br><span class="line">		myPeople.speak();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/02/28/rFUx1wWBl7YkO6A.png" alt="image-20230228161331502"></p>
<p><img src="https://s2.loli.net/2023/02/28/u2UX19jkl6TsEnF.png" alt="image-20230228161317419"></p>
<p><img src="https://s2.loli.net/2023/03/01/Ljd57vMagfht6xu.png" alt="image-20230301144634000"></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1714914983791082793&amp;wfr=spider&amp;for=pc">运行时数据区 (baidu.com)</a></p>
<h2 id="什么时候会出现OOM问题">什么时候会出现OOM问题</h2>
<p>除了程序计数器不会产⽣OOM，其余的均可以产⽣OOM</p>
<p>方法区 OOM：</p>
<p>1、 加载大量的第三方的jar包</p>
<p>2、Tomcat部署的工程过多（30~50个）</p>
<p>3、<strong>大量动态的生成反射类</strong></p>
<h2 id="内存泄露场景">内存泄露场景</h2>
<ol>
<li>**实例变量作用域不合理：**如果只需要一个变量作为局部变量，在方法结束就不使用它了，但是把他设置为实例变量，此时如果该类的实例对象生命周期很长也会导致该变量无法回收发生内存泄漏（因为实例对象引用了它）</li>
<li><strong>ThreadLocal中回收key以后可能会发生</strong>，因为Value是强引用，不会主动GC</li>
<li>**不关闭资源引发内存泄漏：**数据库连接、网络连接、IO连接在使用后忘记关闭，GC无法回收它们，会发生内存泄漏</li>
<li>使用散列表时，充当Key 对象的哈希值被改变导致内存泄漏（key 使用逻辑不可变对象，关键域不能被修改）</li>
</ol>
<h2 id="ThreadLocal是怎么实现的">ThreadLocal是怎么实现的</h2>
<p>ThreadLocal底层是通过ThreadLocalmap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值，不同于synchronized的互斥效果，它是隔离性，各个线程操作自己的数据，还可用于单线程间的全区共享</p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</p>
<h2 id="ThreadLocal带来的问题及解决">ThreadLocal带来的问题及解决</h2>
<p>内存泄漏：ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤，解决：<strong>手动remove</strong></p>
<h2 id="volatile关键字是怎么实现的">volatile关键字是怎么实现的</h2>
<p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序</p>
<p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取</p>
<h2 id="进程和线程区别，具体到上下文切换，哪些资源共享哪些不共享">进程和线程区别，具体到上下文切换，哪些资源共享哪些不共享</h2>
<p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位</strong>，在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p>
<p>线程切换时保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong></p>
<ul>
<li>线程是CPU执行、CPU时间分配的基本单位</li>
<li>进程其他系统资源（内存），一系列的系统资源组成的集合</li>
</ul>
<h2 id="JAVA线程调度">JAVA线程调度</h2>
<p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复</p>
<h2 id="JAVA线程的状态">JAVA线程的状态</h2>
<ol>
<li>新建（New）</li>
<li>运⾏（Runnable）</li>
<li>阻塞（Blocked）</li>
<li>⽆限期等待（Waiting）</li>
<li>限期等待（Time Waiting）</li>
<li>结束（Terminated）</li>
</ol>
<h2 id="进程的状态">进程的状态</h2>
<ol>
<li>创建状态</li>
<li>就绪状态</li>
<li>运行状态</li>
<li>阻塞状态/等待状态</li>
<li>结束状态</li>
</ol>
<h2 id="线程通信方式">线程通信方式</h2>
<ol>
<li>互斥量：采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，Java 中的synchronized 关键词和各种 Lock</li>
<li>信号量：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最⼤线程数量</li>
<li>事件：通过通知操作的⽅式来保持多线程同步</li>
</ol>
<h2 id="进程之间的通信方式">进程之间的通信方式</h2>
<ol>
<li>管道</li>
<li>信号</li>
<li>信号量</li>
<li>消息队列</li>
<li>共享内存</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/26/zSeI9PfidF2g6Wx.png" alt="image-20230226134700122"></p>
<h2 id="sleep和wait的区别">sleep和wait的区别</h2>
<ol>
<li>sleep⽅法属于Thread类，wait⽅法属于Object类</li>
<li>sleep⽅法暂停执⾏指定的时间，让出CPU给其他线程，但其监控状态依然保持在指定的时间过后又会⾃动恢复运⾏状态。</li>
<li>在调⽤sleep⽅法的过程中，线程不会释放对象锁，⽽wait会释放对象锁</li>
</ol>
<h2 id="CAS">CAS</h2>
<p>CAS指令有三个操作数，分别是内存偏移量V（可理解为内存地址），旧的预期值E，准备设置的新值N</p>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了V，则当前线程放弃更新</p>
<h3 id="CAS可能的问题：">CAS可能的问题：</h3>
<ol>
<li><strong>ABA问题</strong>：解决用版本号或时间戳</li>
<li><strong>循环时间长开销大</strong>：CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销，解决用pause指令</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，解决在jdk1.5后：可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作</li>
</ol>
<h2 id="乐观锁和悲观锁">乐观锁和悲观锁</h2>
<p>悲观锁和乐观锁并不是某个具体的“锁”⽽是⼀种并发编程的基本概念</p>
<h3 id="悲观锁">悲观锁</h3>
<p><strong>定义：</strong></p>
<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放</p>
<p>即：<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong></p>
<p><strong>使用场景：</strong></p>
<p>悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能</p>
<h3 id="乐观锁">乐观锁</h3>
<p><strong>定义：</strong></p>
<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</p>
<p><strong>使用场景：</strong></p>
<p>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量</p>
<p><strong>实现：</strong></p>
<ol>
<li>
<p><strong>版本号机制：</strong></p>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功</p>
</li>
<li>
<p><strong>CAS算法</strong></p>
</li>
</ol>
<h2 id="创建线程的方式：">创建线程的方式：</h2>
<ol>
<li>
<p>写⼀个类<strong>继承⼦Thread类</strong>，重写run方法</p>
<p>单继承具有局限性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式一：继承Thread类，重写run()方法，调用start()开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run()方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码——————&quot;</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//main()线程，主线程</span></span><br><span class="line">        <span class="comment">//创建一个对象</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">//调用start()方法</span></span><br><span class="line">        testThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写⼀个类<strong>实现Runable接口</strong>，重写run⽅法</p>
<p>避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式2:实现runnable接口,重写run方法，执行线程丢入runnable接口实现类，调用start()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建runnable接口的实现类对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启我们的线程，代理</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(testThread3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;学习&quot;</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写⼀个类<strong>实现Callable接口</strong>，重写call⽅法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个类，重写call()方法，</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在上班-----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = executorService.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = executorService.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = executorService.submit(t3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        Boolean r1 = result1.get();</span><br><span class="line">        Boolean r2 = result2.get();</span><br><span class="line">        Boolean r3 = result3.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使⽤线程池</p>
</li>
</ol>
<h2 id="创建线程池的方式">创建线程池的方式</h2>
<ol>
<li><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建</strong></li>
<li><strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建</strong>（阿里手册不允许）</li>
</ol>
<h2 id="JVM中类加载的机制是什么样的">JVM中类加载的机制是什么样的</h2>
<p>JVM中的类加载机制是一种基于双亲委派模型的机制，系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。在加载阶段，JVM会查找并加载指定的类文件；在验证阶段，JVM会验证类文件的正确性；在准备阶段，JVM会为类变量分配内存并设置类变量的初始值。</p>
<p><img src="https://s2.loli.net/2023/02/26/yav87xXSqZUIfsD.png" alt="image-20230226161425883"></p>
<h2 id="JVM内存溢出有哪些场景会导致">JVM内存溢出有哪些场景会导致</h2>
<ol>
<li>在JVM中，当 Java 堆内存用完时会导致内存溢出。</li>
<li>另一种情况是，程序中存在大量循环引用，导致无法被 Java 垃圾回收器回收，从而导致内存溢出。</li>
<li>同样，JVM 栈中的局部变量消耗太多的内存也会导致内存溢出。</li>
<li>在 JVM 运行时，虚拟机配置的内存大小比需求的大小要小，也会导致内存溢出。</li>
</ol>
<h2 id="对象的创建过程">对象的创建过程</h2>
<h3 id="Step1-类加载检查">Step1:类加载检查</h3>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="Step2-分配内存">Step2:分配内存</h3>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞 ：
<ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ：
<ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="Step3-初始化零值">Step3:初始化零值</h3>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="Step4-设置对象头">Step4:设置对象头</h3>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="Step5-执行-init-方法">Step5:执行 init 方法</h3>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p>
<h2 id="如何判断对象是否死亡（两种方法）">如何判断对象是否死亡（两种方法）</h2>
<h3 id="引用计数法">引用计数法</h3>
<p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的</li>
</ul>
<p>缺点：<strong>它很难解决对象之间相互循环引用的问题</strong></p>
<h3 id="可达性分析算法">可达性分析算法</h3>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收</p>
<p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象</p>
<p><img src="https://s2.loli.net/2023/02/22/kh4lgQZp7cCorUT.png" alt="image-20230222205338789"></p>
<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p>当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行</p>
<h2 id="介绍强引用、软引用、弱引用、虚引用">介绍强引用、软引用、弱引用、虚引用</h2>
<p>包含虚引用与软引用和弱引用的区别、使用软引用能带来的好处</p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>
<h2 id="虚引用的作用">虚引用的作用</h2>
<p>唯⼀的⽤处：能在对象被GC时收到系统通知</p>
<p>虚引⽤必须和引⽤队列 （ReferenceQueue）联合使⽤。当垃圾回收器准备回收⼀个对象时，如果发现它还有虚引⽤，就会在回收对象的内存之前，把这个虚引⽤加⼊到与之关联的引⽤队列中</p>
<h2 id="如何判断一个常量是废弃常量">如何判断一个常量是废弃常量</h2>
<p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池了。</p>
<h2 id="如何判断一个类是无用的类">如何判断一个类是无用的类</h2>
<ul>
<li>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
</li>
<li>
<p>加载该类的 <code>ClassLoader</code> 已经被回收。</p>
</li>
<li>
<p>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<h2 id="垃圾收集有哪些算法，各自的特点？">垃圾收集有哪些算法，各自的特点？</h2>
<ul>
<li>
<p>标记清除算法</p>
</li>
<li>
<p>标记复制算法</p>
</li>
<li>
<p>标记整理算法</p>
</li>
<li>
<p>分代收集算法</p>
</li>
</ul>
<h2 id="HotSpot-为什么要分为新生代和老年代？">HotSpot 为什么要分为新生代和老年代？</h2>
<p>一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</p>
<h2 id="常见的垃圾回收器有哪些？">常见的垃圾回收器有哪些？</h2>
<ul>
<li>
<p>Serial 收集器：单线程+STW</p>
</li>
<li>
<p>ParNew 收集器：<strong>是 Serial 收集器的多线程版本，新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p>
</li>
<li>
<p>Parallel Scavenge 收集器：<strong>关注点是吞吐量</strong>（吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值），<strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p>
</li>
<li>
<p>CMS收集器(Concurrent Mark Sweep)：<strong>关注点是响应时间</strong>，<strong>是并发收集器</strong>，实现<strong>标记-清除”算法</strong></p>
<p>缺点：</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</li>
</ul>
</li>
<li>
<p>G1收集器：使用多个CPU缩短STW停顿时间；局部是标记复制算法；可预测的停顿</p>
<p>G1垃圾回收器抛弃了分代的概念，将堆内存划分为⼤⼩固定的⼏个独⽴区域，并维护⼀个优先级列表，在垃圾回收过程中根据系统允许的最长垃圾回收时间，优先回收垃圾最多的区域。</p>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 	Region(这也就是它的名字 Garbage-First 的由来)</strong></p>
</li>
</ul>
<h2 id="类的生命周期">类的生命周期</h2>
<p><img src="https://s2.loli.net/2023/02/23/fmYEjcO83WFhlLG.png" alt="image-20230223095349477"></p>
<h2 id="类的加载过程">类的加载过程</h2>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong></p>
<p><strong>加载：</strong></p>
<ol>
<li>将 class 文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</li>
</ol>
<p>验证：文件格式，元数据，字节码，符号引用</p>
<p>**准备：**为类变量分配内存并且设置类变量初始值</p>
<p>​	jdk 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的</p>
<p>**初始化：**对静态变量赋值、并执行静态代码块</p>
<h2 id="对象的加载过程">对象的加载过程</h2>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">int</span> staicVariabl=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span>   <span class="keyword">int</span>  objVariabl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态初始代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staicVariabl=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象初始化代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        objVariabl=<span class="number">88</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        objVariabl=<span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person=<span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person person=new Person()</p>
<ol>
<li>
<p>构建对象</p>
<p>main线程在栈中申请栈空间，并生成一个栈帧，里面局部变量表中包含有person。</p>
<p>然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM<strong>堆中</strong>申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。</p>
<p><img src="https://s2.loli.net/2023/03/07/4lI1GQ79CbYDjMN.png" alt="image-20230307165405107"></p>
</li>
<li>
<p>初始化对象</p>
<p>执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法（init 方法执行完后objVariabl=88，构造方法执行完后objVariabl=99)</p>
<p><img src="https://s2.loli.net/2023/03/07/k8etDogCbURqz7Z.png" alt="image-20230307165433251"></p>
</li>
<li>
<p>引用对象</p>
<p>对象实例化完毕后，再把栈中的person对象引用地址指向Person对象在堆内存中的地址。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/07/yeTJQg5EFCpPSjf.png" alt="image-20230307165840944"></p>
<h2 id="双亲委派机制">双亲委派机制</h2>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成</p>
<p>保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改</p>
<p>具体而言，即为在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器</p>
<p><img src="https://s2.loli.net/2023/02/26/Suh9KNIkd1RCBpH.png" alt="image-20230226164403300"></p>
<h2 id="多线程的实现方式">多线程的实现方式</h2>
<h2 id="JVM调优">JVM调优</h2>
<ol>
<li>调整最大堆内存和最小堆内存</li>
<li>调整新生代和老年代的比值</li>
<li>调整survivor区和Eden区的比值（一般为8:1:1）</li>
<li>设置年轻代和老年代的大小</li>
</ol>
<h2 id="线程池有哪些参数，分别的含义">线程池有哪些参数，分别的含义</h2>
<p>七大核心参数</p>
<ol>
<li>
<p>**corePoolSize：**核⼼线程数</p>
</li>
<li>
<p><strong>maximumPoolSize：</strong> 线程池中最⼤线程数</p>
</li>
<li>
<p>**keepAliveTime：**多余空闲线程数的存活时间，当前线程数⼤于corePoolSize，并且等待时间⼤于keepAliveTime，多于线程或被销毁直到剩下corePoolSize为⽌。</p>
</li>
<li>
<p><strong>TimeUnit unit：</strong> keepAliveTime的单位。</p>
</li>
<li>
<p>**workQueue：**任务队列，被提交但未必执⾏的任务。</p>
</li>
<li>
<p>**threadFactory：**⽤于创建线程池中⼯作线程的线程⼯⼚，⼀般⽤默认的。</p>
</li>
<li>
<p>**handler：**拒绝策略，当堵塞队列满了并且⼯作线程⼤于线程池的最⼤线程数（maximumPoolSize）</p>
<p><img src="https://s2.loli.net/2023/02/26/5wG61dFTamER3M8.png" alt="image-20230226153805288"></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/26/u3yJVo8TY7SZWXg.png" alt="image-20230226153857717"></p>
<h2 id="为什么JVM把永久代换成了元空间">为什么JVM把永久代换成了元空间</h2>
<ol>
<li>在1.7版本中永久代内存是有上限的，虽然可以通过参数设置上限，但是JVM加载的class总数大小是很难去确定的，所以很容易出现OOM的问题，而元空间是存储在本地内存里面，内存上限比较大，可以很好的避免这个问题</li>
<li>永久代的对象是利用FullGC来垃圾回收的，即和老年代同时进行垃圾回收，替换成元空间后简化了FullGC的过程，即有各种垃圾回收算法，可以在不暂停的情况下去并发的释放类的数据，同时也提升了GC的性能</li>
<li>Oracal要合并Hotspot和JRockit的代码，而JRockit中没有永久代</li>
</ol>
<h1>计网</h1>
<h2 id="三次握手过程">三次握手过程</h2>
<ul>
<li>
<p>第一个报文：SYN报文：客户端随机初始化32位序列号client_isn</p>
</li>
<li>
<p>第二个报文：SYN+ACK报文：服务端随机初始化32位序列号server_isn，确认应答号为收到的客户端ISN+1</p>
</li>
<li>
<p>第三个报文：ACK报文：确认应答号为收到服务端的ISN+1</p>
</li>
</ul>
<h2 id="四次挥手过程">四次挥手过程</h2>
<ul>
<li>客户端发送FIN报文，客户端进入FIN_WAIT_1状态</li>
<li>服务端收到后发送ACK应答报文，并进入CLOSED_WAIT状态</li>
<li>客户端收到ACK后进入FIN_WAIT_2状态</li>
<li>等服务端处理完数据，会向客户端发送FIN报文，并进入LAST_ACK状态</li>
<li>客户端收到FIN报文后，回一个ACK应答报文，并进入TIME_WAIT状态</li>
<li>服务器收到ACK报文后，进入CLOSED状态</li>
<li>客户端在经过2MSL时间后，自动进入CLOSED状态</li>
</ul>
<h2 id="为什么是2MSL">为什么是2MSL</h2>
<h2 id="常用状态码">常用状态码</h2>
<p>301,302,500，501，502，401,402,403,404</p>
<p><img src="https://s2.loli.net/2023/02/25/RNLkfzU2HGlWge5.png" alt=""></p>
<p><img src="https://s2.loli.net/2023/02/25/LRerzM46Z9tX2Il.png" alt="image-20230225204425405"></p>
<p><img src="https://s2.loli.net/2023/02/25/YvlgQ5eIPfXKFhd.png" alt="image-20230225204414914"></p>
<h2 id="HTTP1-2-3缺陷">HTTP1/2/3缺陷</h2>
<h3 id="HTTP缺陷">HTTP缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/wD7QIp951mFfC4P.png" alt="image-20230225204244708"></p>
<h3 id="HTTP1-1缺陷">HTTP1.1缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/6QyaX12SmWkGInN.png" alt="image-20230225204202208"></p>
<p>以及高延迟问题：</p>
<p><img src="https://s2.loli.net/2023/02/25/H3QOgP8r42yD9WA.png" alt="image-20230225204745802"></p>
<h3 id="HTTP-2缺陷">HTTP/2缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/xlym3cu2zd5VYKo.png" alt="image-20230225204104566"></p>
<p><img src="https://s2.loli.net/2023/02/25/gHqskGcOQ47jr2U.png" alt="image-20230225204925272"></p>
<p>解决用QUIC：</p>
<p><img src="https://s2.loli.net/2023/02/25/K2zqmTVJr5DZQBP.png" alt="image-20230225204856451"></p>
<h2 id="HTTP的队头阻塞">HTTP的队头阻塞</h2>
<p>多路复用，HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题， 降低了延迟，⼤幅度提⾼了连接的利⽤率</p>
<h2 id="TCP和UDP的区别">TCP和UDP的区别</h2>
<p><img src="https://s2.loli.net/2023/02/20/ZHiR2TzWVIXnL3A.jpg" alt=""></p>
<p>应用场景：</p>
<p><img src="https://s2.loli.net/2023/02/28/kmJyhqtENjOofG1.png" alt="image-20230228134610615"></p>
<h2 id="tcp和http区别">tcp和http区别</h2>
<h2 id="tcp和udp能否共用一个端口号">tcp和udp能否共用一个端口号</h2>
<h2 id="ping的发送和接收过程">ping的发送和接收过程</h2>
<ol>
<li>源主机先构建一个ICMP回送请求消息数据包，包含字段，类型（8），序号(用于区分连续ping的时候发出的多个数据包)以及发送时间</li>
<li>ICMP协议将数据包连同目标主机地址一起交给IP层，IP层进一步将本机IP地址作为源地址，协议字段设置为1表示是ICMP协议</li>
<li>加入MAC头，如果在本地ARP映射表中查找出对应的MAC地址，则直接使用，如果没有，则发送ARP协议查询MAC地址，获得后由数据链路层构建一个数据帧</li>
<li>主机 B 收到这个数据帧后，先检查它的⽬的 MAC 地址，并和本机的 MAC 地址对⽐，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样， IP 层检查后，将有⽤的信息提取后交给 ICMP 协议</li>
<li>主机B会构建⼀个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0 ， 序号为接收到的请求数据包中的序号，然后再发送出去给主机A，在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明⽬标主机不可达；如果接收到了 ICMP 回送响应消息，则说明⽬标主机可达。</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/r4fB1Hn59tekvgQ.png" alt="image-20230220135609934"></p>
<h2 id="当键入网址后，到网页显示，其间发生了什么">当键入网址后，到网页显示，其间发生了什么</h2>
<p><img src="https://s2.loli.net/2023/02/20/BwlAIdDYTcsaOQz.png" alt="image-20230220153505776"></p>
<ol>
<li>解析URL，生成发送给Web服务器的HTTP请求信息（包含服务器名称以及数据源文件的路径名）</li>
<li>通过DNS查询服务器域名对应的IP地址</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/3vGxp6Ynk2NRrlc.png" alt="image-20230220150008877"></p>
<ol start="3">
<li>
<p>通过DNS获得到IP后，把HTTP的传输工作交给操作系统中的协议栈</p>
<p>包含TCP，IP(ICMP，ARP（⽤于根据 IP 地址查询相应的以太⽹ MAC 地址  ）)</p>
<p>具体包含：TCP三次握手，TCP分割数据</p>
<ul>
<li>ICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息。</li>
<li>ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址</li>
</ul>
<p>在发包时：</p>
<blockquote>
<p>先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中的地址。⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询</p>
</blockquote>
</li>
<li>
<p>分别加上HTTP报文，TCP头部，IP头部，MAC头部，MAC包头协议类型只使用0800表示IP协议或者0806表示ARP协议</p>
<p><strong>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象</strong></p>
<p><strong>⽣成了 IP 头部之后，接下来网络包还需要在 IP 头部的前⾯加上 MAC 头部</strong></p>
</li>
<li>
<p>通过网卡传播，转换为电信号</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/CcEYbg25nMVQJ78.png" alt="image-20230220153152419"></p>
<ol start="6">
<li>通过交换机
<ul>
<li>交换机⼯作在 MAC 层，是基于以太⽹设计的，也称为⼆层⽹络设备</li>
<li>交换机的端⼝不具有 MAC 地址</li>
<li>将包存⼊缓冲区后，接下来需要查询⼀下这个包的接收⽅ MAC 地址是否已经在 MAC 地址表中有记录了，如果有则直接进行转发，如果没有，则转发到除源端口外的所有端口上</li>
</ul>
</li>
<li>通过路由器
<ul>
<li>路由器是基于 IP 设计的，俗称<strong>三层网络设备</strong>，路由器的各个端⼝都具有 MAC 地址和 IP 地址</li>
</ul>
</li>
</ol>
<h2 id="RPC-协议和-HTTP-协议的区别和特点">RPC 协议和 HTTP 协议的区别和特点</h2>
<h2 id="讲一下-TCP-三次握手，两次、四次不行吗">讲一下 TCP 三次握手，两次、四次不行吗</h2>
<ul>
<li>三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）</li>
<li>三次握⼿才可以同步双⽅的初始序列号</li>
<li>三次握⼿才可以避免资源浪费</li>
</ul>
<p>**「两次握⼿」：**⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；</p>
<p>**「四次握⼿」：**三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数</p>
<h2 id="TIME-WAIT-状态是做什么用的">TIME_WAIT 状态是做什么用的</h2>
<p>⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都自然消失，再出现的数据包⼀定都是新建立连接所产⽣的</p>
<p>**报文最大生存时间  **：2MSL</p>
<p>为什么是2MSL：<strong>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间</strong></p>
<h2 id="网络拥塞状态下TCP数据传输，从流量控制角度聊聊">网络拥塞状态下TCP数据传输，从流量控制角度聊聊</h2>
<h2 id="https加密过程（详细）">https加密过程（详细）</h2>
<h2 id="HTTP-2与HTTP的区别">HTTP/2与HTTP的区别</h2>
<h2 id="HTTP与HTTPS的区别（细扣）">HTTP与HTTPS的区别（细扣）</h2>
<ul>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<h2 id="HTTP常用的状态码">HTTP常用的状态码</h2>
<h2 id="三次握手为什么是三次-四次挥手为什么是四次">三次握手为什么是三次 四次挥手为什么是四次</h2>
<p>服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次</p>
<p><img src="https://s2.loli.net/2023/02/28/NSvI7JmfVXDhwHY.png" alt="image-20230228141655187"></p>
<p><img src="https://s2.loli.net/2023/02/28/pyobLrQEltsVn3Z.png" alt="image-20230228141632925"></p>
<h2 id="TCP是如何保证高可靠的">TCP是如何保证高可靠的</h2>
<ul>
<li>流式传输</li>
<li>一对一传输</li>
<li>重传机制：超时重传+快速重传+SACK+D-SACK</li>
<li>滑动窗口</li>
<li>拥塞控制：慢启动，拥塞避免，拥塞发生，快速回复</li>
<li>流量控制</li>
<li>三次握手、四次挥手</li>
</ul>
<h2 id="ping-基于什么协议，ICMP-层次">ping 基于什么协议，ICMP 层次</h2>
<h2 id="如果TCP连接不成功，但是ping可以ping通，如何排查网络问题"><strong>如果TCP连接不成功，但是ping可以ping通，如何排查网络问题</strong></h2>
<ol>
<li>防火墙：目标主机可能配置了防火墙规则，禁止TCP连接。因此，您可以通过ping命令ping通目标主机，但是无法建立TCP连接。请检查目标主机的防火墙规则并确保允许TCP连接。</li>
<li>网络连接问题：可能存在与TCP连接相关的网络问题，例如路由器故障或网络故障。请检查您的网络连接，包括您的计算机和目标主机之间的任何中间路由器。</li>
<li>端口问题：如果您尝试连接的端口没有在目标主机上打开，那么TCP连接将失败。请确保您尝试连接的端口在目标主机上打开。</li>
<li>DNS问题：如果您使用主机名而不是IP地址尝试建立连接，则可能存在DNS问题。请确保您的主机名解析到正确的IP地址</li>
</ol>
<h2 id="网络层和传输层有什么区别">网络层和传输层有什么区别</h2>
<h2 id="三次握手和四次挥手最后一步分别是什么？最后一步可以去掉吗">三次握手和四次挥手最后一步分别是什么？最后一步可以去掉吗</h2>
<h2 id="ARP协议？工作机制介绍一下">ARP协议？工作机制介绍一下</h2>
<h1>JAVA</h1>
<h2 id="ArrayList与LinkedList的两者区别">ArrayList与LinkedList的两者区别</h2>
<ol>
<li>ArrayList是<strong>Array即动态数组</strong>的数据结构，LinkedList是<strong>Link(链表)双向链表</strong>的数据结构</li>
<li>ArrayList需要初始化容量为10，插入新元素的时候，会判断是否需要扩容（利用数组的复制），扩容的步长是0.5倍；LinkedList不需要初始化</li>
<li>ArrayList是线程不安全的，而LinkedList是线程安全的</li>
<li>LinkedList插入和删除的速率很快，而ArrayList的查询速度很快</li>
</ol>
<h2 id="ArrayList初始容量以及扩容机制">ArrayList初始容量以及扩容机制</h2>
<p>默认初始化容量为10，扩容倍数为1.5，java8后是懒加载，一开始不会有容量，只有往里面加元素的时候才会在堆里面创建数组的实例，<strong>即向数组中添加第一个元素时，数组容量扩为 10</strong></p>
<h2 id="定义一个变量和new一个变量的区别">定义一个变量和new一个变量的区别</h2>
<h2 id="为什么重写equals-就一定要重写hashcode-方法">为什么重写equals()就一定要重写hashcode()方法</h2>
<p>equals()源码：先比较两个字符串的地址，如果相同，则返回true，如果不同，则继续比较字符串的值，如果两个值完全相同，则返回true</p>
<p>如果两个完全相同的对象，也就是内存地址指向同一个，那他们的hashcode一定是相同的</p>
<p>答：只重写equals方法，这会导致hashcode值可能会不相同，那么这个类无法和所有集合类一起工作，在使用散列集合存储的时候就会出现问题（两个完全相同的对象，却存储在两个不同的位置）</p>
<h2 id="JAVA的锁有哪些">JAVA的锁有哪些</h2>
<h2 id="红黑树和B-树的区别">红黑树和B+树的区别</h2>
<p><img src="https://s2.loli.net/2023/02/24/yCG7QdSRosgMTeP.png" alt="image-20230224220433318"></p>
<h2 id="为什么Hashmap是扩展为红黑树而不是其他">为什么Hashmap是扩展为红黑树而不是其他</h2>
<ul>
<li>
<p>链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。</p>
</li>
<li>
<p>AVL树是一种高度平衡的二叉树，所以查找的非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多代价。每次插入、删除都要做调整，复杂、耗时。所以，hashmap用红黑树</p>
</li>
<li>
<p>如果用B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面。这个时候遍历效率就退化成了链表。</p>
</li>
</ul>
<h2 id="HashMap可以键值对同时为null吗">HashMap可以键值对同时为null吗</h2>
<p>底层：HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null值，因为key不允许重复，因此只能有一个键为null而Hashtable不行呢</p>
<p><strong>Hashtable put 方法逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashMap hash 方法逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理</p>
<p>补充：</p>
<ol>
<li>来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1</li>
</ol>
<h2 id="jdk1-8新特性">jdk1.8新特性</h2>
<h2 id="HashMap-和-Hashtable-的区别">HashMap 和 Hashtable 的区别</h2>
<p><img src="https://s2.loli.net/2023/02/23/KepzNDH9gZO2maj.png" alt="image-20230223214459539"></p>
<h2 id="ConcurrentHashMap-和-Hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别</h2>
<p><img src="https://s2.loli.net/2023/02/23/LlWczTNjIsJ1VUe.png" alt="image-20230223215518928"></p>
<h2 id="JAVA反射机制的优缺点">JAVA反射机制的优缺点</h2>
<p>可以去任意构造一个类对象，获取任意一个类的成员变量，成员方法和属性，以及调用任意一个对象方法，反射可以使得java支持动态获取程序信息以及动态调用方法的能力</p>
<p><img src="https://s2.loli.net/2023/02/24/dcxiGEh13NBPALy.png" alt="image-20230224210051829"></p>
<p><img src="https://s2.loli.net/2023/02/24/NSdGvTYH7MFUJo6.png" alt="image-20230224210105527"></p>
<h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2>
<ul>
<li>
<p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
</li>
<li>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</p>
</li>
<li>
<p><strong>引用拷贝：</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/25/MAD64ogxUvEfmGy.png" alt="image-20230225160018518"></p>
<h4 id="和-equals-的区别">== 和 equals() 的区别</h4>
<ul>
<li>
<p>对于基本数据类型来说，<code>==</code> 比较的是值。</p>
</li>
<li>
<p>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址</p>
</li>
<li>
<p><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</p>
</li>
<li>
<p><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等</p>
</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值</p>
<h4 id="为什么重写-equals-时必须重写-hashCode-方法">为什么重写 equals() 时必须重写 hashCode() 方法</h4>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<h1>数据库</h1>
<h2 id="left-join-和-right-join-的区别">left join 和 right join 的区别</h2>
<h2 id="内连接和外连接的区别">内连接和外连接的区别</h2>
<h2 id="什么情况下建立索引，什么情况不建立索引">什么情况下建立索引，什么情况不建立索引</h2>
<h2 id="Mysql存储引擎有哪些">Mysql存储引擎有哪些</h2>
<h2 id="数据库的索引对应的什么文件">数据库的索引对应的什么文件</h2>
<h2 id="为什么MySQL数据库使⽤B-树不使⽤B树">为什么MySQL数据库使⽤B+树不使⽤B树</h2>
<p>当存储同数量级的数据的时候，B+树的⾼度⽐B树的⾼度⼩，这样的话进程IO操作的次数就少，效果就⾼。因为B+树的所有⾮叶⼦节点只存索引，数据存在叶⼦节点，⼀般3层的树⾼度，即可存千万级别的数据，⽽B数不⾏</p>
<h2 id="Mysql数据库挂掉怎么备份和恢复">Mysql数据库挂掉怎么备份和恢复</h2>
<h2 id="Mysql-索引很慢，怎么排查，怎么处理">Mysql 索引很慢，怎么排查，怎么处理</h2>
<p>虽然命中索引，但SQL效率仍然慢，可能有哪些原因？</p>
<ol>
<li>索引字段重复值或者空值太多。</li>
<li>查询条件范围太广返回结果数太多，全索引扫描。</li>
<li>没有利用到覆盖索引，造成大量回表。</li>
<li>查询字段过多，并且包含大字段。</li>
<li>索引字段数据分布太随机，回表不多也会引起大量随机io。</li>
<li>统计信息不准。</li>
<li>表的单行数据值很大，需要较多io。</li>
<li>表中包含多个索引， 命中的索引不是最优的索引。</li>
</ol>
<h2 id="索引失效的场景">索引失效的场景</h2>
<p><img src="https://s2.loli.net/2023/02/26/a1SBGAW3rfKmeiw.png" alt="image-20230226101837093"></p>
<p>可能导致失效的原因：</p>
<ol>
<li>对索引字段进行了运算或者使用了函数</li>
<li>查询中的数据类型和字段类型不一致（需要进行转换的时候）</li>
<li>违反了索引的最左匹配原则</li>
<li>全表扫描更快</li>
</ol>
<h2 id="一个字段为性别，是否适合建立索引">一个字段为性别，是否适合建立索引</h2>
<p>索引分聚集索引和非聚集索引，性别字段因为可重复肯定只能建立非聚集索引，然而因为非聚集索引叶子节点存储的是索引值和聚集索引值，需要回表。所以在性别这种辨别度较低的字段上建立索引，索引树可能只有两个节点，跟线性查找没有太大区别，并且因为回表的存在导致在聚集索引树和非聚集索引树来回切换反而导致查询时间更慢。并且维护该索引还要一定的开销。另外，数据库优化器最终很大概率也不会选择走这个索引。综上，在辨别度较低的字段上建立索引得不偿失</p>
<h2 id="事务特性与隔离级别实现的基本原理">事务特性与隔离级别实现的基本原理</h2>
<h2 id="数据库索引为什么用B-树不用哈希、红黑树">数据库索引为什么用B+树不用哈希、红黑树</h2>
<p>不用二叉树：顺序插入时，会形成一个链表，查询性能大大降低，大数据量情况下，层级较深，检索速度慢（解决，使用红黑树，因为是自平衡二叉树）</p>
<p>不用红黑树：大数据量情况下，层级较深，检索速度慢</p>
<p>不用B树（多路平衡查找树）：插入时中间元素会发生向上裂变，但是缺点是每个节点会存储数据，利用不够充分</p>
<p><img src="https://s2.loli.net/2023/02/24/achAUCkrNx3EuTK.png" alt="image-20230224214811313"></p>
<p>不用hash：</p>
<p><img src="https://s2.loli.net/2023/02/24/gSEuB2awq5P4bOk.png" alt="image-20230224215420443"></p>
<p>B+树：在裂变的同时叶子节点还存有值，即所有节点都会存在于叶子节点中，并且叶子节点还有单向链表，Mysql中进行了优化，增加了一个指向相邻叶子节点的链表指针，提高了区间访问性能</p>
<p>总结：</p>
<p><img src="https://s2.loli.net/2023/02/24/JWDU6OykbZQji1u.png" alt="image-20230224215524002"></p>
<h2 id="Mysql加索引的优点和缺点">Mysql加索引的优点和缺点</h2>
<p>索引是帮助Mysql高效的从磁盘中检索数据的一种数据结构，在Mysql的InnoDB引擎里面采用的是B+树的结构来实现索引和数据的存储</p>
<p>优点：</p>
<ol>
<li>通过B+树的结构来存储数据，可以大大减少数据检索时磁盘的IO次数，从而提升数据查询的性能</li>
<li>B+树索引在进行范围查找的时候，只需要找到起始节点，然后基于叶子节点的链表结构往下读取即可，查询效率较高</li>
<li>通过唯一索引约束，可以保证数据表中每一行数据的唯一性</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据的增删改，需要涉及到索引的维护，当数据量较大的情况下，索引的维护会带来较大的性能开销</li>
<li>一个表中允许存在一个聚簇索引和多个非聚簇索引，但是索引数不能创建太多，否则造成的索引维护成本过高</li>
<li>创建索引的时候，需要考虑到索引字段值的分散性，如果字段的重复数据过多，创建索引反而会带来性能降低</li>
</ol>
<h2 id="存储的节点个数">存储的节点个数</h2>
<p><img src="https://s2.loli.net/2023/02/24/nA1kdmhj2Pu3fsv.png" alt="image-20230224215839309"></p>
<h2 id="Mysql隔离级别的实现原理">Mysql隔离级别的实现原理</h2>
<h2 id="Mysql如何分库分表">Mysql如何分库分表</h2>
<p>shardingJDBC/Mycat</p>
<h2 id="Mysql的锁">Mysql的锁</h2>
<p>全局锁</p>
<p>表级锁：</p>
<ul>
<li>表锁
<ul>
<li>表共享读锁</li>
<li>表独占写锁</li>
</ul>
</li>
<li>元数据锁：MDL，加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性</strong></li>
<li>意向锁：为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，<strong>使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</strong>
<ul>
<li>意向共享锁（IS）：意向共享锁与表读锁是兼容的，由语句<strong>select … lock in share mode</strong>添加</li>
<li>意向排它锁（IX）：意向排他锁与表读锁、写锁都是互斥的，由<strong>insert、update、delete、select…for update</strong>添加</li>
</ul>
</li>
</ul>
<p>行锁：</p>
<ul>
<li>
<p>行锁：在RC，RR级别下支持</p>
<ul>
<li>
<p>S为共享锁</p>
<p>防止不可重复读，因为当事务对数据加上共享锁后，其他事务就只能对该数据进行读操作，不能进行修改操作，因此也就避免了不可重复读的问题（不可重复读：前后两次读取的结果不一样）</p>
</li>
<li>
<p>X为排他锁</p>
</li>
</ul>
</li>
<li>
<p>间隙锁：防止产生幻读的，在RR隔离级别下支持</p>
</li>
<li>
<p>临键锁：行锁和间隙锁组合，在RR级别下支持</p>
</li>
</ul>
<p>在RR隔离级别中，innodb使用<strong>next-key锁</strong>进行搜索和索引扫描，防止幻读，定位到索引区间后，降级为<strong>间隙锁</strong></p>
<h2 id="Mysql死锁如何解决">Mysql死锁如何解决</h2>
<p><strong>产生条件：</strong></p>
<ol>
<li>互斥条件：共享资源x,y只能被一个线程占有</li>
<li>请求和保持条件：线程t1已经获得了共享资源x，在等待共享资源y的时候不释放共享资源x</li>
<li>不可抢占条件：其余线程不能去抢占线程t1已经占有的资源</li>
<li>循环等待条件：线程t1等待线程t2释放资源，线程t2也等待线程t1释放资源</li>
</ol>
<p>**原因：**死锁的关键在于：两个(或以上)的Session加锁的顺序不一致</p>
<p><strong>解决关键：</strong>（让不同的session加锁有次序），上面的条件1为特征，无法破坏，其余三点都可以外部干预进行破坏</p>
<ul>
<li>解决条件2：第一次执行的时候一次性申请所有的共享资源</li>
<li>解决条件3：如果申请不到就主动释放它占有的资源</li>
<li>解决条件4：按照顺序申请锁资源，相当于给资源一个编号</li>
</ul>
<p>**如何找到：**可以调用jstack命令，导出线程的dump日志，然后定位到具体的死锁程序代码</p>
<p><strong>如何避免：</strong></p>
<ul>
<li>事务尽可能小，不要将复杂逻辑放进一个事务里。</li>
<li>涉及多行记录时，约定不同事务以相同顺序访问。</li>
<li>业务中要及时提交或者回滚事务，可减少死锁产生的概率。</li>
<li>表要有合适的索引。</li>
<li>可尝试将隔离级别改为 RC</li>
</ul>
<h2 id="什么是覆盖索引">什么是覆盖索引</h2>
<h2 id="写sql需要注意的点，SQL调优">写sql需要注意的点，SQL调优</h2>
<ol>
<li>
<p>尽量不要用select * ，尽量覆盖索引，在二级索引下就能查到想要的</p>
</li>
<li>
<p>小表查询大表时尽量用in不要用exists</p>
</li>
<li>
<p>update的时候如果不走索引，会把行级锁升级为表级锁，这样会大大降低并发性</p>
</li>
<li>
<p>主键顺序导入：插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能，一般都让主键id自增</p>
</li>
<li>
<p>一个SQL不会操作两张表，在程序中作为参数的传递，永远单表查询</p>
</li>
<li>
<p>批量插入代替循环插入，使用batch批处理：orderMapper.insertBatch(list)</p>
</li>
<li>
<p>用limit限制返回的条数，避免内存溢出</p>
</li>
<li>
<p>当pageNo比较大的时候，查询效率变低，所以可以用上次查询的最大id或者order by的那个字段的最大值或者最小值来做一个条件的过滤</p>
</li>
<li>
<p>缩小数据集的条件要放前面</p>
</li>
</ol>
<h2 id="嵌套查询和嵌套结果的区别">嵌套查询和嵌套结果的区别</h2>
<h2 id="索引的分类">索引的分类</h2>
<p><img src="https://s2.loli.net/2023/02/24/rHYlZaomMWi8cvx.png" alt="image-20230224215556320"></p>
<p><img src="https://s2.loli.net/2023/02/24/AChFDe829wUI1Mg.png" alt="image-20230224215636648"></p>
<p>聚簇索引(Clustered Indexes)保证关键字的值相近的元组存储的物理位置也相同，且一个表只能有一个聚簇索引。字符串类型不建议使用聚簇索引，特别是随机字符串，因为它们会使系统进行大量的移动操作。并不是所有的存储引擎都支持聚簇索引，目前InnoDB支持。如果使用聚簇索引，最好使用AUTO_INCREMENT列作为主键，应该尽量避免使用随机的聚簇主键</p>
<h2 id="聊聊联合索引">聊聊联合索引</h2>
<p>多个字段组合一起作为索引，它支持最左前缀原则即最左匹配原则，</p>
<h2 id="最左匹配原则">最左匹配原则</h2>
<p>如果想使用联合索引，联合索引的最左边的列必须作为过滤条件，否则联合索引不会生效，mysql会⼀直向右匹配直⾄遇到范围查询(&gt;、&lt;、between、like)就停⽌匹配</p>
<h2 id="覆盖索引">覆盖索引</h2>
<p>不是索引结构，可以理解为是一种优化手段</p>
<p>因为在使⽤辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据</p>
<p>从辅助索引中查询得到记录，⽽不需要通过聚族索引查询获得，MySQL 中将其称为覆盖索引</p>
<p>好处：<strong>不需要查询出包含整⾏记录的所有信息，因此可以减少大量的 I/O 操作</strong></p>
<p>距离：</p>
<p>​		假设我们只需要查询商品的名称、价格信息，我们有什么⽅式来避免回表呢？我们可以建⽴⼀个组合索引，即商品编码、名称、价格作为⼀个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从⽽避免回表</p>
<h2 id="索引如何生成的">索引如何生成的</h2>
<p><img src="https://s2.loli.net/2023/02/24/HW1Uj8hqDLQ4Ez7.png" alt="image-20230224215752844"></p>
<p><img src="https://s2.loli.net/2023/02/24/GpDQY54sUzkS1dP.png" alt="image-20230224215901738"></p>
<h2 id="创建索引需要注意的点">创建索引需要注意的点</h2>
<ol>
<li>选择选择性高的，即重复度低的列创建索引，比如性别不适合而身份证号适合</li>
<li>选择经常用于查询的列创建索引</li>
<li>多表关联查询时作为关联条件的列适合创建索引</li>
<li>值会频繁变化的列不适合建索引</li>
<li>⼀张表上不要建太多的索引，太多的话会严重影响数据增删改的性能。也会耗费很⼤的磁盘空间</li>
</ol>
<h2 id="慢查询">慢查询</h2>
<p><img src="https://s2.loli.net/2023/02/26/Nkl2bneTUWYH9m6.png" alt="image-20230226101225801"></p>
<h2 id="Mysql-limit">Mysql limit</h2>
<p>limit x,y的含义是：扫描x条，然后往后扫描截取y条</p>
<h2 id="日志">日志</h2>
<p>Redo-Log保证已提交事务的持久性，undo是用于消除未提交事务的影响</p>
<p><img src="https://s2.loli.net/2023/03/01/cqUmuotCl2OP8MR.png" alt="image-20230301094518509"></p>
<p>binLog是逻辑日志，RedoLog是物理日志</p>
<h2 id="ACID">ACID</h2>
<p>原子性：undo log实现</p>
<p>持久性：redo log实现</p>
<p>隔离性：加锁以及MVCC实现</p>
<h2 id="MVCC（RC与RR）">MVCC（RC与RR）</h2>
<p><strong>重点为：版本链+undo回滚日志+对比规则</strong></p>
<p>read view中四变量：</p>
<ul>
<li>活跃事务（活跃事务就是没提交的事务）集合；</li>
<li>当前事务id</li>
<li>集合中的最小值；</li>
<li>集合中最大值的下个值</li>
</ul>
<p>当执行查询sql时会生成一致性视图read-view</p>
<p>RC隔离级别下每次select的时候都会生成新的快照读，所以第一次没提交读不到，第二次提交了，生成了新的快照读就读到了，故会出现不可重复读的问题</p>
<p>RR可重复读级别下所有的select都会使用同一个read-view</p>
<p><strong>即只读自己事物前已经commit的事物，加上自己事物未提交的事物，别人同时做的未提交操作，和后面commit事物就不读了</strong></p>
<p><img src="https://s2.loli.net/2023/03/06/byeINEqtK6JxkLa.png" alt="image-20230306155955830"></p>
<p><img src="https://s2.loli.net/2023/03/06/EUCe1o83IDbmWwa.png" alt="image-20230306152411197"></p>
<p><img src="https://s2.loli.net/2023/03/06/cGpsnlWZSKmyruI.png" alt="image-20230306152523720"></p>
<p><strong>其他任何情况都要一直递归查询undo日志，直到符合这三个条件为止</strong></p>
<p>数组中是未提交事务，外面的是当前最大的事务id（包含已提交的）</p>
<p>快照读是MVCC负责的，当前读是通过锁</p>
<p>幻读通过加间隙锁解决幻读</p>
<p>注：</p>
<ol>
<li>
<p><strong>当前读就是显式加锁的 SQL 语句（lock in share mode 或 for update）</strong><br>
例如：select * from T where id=10 for update;<br>
此外 insert update 和 delete 这些隐式加锁的语句也是使用当前读。</p>
</li>
<li>
<p><strong>没有显示加锁的查询语句就是快照读了。</strong></p>
<p>例如：select * from T where id=10;</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">杨译茗</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://boomboom-yang.github.io" target="_blank">YYM‘s Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/">面试题目整理</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/05/22/RjklgVawrtOcuPf.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/05/22/RjklgVawrtOcuPf.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.loli.net/2021/05/22/qKAvWJgRe3IQVp5.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/05/22/qKAvWJgRe3IQVp5.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/02/15/JAVA%E2%80%94%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/05/22/2KPMBkSoU3ahebr.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">杨译茗</div><div class="author-info__description">此后如竟没有炬火，我便是唯一的光</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/boomboom-yang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/boomboom-yang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2476165779@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">是我太蠢，搭这玩意儿让我快吐血！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">讲讲对Spring的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-number">1.1.1.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">1.1.2.</span> <span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP-2"><span class="toc-number">1.2.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">Spring事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.</span> <span class="toc-text">spring事务的失效场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">“#{}”和“${}”的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">BeanFactory和FactoryBean的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DI%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">DI的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Setter%E6%B3%A8%E5%85%A5"><span class="toc-number">1.7.1.</span> <span class="toc-text">Setter注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B1%9E%E6%80%A7"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">简单属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">1.7.2.</span> <span class="toc-text">构造器注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B1%9E%E6%80%A7-2"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">简单属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.3.</span> <span class="toc-text">自动配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">1.8.</span> <span class="toc-text">纯注解开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.9.</span> <span class="toc-text">Spring中Bean的作用域有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.10.</span> <span class="toc-text">将一个类声明为 Bean 的注解有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component%E5%92%8C-Bean%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">@Component和@Bean注解的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IOC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">Spring IOC的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.12.1.</span> <span class="toc-text">注入 Bean 的注解有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.</span> <span class="toc-text">@Autowired和@Resource的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E5%92%8CJDBC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">Mybatis和JDBC的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.1.</span> <span class="toc-text">JAVA运行时数据区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">什么时候会出现OOM问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.</span> <span class="toc-text">内存泄露场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.4.</span> <span class="toc-text">ThreadLocal是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">2.5.</span> <span class="toc-text">ThreadLocal带来的问题及解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.6.</span> <span class="toc-text">volatile关键字是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B7%E4%BD%93%E5%88%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%8C%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%85%B1%E4%BA%AB"><span class="toc-number">2.7.</span> <span class="toc-text">进程和线程区别，具体到上下文切换，哪些资源共享哪些不共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.8.</span> <span class="toc-text">JAVA线程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.9.</span> <span class="toc-text">JAVA线程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.10.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.11.</span> <span class="toc-text">线程通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.12.</span> <span class="toc-text">进程之间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.13.</span> <span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">2.14.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">2.14.1.</span> <span class="toc-text">CAS可能的问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.15.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.15.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">2.15.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.16.</span> <span class="toc-text">创建线程的方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.17.</span> <span class="toc-text">创建线程池的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">2.18.</span> <span class="toc-text">JVM中类加载的机制是什么样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E5%AF%BC%E8%87%B4"><span class="toc-number">2.19.</span> <span class="toc-text">JVM内存溢出有哪些场景会导致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">2.20.</span> <span class="toc-text">对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="toc-number">2.20.1.</span> <span class="toc-text">Step1:类加载检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">2.20.2.</span> <span class="toc-text">Step2:分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="toc-number">2.20.3.</span> <span class="toc-text">Step3:初始化零值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">2.20.4.</span> <span class="toc-text">Step4:设置对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step5-%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95"><span class="toc-number">2.20.5.</span> <span class="toc-text">Step5:执行 init 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1%EF%BC%88%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">2.21.</span> <span class="toc-text">如何判断对象是否死亡（两种方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.21.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.21.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">2.22.</span> <span class="toc-text">介绍强引用、软引用、弱引用、虚引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.23.</span> <span class="toc-text">虚引用的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="toc-number">2.24.</span> <span class="toc-text">如何判断一个常量是废弃常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">2.25.</span> <span class="toc-text">如何判断一个类是无用的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">2.26.</span> <span class="toc-text">垃圾收集有哪些算法，各自的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-number">2.27.</span> <span class="toc-text">HotSpot 为什么要分为新生代和老年代？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.28.</span> <span class="toc-text">常见的垃圾回收器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.29.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.30.</span> <span class="toc-text">类的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.31.</span> <span class="toc-text">对象的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.32.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.33.</span> <span class="toc-text">多线程的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">2.34.</span> <span class="toc-text">JVM调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">2.35.</span> <span class="toc-text">线程池有哪些参数，分别的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JVM%E6%8A%8A%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%8D%A2%E6%88%90%E4%BA%86%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">2.36.</span> <span class="toc-text">为什么JVM把永久代换成了元空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">三次握手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">四次挥手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2MSL"><span class="toc-number">3.3.</span> <span class="toc-text">为什么是2MSL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text">常用状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-2-3%E7%BC%BA%E9%99%B7"><span class="toc-number">3.5.</span> <span class="toc-text">HTTP1&#x2F;2&#x2F;3缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%BA%E9%99%B7"><span class="toc-number">3.5.1.</span> <span class="toc-text">HTTP缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1%E7%BC%BA%E9%99%B7"><span class="toc-number">3.5.2.</span> <span class="toc-text">HTTP1.1缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2%E7%BC%BA%E9%99%B7"><span class="toc-number">3.5.3.</span> <span class="toc-text">HTTP&#x2F;2缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">3.6.</span> <span class="toc-text">HTTP的队头阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%92%8Chttp%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.</span> <span class="toc-text">tcp和http区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%92%8Cudp%E8%83%BD%E5%90%A6%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">3.9.</span> <span class="toc-text">tcp和udp能否共用一个端口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">3.10.</span> <span class="toc-text">ping的发送和接收过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%EF%BC%8C%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%85%B6%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.11.</span> <span class="toc-text">当键入网址后，到网页显示，其间发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC-%E5%8D%8F%E8%AE%AE%E5%92%8C-HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">3.12.</span> <span class="toc-text">RPC 协议和 HTTP 协议的区别和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97"><span class="toc-number">3.13.</span> <span class="toc-text">讲一下 TCP 三次握手，两次、四次不行吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIME-WAIT-%E7%8A%B6%E6%80%81%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">3.14.</span> <span class="toc-text">TIME_WAIT 状态是做什么用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E4%B8%8BTCP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%8C%E4%BB%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%A7%92%E5%BA%A6%E8%81%8A%E8%81%8A"><span class="toc-number">3.15.</span> <span class="toc-text">网络拥塞状态下TCP数据传输，从流量控制角度聊聊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-number">3.16.</span> <span class="toc-text">https加密过程（详细）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2%E4%B8%8EHTTP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.17.</span> <span class="toc-text">HTTP&#x2F;2与HTTP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BB%86%E6%89%A3%EF%BC%89"><span class="toc-number">3.18.</span> <span class="toc-text">HTTP与HTTPS的区别（细扣）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.19.</span> <span class="toc-text">HTTP常用的状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="toc-number">3.20.</span> <span class="toc-text">三次握手为什么是三次 四次挥手为什么是四次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84"><span class="toc-number">3.21.</span> <span class="toc-text">TCP是如何保证高可靠的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping-%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%8CICMP-%E5%B1%82%E6%AC%A1"><span class="toc-number">3.22.</span> <span class="toc-text">ping 基于什么协议，ICMP 层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CTCP%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E4%BD%86%E6%98%AFping%E5%8F%AF%E4%BB%A5ping%E9%80%9A%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98"><span class="toc-number">3.23.</span> <span class="toc-text">如果TCP连接不成功，但是ping可以ping通，如何排查网络问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.24.</span> <span class="toc-text">网络层和传输层有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%8E%89%E5%90%97"><span class="toc-number">3.25.</span> <span class="toc-text">三次握手和四次挥手最后一步分别是什么？最后一步可以去掉吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">3.26.</span> <span class="toc-text">ARP协议？工作机制介绍一下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E4%B8%8ELinkedList%E7%9A%84%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">ArrayList与LinkedList的两者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">ArrayList初始容量以及扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%92%8Cnew%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">定义一个变量和new一个变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashcode-%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">为什么重写equals()就一定要重写hashcode()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E7%9A%84%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">4.5.</span> <span class="toc-text">JAVA的锁有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.</span> <span class="toc-text">红黑树和B+树的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Hashmap%E6%98%AF%E6%89%A9%E5%B1%95%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B6%E4%BB%96"><span class="toc-number">4.7.</span> <span class="toc-text">为什么Hashmap是扩展为红黑树而不是其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%8F%AF%E4%BB%A5%E9%94%AE%E5%80%BC%E5%AF%B9%E5%90%8C%E6%97%B6%E4%B8%BAnull%E5%90%97"><span class="toc-number">4.8.</span> <span class="toc-text">HashMap可以键值对同时为null吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.9.</span> <span class="toc-text">jdk1.8新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.12.</span> <span class="toc-text">JAVA反射机制的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.13.</span> <span class="toc-text">浅拷贝和深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.13.0.1.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals() 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95"><span class="toc-number">4.13.0.2.</span> <span class="toc-text">为什么重写 equals() 时必须重写 hashCode() 方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#left-join-%E5%92%8C-right-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">left join 和 right join 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">内连接和外连接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8D%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.</span> <span class="toc-text">什么情况下建立索引，什么情况不建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.4.</span> <span class="toc-text">Mysql存储引擎有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6"><span class="toc-number">5.5.</span> <span class="toc-text">数据库的索引对应的什么文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E2%BD%A4B-%E6%A0%91%E4%B8%8D%E4%BD%BF%E2%BD%A4B%E6%A0%91"><span class="toc-number">5.6.</span> <span class="toc-text">为什么MySQL数据库使⽤B+树不使⽤B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%82%E6%8E%89%E6%80%8E%E4%B9%88%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">5.7.</span> <span class="toc-text">Mysql数据库挂掉怎么备份和恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql-%E7%B4%A2%E5%BC%95%E5%BE%88%E6%85%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">5.8.</span> <span class="toc-text">Mysql 索引很慢，怎么排查，怎么处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">5.9.</span> <span class="toc-text">索引失效的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%B8%BA%E6%80%A7%E5%88%AB%EF%BC%8C%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">5.10.</span> <span class="toc-text">一个字段为性别，是否适合建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.11.</span> <span class="toc-text">事务特性与隔离级别实现的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E4%B8%8D%E7%94%A8%E5%93%88%E5%B8%8C%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">5.12.</span> <span class="toc-text">数据库索引为什么用B+树不用哈希、红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">5.13.</span> <span class="toc-text">Mysql加索引的优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">5.14.</span> <span class="toc-text">存储的节点个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.15.</span> <span class="toc-text">Mysql隔离级别的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E5%A6%82%E4%BD%95%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">5.16.</span> <span class="toc-text">Mysql如何分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E7%9A%84%E9%94%81"><span class="toc-number">5.17.</span> <span class="toc-text">Mysql的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">5.18.</span> <span class="toc-text">Mysql死锁如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">5.19.</span> <span class="toc-text">什么是覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99sql%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%8CSQL%E8%B0%83%E4%BC%98"><span class="toc-number">5.20.</span> <span class="toc-text">写sql需要注意的点，SQL调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.21.</span> <span class="toc-text">嵌套查询和嵌套结果的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.22.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">5.23.</span> <span class="toc-text">聊聊联合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">5.24.</span> <span class="toc-text">最左匹配原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">5.25.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84"><span class="toc-number">5.26.</span> <span class="toc-text">索引如何生成的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">5.27.</span> <span class="toc-text">创建索引需要注意的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.28.</span> <span class="toc-text">慢查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql-limit"><span class="toc-number">5.29.</span> <span class="toc-text">Mysql limit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">5.30.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACID"><span class="toc-number">5.31.</span> <span class="toc-text">ACID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%EF%BC%88RC%E4%B8%8ERR%EF%BC%89"><span class="toc-number">5.32.</span> <span class="toc-text">MVCC（RC与RR）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="面试问题整理"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试问题整理"/></a><div class="content"><a class="title" href="/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="面试问题整理">面试问题整理</a><time datetime="2023-03-07T10:17:37.000Z" title="发表于 2023-03-07 18:17:37">2023-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/JAVA%E2%80%94%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="无题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/02/15/JAVA%E2%80%94%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="无题">无题</a><time datetime="2023-02-15T15:22:30.630Z" title="发表于 2023-02-15 23:22:30">2023-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL基础学习笔记"><img src="https://images.unsplash.com/photo-1655438819488-69bfb10a6c21?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL基础学习笔记"/></a><div class="content"><a class="title" href="/2023/02/12/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL基础学习笔记">MySQL基础学习笔记</a><time datetime="2023-02-12T08:45:54.000Z" title="发表于 2023-02-12 16:45:54">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/" title="瑞吉外卖项目"><img src="https://cdn.stocksnap.io/img-thumbs/960w/coastal-sunset_GYJOTKPBW3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖项目"/></a><div class="content"><a class="title" href="/2023/02/12/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/" title="瑞吉外卖项目">瑞吉外卖项目</a><time datetime="2023-02-12T08:45:32.000Z" title="发表于 2023-02-12 16:45:32">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/05/SSM%E5%AD%A6%E4%B9%A0/" title="SSM学习"><img src="https://cdn.stocksnap.io/img-thumbs/960w/nature-landscape_S1W7ELWFFR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM学习"/></a><div class="content"><a class="title" href="/2023/02/05/SSM%E5%AD%A6%E4%B9%A0/" title="SSM学习">SSM学习</a><time datetime="2023-02-05T03:55:19.000Z" title="发表于 2023-02-05 11:55:19">2023-02-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 杨译茗</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,欢迎来到我的世界！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'twikoo-4g298nsce5004c8a',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'twikoo-4g298nsce5004c8a',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="6748041442" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>