<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试问题整理 | YYM‘s Blog</title><meta name="keywords" content="面试题目整理"><meta name="author" content="杨译茗"><meta name="copyright" content="杨译茗"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA jdk1.8新特性   Lamda表达式 原先比较大小： 1234567List&lt;String&gt; names &#x3D; Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);Collections.sort(names, new Comparator&lt;St">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问题整理">
<meta property="og:url" content="https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="YYM‘s Blog">
<meta property="og:description" content="JAVA jdk1.8新特性   Lamda表达式 原先比较大小： 1234567List&lt;String&gt; names &#x3D; Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);Collections.sort(names, new Comparator&lt;St">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg">
<meta property="article:published_time" content="2023-03-07T10:17:37.000Z">
<meta property="article:modified_time" content="2023-03-28T15:52:36.307Z">
<meta property="article:author" content="杨译茗">
<meta property="article:tag" content="面试题目整理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg"><link rel="shortcut icon" href="https://i.loli.net/2021/05/22/yRLpfi8dHGJktEc.png"><link rel="canonical" href="https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?df75c0fdf4d51c6436007e2cf0312f5c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试问题整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-28 23:52:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet"href="/css/icon.css"media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/05/22/2KPMBkSoU3ahebr.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-dragon"></i><span> 电影</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-spider"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YYM‘s Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-dragon"></i><span> 电影</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-spider"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试问题整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-07T10:17:37.000Z" title="发表于 2023-03-07 18:17:37">2023-03-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-28T15:52:36.307Z" title="更新于 2023-03-28 23:52:36">2023-03-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0-JAVA-%E9%9D%A2%E8%AF%95/">-学习 -JAVA -面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>133分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试问题整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>JAVA</h1>
<h2 id="jdk1-8新特性">jdk1.8新特性</h2>
<ol>
<li>
<p>Lamda表达式</p>
<p>原先比较大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>新做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简短</span></span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简短</span></span><br><span class="line"><span class="comment">//Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型</span></span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">Runnable r2 = () -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">r2.run();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">Consumer&lt;String&gt; con1 = (String s) -&gt; System.out.println(s);</span><br><span class="line">con1.accept(<span class="string">&quot;世上无难事，只怕有心人！&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">Consumer&lt;String&gt; con2 = (s) -&gt; System.out.println(s);</span><br><span class="line">con2.accept(<span class="string">&quot;世上无难事，只怕有心人！&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">Consumer&lt;String&gt; con3 = s -&gt; System.out.println(s);</span><br><span class="line">con3.accept(<span class="string">&quot;世上无难事，只怕有心人！&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(o2);</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(com2.compare(<span class="number">12</span>, <span class="number">6</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">System.out.println(com3.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Stream</p>
</li>
<li>
<p>Hashmap底层变为红黑树以及新的扩容机制</p>
</li>
<li>
<p>方法与构造函数引用</p>
<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用</p>
<p>传递方法：</p>
<p><strong>对象::实例方法名</strong></p>
<p><strong>类::静态方法名</strong></p>
<p><strong>类::实例方法名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line">PrintStream ps = System.out;</span><br><span class="line">Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">System.out.println(com2.compare(<span class="number">12</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class="line"><span class="comment">//注意：当函数式接口方法的第一个参数是需要引用方法的调用者，</span></span><br><span class="line"><span class="comment">//并且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName</span></span><br><span class="line"><span class="comment">// String中的 int t1.compareTo(t2)</span></span><br><span class="line">Comparator&lt;String&gt; com3 = String::compareTo;</span><br><span class="line">System.out.println(com3.compare(<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;abm&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">BiPredicate&lt;String, String&gt; pre2 = String::equals;</span><br><span class="line">System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名： &quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;、年龄： &quot;</span>+<span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFunction</span>&lt;<span class="title">A</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">crt</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFunction&lt;Person&gt; fun = Person::<span class="keyword">new</span>;    <span class="comment">//Person类构造方法的引用传递</span></span><br><span class="line">        System.out.println(fun.crt(<span class="string">&quot;小明&quot;</span>,<span class="number">15</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="8大基本类型">8大基本类型</h2>
<p><img src="https://s2.loli.net/2023/03/24/sxrmijaOCdc6oI7.png" alt="image-20230324162753360"></p>
<p><img src="https://s2.loli.net/2023/03/27/VrEDFKQqUpPb75a.png" alt="image-20230327231307702"></p>
<p><strong>注：封装类是引用类型</strong></p>
<h2 id="面向对象和面向过程的区别">面向对象和面向过程的区别</h2>
<p>面向过程：是分析解决问题的步骤，然后用函数把步骤一步一步的实现，在使用的时候一一调用即可，性能更高，比如单片机，嵌入式开发</p>
<p>面向对象：将问题分解成各个对象，对象是为了描述某个事物在解决整个问题的过程中所发生的行为，面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
<h2 id="装箱与拆箱">装箱与拆箱</h2>
<ul>
<li>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的<strong>valueOf(int)</strong> 方法</li>
<li>拆箱就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）；调用方法：Integer的<strong>intValue</strong>方法</li>
</ul>
<h2 id="Integer缓存是放在哪里的">Integer缓存是放在哪里的</h2>
<p>在Java中，对于Integer对象，JVM会缓存一定范围内的整数对象，这些对象被缓存在<strong>静态内部类IntegerCache</strong>中。具体来说，JVM缓存了-128到127之间的整数对象。</p>
<p>当Java程序使用自动装箱将一个int值转换为Integer对象时，如果该值在-128到127之间，JVM会直接从IntegerCache中取出已经缓存的Integer对象，而不是新创建一个对象。</p>
<h2 id="String的不可变性">String的不可变性</h2>
<h3 id="原理">原理</h3>
<ol>
<li>
<p>String类由final修饰，所以不能被继承</p>
</li>
<li>
<p>Java 9之前字符串采用char[]数组来保存字符，即 <code>private final char[] value ；</code></p>
<p>Java 9做了改进，采用byte[]数组来保存字符，即 <code>private final byte[] value ；</code></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/11/A65w3symEjOIbWZ.png" alt="image-20230311151509558"></p>
<h3 id="好处：">好处：</h3>
<ol>
<li>
<p><strong>防止被篡改，保证信息数据的安全性</strong></p>
<p>如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作</p>
</li>
<li>
<p><strong>不变的对象和值是线程安全的</strong></p>
<p>由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作</p>
</li>
<li>
<p><strong>哈希值的唯一性来挺好性能</strong></p>
<p>由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于String 的不可变，避免重复计算 hashcode ，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能</p>
</li>
<li>
<p><strong>提高常量池的可用性</strong></p>
<p>字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 <code>String.intern() </code>方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存</p>
</li>
</ol>
<h2 id="创建对象的方式">创建对象的方式</h2>
<ol>
<li>
<p>new创建新对象</p>
</li>
<li>
<p>通过反射机制</p>
<ul>
<li>
<p>通过Class字节码对象newInstance();（默认通过无参构造创建）</p>
</li>
<li>
<p>通过获取构造器getConstructor(Class&lt;?&gt;…parameterTypes);（通过有参的构造器，参数可以指定具体类型和多个数量）</p>
<p>举例：</p>
<p>用户类User：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.java.zxj.test_project;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String userId;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反射创建无参构造对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.java.zxj.test_project;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clz = Class.forName(<span class="string">&quot;test.java.zxj.test_project.User&quot;</span>);</span><br><span class="line">		Object object = clz.newInstance();</span><br><span class="line">		System.out.println(object <span class="keyword">instanceof</span> User);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建有参构造的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给User添加有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String userId;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userId, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.java.zxj.test_project;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clz = Class.forName(<span class="string">&quot;test.java.zxj.test_project.User&quot;</span>);</span><br><span class="line">		<span class="comment">//获取参数为&lt;String,String&gt;的构造器</span></span><br><span class="line">		Constructor&lt;?&gt; constructor = clz.getConstructor(String.class, String.class);</span><br><span class="line">		Object object = constructor.newInstance(<span class="string">&quot;userId_001&quot;</span>,<span class="string">&quot;name_jack&quot;</span>);</span><br><span class="line"><span class="comment">//		System.out.println(object instanceof User);</span></span><br><span class="line">		<span class="keyword">if</span> (object <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">			User user = (User)object;</span><br><span class="line">			System.out.println(<span class="string">&quot;userId:&quot;</span> + user.getUserId());</span><br><span class="line">			System.out.println(<span class="string">&quot;name:&quot;</span> + user.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>采用clone机制</p>
</li>
<li>
<p>通过序列化机制</p>
<p>需要实现<strong>java.io.Serializable</strong>接口</p>
</li>
</ol>
<h2 id="反射">反射</h2>
<h3 id="什么是反射？">什么是反射？</h3>
<p>（1）Java反射机制的核心是<strong>在程序运行时动态加载类并获取类的详细信息</strong>，从而操作类或对象的属性和方法。 本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p>
<p>（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了， 而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到， 所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性， 不需要提前在编译期知道运行的对象是谁。</p>
<p>反射：能够分析类信息（属性、方法、构造器）的能力的程序叫做反射</p>
<h3 id="获取class对象的方式：">获取class对象的方式：</h3>
<ol>
<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回class对象</li>
<li>类名.class：通过类名的class获取</li>
<li>对象.getClass()：getClass()方法在object类当中定义着</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 1.Class.forName(&quot;全类名&quot;)：</span></span><br><span class="line">       Class class1 = Class.forName(<span class="string">&quot;com.haijiao12138.demo.spring.reflection.Person&quot;</span>);</span><br><span class="line">       System.out.println(class1);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.类名.class:通过类名的class获取</span></span><br><span class="line">       Class class2 = Person.class;</span><br><span class="line">       System.out.println(class2);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.对象.getClass()</span></span><br><span class="line">       Person person = <span class="keyword">new</span> Person();</span><br><span class="line">       Class class3 = person.getClass();</span><br><span class="line">       System.out.println(class3);</span><br><span class="line">       System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">       System.out.println(class1  == class2);</span><br><span class="line">       System.out.println(class1  == class3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射获取：">反射获取：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">· <span class="number">1.</span>获取成员变量们</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span>Field[] getFields() ：获取所有<span class="keyword">public</span>修饰的成员变量</span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span>：获取指定名称的</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.Field[] <span class="title">getDeclaredFilds</span><span class="params">()</span>：获取所有的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">2.获取构造方法们</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">1.Constructor[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">2.Constructor <span class="title">getConstructor</span><span class="params">(类...parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.Constructor <span class="title">getDeclaredConstructors</span><span class="params">(类...parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.获取方法名</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">1.Method[] <span class="title">getMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">2.Method <span class="title">getMethod</span><span class="params">(String name,类... parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">3.Method[] <span class="title">getDeclaredMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.Method <span class="title">getDeclaredMethod</span><span class="params">(String name,类... parameterTypes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">4.获取类名</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="举例">举例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: haijiao12138</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Student</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/15 2:51</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haijiao12138.demo.spring.reflection1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: haijiao12138</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: CommonReflect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/8/15 2:52</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReflect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取该类的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getClassName</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Class studentClass = Student.class;</span></span><br><span class="line">        <span class="comment">//String name = studentClass.getName().;</span></span><br><span class="line">        String className = object.getClass().getSimpleName();</span><br><span class="line">        System.out.println(<span class="string">&quot;类的名字是：&quot;</span>+className);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取类的变量名称   不考虑修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getField</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员变量的名称为：&quot;</span>+fields[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取类的成员方法  所有private的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethod</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Method[] methods = object.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员方法的名称：&quot;</span>+methods[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用该类的成员方法，以get为例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAction</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取到有多少get方法</span></span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            String fieldName = fields[i].getName();</span><br><span class="line">            String fistfont = fieldName.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase();</span><br><span class="line">            String methodname = <span class="string">&quot;get&quot;</span>+fistfont+fieldName.substring(<span class="number">1</span>); <span class="comment">//get+N+name=getName; getAge  getAddress</span></span><br><span class="line">            Method method = object.getClass().getMethod(methodname);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;get的输出结果：&quot;</span>+method.invoke(object));</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object studentObject = Student.class.getConstructor(String.class,<span class="keyword">int</span>.class,String.class).newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="string">&quot;保定&quot;</span>);</span><br><span class="line">        getClassName(studentObject);<span class="comment">//类名</span></span><br><span class="line">        getField(studentObject);<span class="comment">//成员变量名</span></span><br><span class="line">        getMethod(studentObject);<span class="comment">//成员方法名</span></span><br><span class="line">        getAction(studentObject);<span class="comment">//成员变量的输出结果</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">类的名字是：Student</span><br><span class="line">成员变量的名称为：name</span><br><span class="line">成员变量的名称为：age</span><br><span class="line">成员变量的名称为：address</span><br><span class="line">成员方法的名称：setAge</span><br><span class="line">成员方法的名称：getAge</span><br><span class="line">成员方法的名称：setAddress</span><br><span class="line">成员方法的名称：getAddress</span><br><span class="line">成员方法的名称：getName</span><br><span class="line">成员方法的名称：setName</span><br><span class="line">get的输出结果：张三</span><br><span class="line">get的输出结果：20</span><br><span class="line">get的输出结果：保定</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="JAVA反射机制的优缺点">JAVA反射机制的优缺点</h2>
<p>可以去任意构造一个类对象，获取任意一个类的成员变量，成员方法和属性，以及调用任意一个对象方法，反射可以使得java支持动态获取程序信息以及动态调用方法的能力</p>
<p><img src="https://s2.loli.net/2023/02/24/dcxiGEh13NBPALy.png" alt="image-20230224210051829"></p>
<p><img src="https://s2.loli.net/2023/02/24/NSdGvTYH7MFUJo6.png" alt="image-20230224210105527"></p>
<h2 id="反射和new对象的区别">反射和new对象的区别</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45076180/article/details/117733342">Spring的IOC容器为什么用反射而不用new来创建实例？</a></p>
<ol>
<li>
<p>反射和new都是创建对象实例的，但是new对象无法调用该类里面私有private的属性，而反射可以调用类中private的属性！</p>
</li>
<li>
<p>new属于静态编译。就是在编译的时候把所有的模块都确定，如果有添加或删除某些功能，需要重新编译。但系统不可能一次就把把它设计得很完美，当发现需要更新某些功能时，采用静态编译的话，需要把整个程序重新编译一次才可以实现功能的更新。也就是说，用户需要把以前的软件卸载了，再重新安装才会重新编译！这样的系统耦合严重，难以扩展！</p>
</li>
<li>
<p>反射属于动态编译。在运行时确定类型并创建对象，通过反射指定模板，动态的向模板中传入要实例化的对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。其中spring中ioc的核心就是利用了反射解耦合。</p>
</li>
<li>
<p>反射效率较低，但经过jdk很多版本的优化，效率已经很高了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple1234&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span></span>&#123;</span><br><span class="line">        fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//工厂中使用反射！</span></span><br><span class="line">            f=(fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        fruit f=Factory.getInstance(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="try-catch-finally">try-catch-finally</h2>
<p>无论 try 中是否包含 return 语句，finally 语句块都会执行。</p>
<p>finally 语句块中的代码总是会在 try 或 catch 块中的代码执行完毕之后执行，无论 try 或 catch 中是否有 return 语句或抛出异常。这是因为 finally 语句块中的代码是一定会被执行的，它通常用于<strong>释放资源、关闭连接</strong>等必须要执行的操作。</p>
<p>当 try 或 catch 中有 return 语句时，finally 语句块中的代码会在返回之前执行。<strong>如果在 finally 语句块中也有 return 语句，那么它会覆盖之前的返回值，以 finally 中的 return 语句为准。</strong>（实际：finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的）</p>
<p>需要注意的是，在某些特殊情况下，如在 try 或 catch 块中调用了 System.exit() 方法，程序将会退出，finally 语句块中的代码不会执行。此外，如果在 try 或 catch 块中使用了 Thread.stop() 方法强制终止线程，finally 语句块中的代码同样也不会执行。这些情况下 finally 语句块中的代码不会执行，是一个例外情况。</p>
<h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/25/MAD64ogxUvEfmGy.png" alt="image-20230225160018518"></p>
<h2 id="两个不相等的对象有相同的hashcode">两个不相等的对象有相同的hashcode</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;str1：%d | str2：%d&quot;</span>,  str1.hashCode(),str2.hashCode()));</span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="和-equals-的区别">== 和 equals() 的区别</h2>
<ul>
<li>
<p>对于基本数据类型来说，<code>==</code> 比较的是值。</p>
</li>
<li>
<p>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址</p>
</li>
<li>
<p><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</p>
</li>
<li>
<p><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)</p>
</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值</p>
<h2 id="为什么重写-equals-时必须重写-hashCode-方法">为什么重写 equals() 时必须重写 hashCode() 方法</h2>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<h2 id="ArrayList与LinkedList的两者区别">ArrayList与LinkedList的两者区别</h2>
<ol>
<li>ArrayList是<strong>Array即动态数组</strong>的数据结构，LinkedList是<strong>Link(链表)双向链表</strong>的数据结构</li>
<li>ArrayList需要初始化容量为10，插入新元素的时候，会判断是否需要扩容（利用数组的复制），扩容的步长是0.5倍；LinkedList不需要初始化</li>
<li>ArrayList是线程不安全的，而LinkedList是线程安全的</li>
<li>LinkedList插入和删除的速率很快，而ArrayList的查询速度很快</li>
</ol>
<h2 id="ArrayList初始容量以及扩容机制">ArrayList初始容量以及扩容机制</h2>
<p>默认初始化容量为10，扩容倍数为1.5，java8后是懒加载，一开始不会有容量，只有往里面加元素的时候才会在堆里面创建数组的实例，<strong>即向数组中添加第一个元素时，数组容量扩为 10</strong></p>
<h2 id="HashMap-和-Hashtable-的区别">HashMap 和 Hashtable 的区别</h2>
<p><img src="https://s2.loli.net/2023/02/23/KepzNDH9gZO2maj.png" alt="image-20230223214459539"></p>
<h2 id="HashMap会出现的问题">HashMap会出现的问题</h2>
<p>可能出现的问题：</p>
<ol>
<li>jdk1.7中可能会出现链表成环的问题，所以jdk1.8改成了尾插法并且在ConcurrentHashMap对单个Node加锁实现安全并发</li>
<li>将链表转为红黑树的时候会出现死循环问题</li>
<li>put数据丢失</li>
<li>size只是用了**transient（不参与序列化）**关键字修饰,在各个线程中的size不会及时同步，在多个线程操作的时候，size将会被覆盖</li>
</ol>
<h2 id="ConcurrentHashMap-和-Hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别</h2>
<p><img src="https://s2.loli.net/2023/02/23/LlWczTNjIsJ1VUe.png" alt="image-20230223215518928"></p>
<blockquote>
<p>ConcurrentHashMap和Hashtable都是线程安全的Map实现，但是它们在加锁机制上有所不同。</p>
<p>Hashtable使用的是一种简单的方法级别的同步机制，也就是<strong>在每个方法上添加synchronized关键字</strong>，使得每个方法在被调用时都会获得一个对象级别的锁。这种机制使得多个线程不能同时访问Hashtable中的数据，因此在高并发场景下可能会存在性能问题。</p>
<p>而ConcurrentHashMap使用了一种不同的锁机制，它采用了<strong>分段锁</strong>的方式。ConcurrentHashMap中的数据结构是由多个Segment（段）组成的，<strong>每个Segment都是一个独立的Hashtable</strong>，它们各自维护自己的锁。当一个线程访问ConcurrentHashMap中的某个Segment时，只会锁定该Segment，而不会锁定整个ConcurrentHashMap，因此多个线程可以同时访问不同的Segment，从而提高了并发访问的效率。</p>
<p>另外，ConcurrentHashMap也支持读取数据时的无锁并发访问，即多个线程可以同时读取ConcurrentHashMap中的数据，而不会阻塞。</p>
<p>总之，ConcurrentHashMap的锁机制相比Hashtable更加高效，在高并发场景下表现更优秀。</p>
</blockquote>
<h2 id="HashTable的实现">HashTable的实现</h2>
<h2 id="HashSet的实现">HashSet的实现</h2>
<h2 id="为什么重写equals-就一定要重写hashcode-方法">为什么重写equals()就一定要重写hashcode()方法</h2>
<p>equals()源码：先比较两个字符串的地址，如果相同，则返回true，如果不同，则继续比较字符串的值，如果两个值完全相同，则返回true</p>
<p>如果两个完全相同的对象，也就是内存地址指向同一个，那他们的hashcode一定是相同的</p>
<p>答：只重写equals方法，这会导致hashcode值可能会不相同，那么这个类无法和所有集合类一起工作，在使用散列集合存储的时候就会出现问题（两个完全相同的对象，却存储在两个不同的位置）</p>
<h2 id="为什么Hashmap是扩展为红黑树而不是其他">为什么Hashmap是扩展为红黑树而不是其他</h2>
<ul>
<li>
<p>链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。</p>
</li>
<li>
<p>AVL树是一种高度平衡的二叉树，所以查找的稳定度非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多代价。每次插入、删除都要做调整，复杂、耗时。所以，hashmap用红黑树</p>
</li>
<li>
<p>如果用B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面。这个时候遍历效率就退化成了链表。</p>
</li>
</ul>
<h2 id="红黑树和B-树的区别">红黑树和B+树的区别</h2>
<p><strong>红黑树特征：</strong></p>
<ol>
<li>每个节点都是黑色或者红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色</li>
<li>如果一个节点是红色，那其子节点都必须是黑色</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/24/yCG7QdSRosgMTeP.png" alt="image-20230224220433318"></p>
<h2 id="HashMap可以键值对同时为null吗">HashMap可以键值对同时为null吗</h2>
<p>底层：HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null值，因为key不允许重复，因此只能有一个键为null而Hashtable不行呢</p>
<p><strong>Hashtable put 方法逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashMap hash 方法逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理</p>
<p>补充：</p>
<ol>
<li>来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1</li>
</ol>
<h1>Spring</h1>
<h2 id="讲讲对Spring的理解">讲讲对Spring的理解</h2>
<h3 id="IOC">IOC</h3>
<p>是一种设计思想，而不是一个具体的技术实现。IOC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</p>
<h3 id="AOP">AOP</h3>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如<strong>事务处理、日志管理、权限控制等</strong>）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</p>
<p>能够在已有方法，属性，代码块的基础上批量进行功能的增强</p>
<h2 id="讲讲对spring-IOC的理解">讲讲对spring IOC的理解</h2>
<p><strong>自己答：</strong></p>
<p>Spring IoC是一个轻量级的框架，它的核心思想是将对象之间的依赖关系交给容器来管理，从而实现了对象之间的松耦合，它的核心思想有两个，一个是IOC即控制反转，一个是DI即依赖注入，开发者只需要配置好对象之间的依赖关系，然后将这些对象交给Spring容器来管理，容器会负责对象的创建、销毁、依赖注入等任务。开发者无需手动创建对象，只需要从容器中获取对象即可。</p>
<p><strong>Chatgpt：</strong></p>
<blockquote>
<p>Spring IoC是一个轻量级的框架，它的核心思想是将对象之间的依赖关系交给容器来管理，从而实现了对象之间的松耦合。IoC即Inversion of Control（控制反转）和DI（Dependency Injection，依赖注入），是Spring框架的核心，是实现Spring的重要手段之一。</p>
<p>在Spring IoC中，开发者只需要配置好对象之间的依赖关系，然后将这些对象交给Spring容器来管理，容器会负责对象的创建、销毁、依赖注入等任务。开发者无需手动创建对象，只需要从容器中获取对象即可。这种方式避免了传统的耦合方式，使得开发更加灵活、方便、高效。</p>
<p>Spring IoC的实现方式包括XML配置、注解方式、Java Config方式等。通过这些方式，开发者可以将应用程序的组件（如Controller、Service、DAO等）交给Spring容器来管理，容器可以自动地将这些组件组装起来，从而实现了整个应用程序的松耦合和模块化管理。</p>
<p>总之，Spring IoC是一种通过容器来管理对象依赖关系的方式，它提供了一种灵活、方便、高效的方式来构建应用程序。</p>
</blockquote>
<h2 id="讲讲对Spring-AOP的理解">讲讲对Spring AOP的理解</h2>
<p><strong>自己答：</strong></p>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如<strong>事务处理、日志管理、权限控制等</strong>）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性，能够在已有方法，属性，代码块的基础上批量进行功能的增强</p>
<p><strong>Chatgpt:</strong></p>
<blockquote>
<p>Spring AOP（Aspect Oriented Programming，面向切面编程）是Spring框架中的一个重要组成部分，它提供了一种在不修改原有代码的情况下，通过对程序进行横向切割的方式来增强代码功能的手段。</p>
<p>AOP的核心思想是将系统的关注点（例如日志、安全性、事务等）从核心业务逻辑中分离出来，将其封装成一个切面（Aspect），然后将这个切面应用到核心业务逻辑的特定位置上，从而实现对核心业务逻辑的增强。在Spring AOP中，可以通过注解或XML配置的方式来声明切面和切入点，从而达到对系统的横向增强。</p>
<p>Spring AOP的实现方式主要依赖于动态代理(和字节码操作技术)，通过这些技术可以在运行时动态地生成代理对象，从而将切面的代码织入到目标对象中。Spring AOP支持的切面类型包括前置通知、后置通知、异常通知、环绕通知等等，这些通知可以根据需要进行组合使用，从而实现更加灵活的增强效果。</p>
<p>总之，Spring AOP是一种通过对系统关注点进行横向切割来增强代码功能的手段，它可以实现对核心业务逻辑的非侵入式增强，使得代码的可重用性、可维护性和可扩展性得到了显著提升。</p>
</blockquote>
<h2 id="讲讲对Spring-DI的理解">讲讲对Spring DI的理解</h2>
<p><strong>自己：</strong></p>
<p>依赖注入，它可以使得对象之间的依赖关系通过外部容器来管理，在传统的编程模式中，对象之间的依赖关系通常是通过new来实现的，这种方式导致对象之间的依赖关系非常紧密，代码耦合度高，而在Spring中，只需要将这些对象交给Spring容器来管理，容器会在创建对象的同时自动将依赖注入到对象中，从而实现了代码的松耦合和更高的灵活性。</p>
<p><strong>Chatgpt：</strong></p>
<blockquote>
<p>Spring DI（Dependency Injection，依赖注入）是Spring框架中的一个重要特性，它可以使得对象之间的依赖关系通过外部容器来管理，从而实现了代码的松耦合和更高的灵活性。</p>
<p>在传统的编程模式中，对象之间的依赖关系通常是通过new关键字或工厂方法来实现的，这种方式导致对象之间的依赖关系非常紧密，代码耦合度高，难以进行单元测试和重构。而在Spring DI中，开发者只需要在配置文件或代码中定义好对象之间的依赖关系，然后将这些对象交给Spring容器来管理，容器会在创建对象的同时自动将依赖注入到对象中，从而实现了对象之间的松耦合和更高的灵活性。</p>
<p>Spring DI的实现方式主要有两种：XML配置和注解配置。在XML配置中，开发者需要在配置文件中定义bean的属性，然后在应用程序中通过ApplicationContext来获取这些bean，容器会自动将这些属性注入到对象中。在注解配置中，开发者可以使用注解来定义bean和bean之间的依赖关系，然后容器会根据注解的信息来进行依赖注入。通过这些方式，Spring DI可以使得开发者的代码更加灵活、易于维护和测试，从而提高了开发效率和代码质量。</p>
<p>总之，Spring DI是一种通过外部容器来管理对象之间的依赖关系的手段，它可以实现对象之间的松耦合和更高的灵活性，从而提高了应用程序的可维护性、可测试性和可扩展性。</p>
</blockquote>
<h2 id="说下对Spring-MVC的理解">说下对Spring MVC的理解</h2>
<p>（1） 客户端发送请求，请求到达 DispatcherServlet 主控制器。<br>
（2） DispatcherServlet 控制器调用 HandlerMapping 处理。<br>
（3） HandlerMapping 负责维护请求和 Controller 组件对应关系。 HandlerMapping 根据请求调用对应的 Controller 组件处理。<br>
（4） 执行 Controller 组件的业务处理，需要访问数据库，可以调用 DAO 等组件。<br>
（5）Controller 业务方法处理完毕后，会返回一个 ModelAndView 对象。该组件封装了模型数据和视图标识。<br>
（6）Servlet 主控制器调用 ViewResolver 组件，根据 ModelAndView 信息处理。定位视图资源，生成视图响应信息。<br>
（7）控制器将响应信息给用户输出。</p>
<h2 id="AOP的具体实现">AOP的具体实现</h2>
<p>在不惊动原始设计的基础上为其进行功能增强，即无入侵式编程，<strong>可以将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统代码的重复代码和降低模块间的耦合度</strong></p>
<p>AOP有两种实现方式：静态代理和动态代理</p>
<ul>
<li>
<p>静态代理：代理类在编译阶段生成，在编译阶段将通知植入Java字节码中，也称<strong>编译时增强</strong>，AspectJ使用的是静态代理，静态代理的缺点就是代理对象需要与目标对象实现一样的接口，并且实现接口的方法会有冗余代码，同时，一旦接口增加方法，目标对象与代理对象都要维护</p>
</li>
<li>
<p>动态代理：在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类，具体来说，如果为Spring的某个bean配置的切面，那创建bean的时候，实际上创建的是这个bean的一个代理对象，后续对bean中方法的调用，实际上调用的是<strong>代理类重写的代理方法</strong>。有两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理</p>
<ul>
<li>
<p>JDK动态代理：如果目标实现了接口，SpringAOP会选择使用JDK动态代理目标类，JDK动态代理的代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口，JDK动态代理的核心是InvocationHandler接口（拦截器）和Proxy类，如果某个类没有实现接口，那这个类就不能用JDK动态代理</p>
</li>
<li>
<p>CGLib动态代理：如果目标类没有实现接口，那么AOP会选择使用CGLib来动态代理目标类，全称为Code Generation Library，可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类，CGLib是通过继承的方式实现的动态代理，因此如果某个类被标记为final，那么他是无法使用CGLib做动态代理的，CGLib的优点是目标类不需要实现特定的接口，更加灵活</p>
</li>
</ul>
</li>
</ul>
<p>连接点，切入点+通知——&gt;切面</p>
<p><img src="https://s2.loli.net/2023/02/27/fAgWX5jlR6usExo.png" alt="image-20230227210834126"></p>
<p><img src="https://s2.loli.net/2023/02/27/5wOEWZj3JHqUvat.png" alt="image-20230227211059048"></p>
<p><img src="https://s2.loli.net/2023/02/27/hvkNTAYqu6241tV.png" alt="image-20230227211109637"></p>
<h2 id=""></h2>
<h2 id="Spring-中-ApplicationContext-和-BeanFactory-的区别">Spring 中 ApplicationContext 和 BeanFactory 的区别</h2>
<p>ApplicationContext 继承了 BeanFactory，BeanFactory 是 Spring 中比较原始的Factory，它不支持 AOP、Web 等 Spring 插件，相当于是Spring框架的一个基础设施，而 ApplicationContext 不仅包含了 BeanFactory的所有功能，还提供了更多面向实际应用的功能，比如国际化以及事件机制，还以一种面向框架的方式工作以及对上下文进行分层和实现继承</p>
<h2 id="懒加载">懒加载</h2>
<p>lazy-init属性，设置为true</p>
<p>或者在SpringConfig中：@lazy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jt.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.jt.demo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.jt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的 spring 的配置问题。而 ApplicationContext 则相反，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误</p>
<h2 id="单例Bean的创建步骤">单例Bean的创建步骤</h2>
<ol>
<li>creatBeanInstance实例化，调用对象的构造方法实例化对象</li>
<li>如果是scope=singleton且允许环形依赖，添加一个getEarlyBeanReference()到第三级缓存中</li>
<li>populateBean()，填充bean引用的对象，也就是依赖注入</li>
<li>initializeBean()，在完成所有的依赖注入后，进行bean的各种后置处理，可以生成代理对象</li>
</ol>
<h2 id="Bean的生命周期">Bean的生命周期</h2>
<p><strong>构造方法 —&gt;普通对象—&gt;依赖注入—&gt;初始化前—&gt;初始化—&gt;初始化后(AOP)—&gt;放入单例池map—&gt;Bean对象</strong></p>
<p>依赖注入：给加了@Autowired注解的属性去赋值</p>
<p>单例池map：Map&lt;beanName, Bean对象&gt;</p>
<p>AOP步骤中：将代理对象的某个属性指向前面的普通对象，这样执行完代理逻辑后会执行普通对象的方法</p>
<p><img src="https://s2.loli.net/2023/03/24/gLmfskrijyU725n.png" alt=""></p>
<p><img src="https://s2.loli.net/2023/03/24/okECZtOg9VIn4bu.png" alt="image-20230324142423750"></p>
<h2 id="循环依赖">循环依赖</h2>
<p>一级缓存(SingletonObjects)：<strong>单例池，保存经过完整生命周期的Bean</strong></p>
<p>二级缓存(earlySingletonObjects)：<strong>保存出现循环依赖的Bean，方便提前给其他Bean使用的单例Bean（提前曝光）</strong></p>
<p>三级缓存(SingletonFactories)：<strong>用于打破循环，在AOP前拿到普通对象，执行lamda表达式后返回一个代理对象或者普通对象，然后放到二级缓存中，并移除lamda表达式</strong>（源码为：只要是单例Bean，并且处于循环依赖下，并且需要的Bean在创建中，就会生成lamda表达式并放入三级缓存中）</p>
<h3 id="三级缓存解决不了的场景">三级缓存解决不了的场景</h3>
<p>有参构造中</p>
<p><img src="https://s2.loli.net/2023/03/24/Q9r7D8cyXspL1qn.png" alt="image-20230324150203973"></p>
<p>解决：@lazy注解</p>
<h2 id="创建Bean实例">创建Bean实例</h2>
<p>详细讲解+举例：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46228112/article/details/124342630">Spring系列之创建bean实例的方式</a></p>
<ol>
<li>
<p>通过反射调用构造方法创建bean对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean名称&quot;</span> <span class="attr">name</span>=<span class="string">&quot;bean名称或者别名&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean的完整类型名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;n&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>constructor-arg用于指定构造方法参数的值</p>
<p>index：构造方法中参数的位置，从0开始，依次递增</p>
<p>value：指定参数的值</p>
<p>ref：当插入的值为容器内其他bean的时候，这个值为容器中对应bean的名称</p>
</blockquote>
</li>
<li>
<p>通过静态工厂方法创建bean对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean名称&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;静态工厂完整类名&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;静态工厂的方法&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;n&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过工厂静态无参方法创建bean对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;createBeanByStaticFactoryMethod1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javacode2018.lesson001.demo3.UserStaticFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;buildUser1&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 通过工厂静态有参方法创建bean对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;createBeanByStaticFactoryMethod2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javacode2018.lesson001.demo3.UserStaticFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;buildUser2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;通过工厂静态有参方法创建UerModel实例对象&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过实例工厂方法创建bean对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean名称&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;需要调用的实例对象bean名称&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;bean对象中的方法&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;n&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bean的值&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的bean名称&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过FactoryBean创建bean对象</p>
</li>
</ol>
<h2 id="Spring中实现数据库事务的方法">Spring中实现数据库事务的方法</h2>
<ol>
<li>
<p>声明式事务管理</p>
<p>使用Spring的声明式事务管理，通过在XML或注解中配置事务属性，可以将数据库事务的控制从业务代码中分离出来。在Spring中，声明式事务管理有两种实现方式：</p>
<ul>
<li>**基于XML的声明式事务管理：**通过配置XML文件中的AOP切面和事务属性，来实现声明式事务管理。</li>
<li>**基于注解的声明式事务管理：**通过使用@Transactional注解，在业务方法上声明事务属性，来实现声明式事务管理。</li>
</ul>
</li>
<li>
<p>编程式事务管理</p>
<p>在Spring中，通过编写代码来实现事务控制也是一种常见的事务管理方式，这种方式称为编程式事务管理。在编程式事务管理中，业务代码需要显式地调用事务管理器的API，来开启、提交或回滚事务。</p>
</li>
</ol>
<h2 id="Transactional具体实现原理">@Transactional具体实现原理</h2>
<p>@Transactional是一个注解，通常用于在Spring框架中处理事务。它可以应用于类或方法级别，并指示Spring在执行受注解标记的方法或类的操作时开启一个事务。如果方法或类内部存在多个数据操作，Spring会将这些操作作为一个单元来处理，并将它们视为一个整体，如果整体操作成功，则提交整个事务，否则回滚整个事务。</p>
<p>@Transactional的具体实现原理可以概括为以下几个步骤：</p>
<ol>
<li>首先，Spring会检查当前线程是否已经存在一个事务。如果不存在，它将创建一个新的事务。</li>
<li>接下来，Spring将在事务管理器中开启一个新的事务。</li>
<li>在执行受@Transactional标记的方法或类的操作之前，Spring会在当前线程中存储事务状态。这个状态包括事务的隔离级别、超时时间和只读属性等信息。</li>
<li>当受@Transactional标记的方法或类的操作完成时，Spring会检查操作是否成功。如果成功，它将提交事务，否则将回滚事务。</li>
<li>最后，Spring将恢复存储在当前线程中的事务状态，并关闭事务。</li>
</ol>
<p>总之，@Transactional的具体实现原理就是通过将所有的数据操作作为一个整体来处理，以保证整个事务的一致性和完整性。如果其中任何一个操作失败，整个事务都会被回滚，以确保数据的正确性。</p>
<h2 id="黑马Spring事务实现">黑马Spring事务实现</h2>
<p>三步：</p>
<p><img src="https://s2.loli.net/2023/02/27/z8RwDFpUWo3CX4T.png" alt="image-20230227212149992"></p>
<p>②设置事务管理器</p>
<p><img src="https://s2.loli.net/2023/02/27/EVohKeBqst8y4L9.png" alt=""></p>
<p>③开启注解式事务驱动</p>
<p><img src="https://s2.loli.net/2023/02/27/flvdZTyRtQFOuN6.png" alt="image-20230227211918009"></p>
<p>@Transactional一般放在接口里不放在实现类里，为了降低耦合</p>
<h2 id="spring事务的失效场景">spring事务的失效场景</h2>
<ol>
<li>
<p>事务方法访问修饰符非public，导致事务失效</p>
<p>如果事务是static、final的，同样无法通过动态代理，事务也是不会生效的</p>
</li>
<li>
<p>@Transactional注解的方法抛出的异常不是spring的事务支持的异常，导致事务失效</p>
</li>
<li>
<p>数据表本身是不支持事务，导致事务失效，如MyISAM</p>
</li>
<li>
<p>@Transactional注解所在的类没有被spring管理，导致事务失效</p>
</li>
<li>
<p>多线程调用，导致事务失效</p>
</li>
</ol>
<h2 id="事务的传播级别">事务的传播级别</h2>
<p>默认为：Propagation_required</p>
<p><img src="https://s2.loli.net/2023/03/24/3gVJKtQPrMROu6Z.png" alt="image-20230324150808482"></p>
<h2 id="自动装配原理">自动装配原理</h2>
<h2 id="“-”和“-”的区别">“#{}”和“${}”的区别</h2>
<p>答：都是Mybatis里面提供的两种实现动态SQL的方式，可以把参数传递到XML里面，#等同于JDBC里面的“？”占位符，PreparedStatement，“#”可以防止SQL注入，属于动态参数，，适合于动态传递表名，动态设置排序字段，而使用“$”相当于直接把参数拼接到了原式SQL里面，Mybatis不会对它进行任何的特殊处理</p>
<blockquote>
<p>#{}将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如果传入的值是1111,那么解析成sql时的值为 “1111”, 如果传入的值是id，则传入 “id”.</p>
<p>${} 则只是简单的字符串替换，在动态解析阶段，该 sql 语句会直接将变量值替换进去，这样就有可能会发生sql注入的风险。</p>
<p>${}将传入的数据直接替换，如果传入的值是1111,那么解析成sql时的值为 1111, 如果传入的值是id，则传入 id</p>
</blockquote>
<p><strong>在传入关键字时，不可以使用#{}，在传入普通字符串时，不可以使用${}</strong></p>
<h2 id="BeanFactory和FactoryBean的区别">BeanFactory和FactoryBean的区别</h2>
<p>答：BeanFactory是一个Factory，是IOC容器的顶级接口，是IOC容器最基础的实现，同时也是访问Spring容器的根接口，主要是负责Bean的创建和访问，里面有一个getBean方法，同时BeanFactory还能完成对Bean的依赖注入的功能，即DI</p>
<p>FactoryBean是一个特殊的Bean，是一个工厂Bean，如果配置了FactoryBean接口，那就可以通过不同的配置类，去返回不同类型的Bean，一个比较核心的方法是getObject。如果要使用Bean工厂，可以手动实现一个实现FactoryBean接口的一个类。</p>
<p>通过getObject方法返回一个对象，当用户使用容器本身时，可以使用转义字符<code>”&amp;”</code>来得到FactoryBean本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身，如果beanName没有加&amp;，则获取的是泛型T的对象，如果加了&amp;，获取的是实现了FactoryBean接口本身的对象</p>
<p><img src="https://s2.loli.net/2023/02/19/gYbyu1kczq8DGI7.png" alt="image-20230219155355502"></p>
<p>FactoryBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建好的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回需要创建的对象的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * bean是否是单例的</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DI的方式">DI的方式</h2>
<h3 id="Setter注入">Setter注入</h3>
<h4 id="引用类型">引用类型</h4>
<p>property标签，name属性+ref属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单属性">简单属性</h4>
<p>property标签，name属性+value属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造器注入">构造器注入</h3>
<h4 id="引用类型-2">引用类型</h4>
<p>constructor-arg标签，name属性+ref属性</p>
<p>其中name是构造器的形参，所以耦合度较高</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="简单属性-2">简单属性</h4>
<p>constructor-arg标签，name属性+value属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自动配置">自动配置</h3>
<ul>
<li>==按类型（常用）==：要求类型匹配必须唯一</li>
<li>按名称</li>
<li><img src="https://s2.loli.net/2023/02/27/rfscMWoCx4HjmSn.png" alt="image-20230227204257803"></li>
</ul>
<h2 id="纯注解开发">纯注解开发</h2>
<p>新建一个config包下的SpringConfig，这样就不用配置了，然后加上@Configuration，再写上@ComponentScan</p>
<p><img src="https://s2.loli.net/2023/02/27/HDKvaVkbyATXoNx.png" alt="image-20230227204844510"></p>
<p>然后换为注解开发加载配置类：</p>
<p><img src="https://s2.loli.net/2023/02/27/sVH4yKon73DMXO5.png" alt="image-20230227204919629"></p>
<p><img src="https://s2.loli.net/2023/02/27/xnrgtjTJBGquAf7.png" alt="image-20230227204949788"></p>
<p>在类中比如BookDaoImpl加上@Component，等价于<bean></p>
<p><img src="https://s2.loli.net/2023/02/27/7VmpXDKyAzxrvfC.png" alt="image-20230227205137500"></p>
<p>如果有多个相同类型的Bean，则：</p>
<p>@Autowired：使用暴力反射，故无需setter方法</p>
<p>@Qualifier(“Bean名称”)</p>
<p>如果是简单类型注入，则@Value</p>
<p>如果是外部properties注入，则先把SpringConfig加上@PropertySource(“jdbc.properties”)，然后改为@Value(“${name}”)，即可把properties里面的name注入</p>
<h2 id="Spring中Bean的作用域有哪些">Spring中Bean的作用域有哪些</h2>
<ol>
<li>Spring 中 Bean 的作用域通常有下面几种：
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean</li>
</ul>
</li>
</ol>
<h2 id="将一个类声明为-Bean-的注解有哪些">将一个类声明为 Bean 的注解有哪些?</h2>
<p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要<strong>想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类</strong>,可以采用以下注解实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
<h2 id="Component和-Bean注解的区别">@Component和@Bean注解的区别</h2>
<p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p>
<blockquote>
<p>@Bean表示当前方法返回值是一个bean（黑马），一般用于管理第三方Bean，然后用@Import注解手动加入配置类到核心配置</p>
</blockquote>
<p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p>
<p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p>
<h2 id="Boot注解">Boot注解</h2>
<h3 id="SpringBootConfiguration-注解">@SpringBootConfiguration 注解</h3>
<p>这个注解我们点进去就可以发现，它实际上就是一个 @Configuration 注解，这个注解大家应该很熟悉了，加上这个注解就是为了让当前类作为一个配置类交由 Spring 的 IOC 容器进行管理</p>
<p><strong>@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan</strong></p>
<h3 id="ComponentScan-注解">@ComponentScan 注解</h3>
<p>这个注解也很熟悉，用于定义 Spring 的扫描路径，等价于在 xml 文件中配置 context:component-scan，假如不配置扫描路径，那么 Spring 就会默认扫描当前类所在的包及其子包中的所有标注了 @Component，@Service，@Controller 等注解的类</p>
<h2 id="Spring-IOC的工作流程">Spring IOC的工作流程</h2>
<p>IOC全称为Inversion of control，即控制反转，核心思想是把对象的管理权限交给了容器，好处是降低了对象与对象之间的耦合性</p>
<p><img src="https://s2.loli.net/2023/02/20/npTWvUomzHVul5t.png" alt="image-20230220185143785"></p>
<blockquote>
<p>声明Bean的方式：</p>
<ol>
<li>xml文件中使用<bean></li>
<li>@Service/@Repository/@Component</li>
<li>@Configuration-@Bean(在Configuration配置类里面通过Bean注解去声明)</li>
</ol>
<p>Spring在启动的时候会解析这些Bean，然后保存到IOC容器里面</p>
</blockquote>
<p>IOC的工作流程：</p>
<ol>
<li><strong>IOC容器的初始化阶段</strong>：通过解析和加载后生成的BeanDefinition，然后将BeanDefinition注册到IOC容器里面，把BeanDefinition保存到一个Map集合里面</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/zIx5vlCdG7O3XLb.png" alt="image-20230220191350435"></p>
<ol start="2">
<li><strong>完成Bean的初始化和依赖注入</strong>：会完成两个事情，第一个是通过反射去针对没有设置lazy-init属性的单例bean进行初始化，第二个是完成bean的依赖注入</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/X4nriPvkWbZI3dg.png" alt="image-20230220191642673"></p>
<p><strong>Bean的使用</strong>：通过BeanFactory.getBean()或者@Autowired</p>
<p><img src="https://s2.loli.net/2023/02/20/954EgFj8wWmeCUt.png" alt="image-20230220191810758"></p>
<h3 id="注入-Bean-的注解有哪些？">注入 Bean 的注解有哪些？</h3>
<p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="Autowired和-Resource的区别">@Autowired和@Resource的区别</h2>
<p><img src="https://s2.loli.net/2023/02/22/bYGiImM8p279zaj.png" alt="image-20230222181632905"></p>
<p>@AutoWired先根据属性的类型去Spring容器中找Bean对象，如果找到多个，就会根据名字去确定其中一个，如果根据名字没有找到则会报错；@Resouce会先根据名字取Spring容器中找Bean对象，如果没有则会按照属性，如果还没有则会报错，另外，可以指定@Resouce的name，如果配置了name，则只会找到这个叫name的Bean对象，如果没有找到，就会直接报错，不会再根据类型去找了，@AutoWired是Spring层面提供的，是和Spring强绑定的，@Resouce是JDK层面提供的</p>
<h2 id="Mybatis和JDBC的区别">Mybatis和JDBC的区别</h2>
<ol>
<li>内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高</li>
<li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li>
</ol>
<h2 id="JDBC操作数据库">JDBC操作数据库</h2>
<ol>
<li>
<p>装载加载JDBC驱动并进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>建立数据库连接，获得 Connection 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据用户的输入组装查询 SQL 语句</p>
</li>
<li>
<p>根据 SQL 语句建立 Statement 对象 或者 PreparedStatement 对象</p>
</li>
<li>
<p>用 Connection 对象执行 SQL语句，获得结果集 ResultSet 对象。</p>
</li>
<li>
<p>处理和显示结果</p>
<ul>
<li>
<p>一条一条读取结果集 ResultSet 对象中的数据。</p>
</li>
<li>
<p>根据读取到的数据，按特定的业务逻辑进行计算。</p>
</li>
<li>
<p>根据计算得到的结果再组装更新 SQL 语句。</p>
</li>
<li>
<p>再使用 Connection 对象执行更新 SQL 语句，以更新数据库中的数据。</p>
</li>
</ul>
</li>
<li>
<p>释放资源，依次关闭各个 Statement 对象和 Connection 对象</p>
</li>
</ol>
<h2 id="MyBatis新建一个查询要做那些事情？">MyBatis新建一个查询要做那些事情？</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58342797/article/details/127324984">MyBatis基本操作_mybatis 查询表结构_</a></p>
<ol>
<li>
<p>查看表结构</p>
</li>
<li>
<p>根据表结构，创建对应类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> class_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span><span class="comment">//让这个接口被MyBatis框架接收、</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectByIdMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;<span class="comment">//根据id获取Student对象</span></span><br><span class="line"><span class="comment">//Param 表示在xml中对应获取的参数名称也是id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>xml文件实现接口的方法（这个文件的命名，和配置文件保持一致）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.example.demo.Mapper.SelectByIdMapper&quot;</span>&gt;</span><br><span class="line">&lt;!--&gt;namespace 绑定xml文件实现的接口 包名+类名  &lt;--&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;select id=<span class="string">&quot;getStudentById&quot;</span> resultType=<span class="string">&quot;com.example.demo.Model.Student&quot;</span>&gt;</span><br><span class="line">&lt;!--        这个id，表示实现StudentMapper接口的哪一个方法--&gt;</span><br><span class="line">&lt;!--        resultType 表示方法的返回类型--&gt;</span><br><span class="line"> </span><br><span class="line">        select * from student where id=$&#123;id&#125;</span><br><span class="line">&lt;!--        这里写具体的执行语句--&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol start="5">
<li>
<p><strong>Controll层，接收前端数据，调用Service层处理业务逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentControl</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//属性注入</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getstudentbyid&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudentById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> studentService.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Service层：处理业务逻辑，调用数据库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService &#123;</span><br><span class="line">    //使用StudentMapper对象 属性注入</span><br><span class="line">    @Autowired</span><br><span class="line">    private SelectByIdMapper selectByIdMapper;</span><br><span class="line"> </span><br><span class="line">    public Student getStudentById(Integer id) &#123;</span><br><span class="line">        return selectByIdMapper.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Mapper层：执行数据库操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span><span class="comment">//让这个接口被MyBatis框架接收、</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectByIdMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;<span class="comment">//根据id获取Student对象</span></span><br><span class="line"><span class="comment">//Param 表示在xml中对应获取的参数名称也是id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Spring和SpringBoot的区别">Spring和SpringBoot的区别</h2>
<p>SpringBoot优点：</p>
<ol>
<li>
<p>独立运行</p>
<p>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内</p>
</li>
<li>
<p>简化配置</p>
<p>spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置</p>
</li>
<li>
<p>自动配置</p>
<p>Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starterweb启动器就能拥有web的功能，无需其他配置</p>
</li>
<li>
<p>无需XML配置（通过注解即可）</p>
<p><strong>@SpringBootApplication</strong></p>
<ul>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能</li>
<li>@EnableAutoConfiguration：自动配置</li>
<li>@ComponentScan：Spring组件扫描</li>
</ul>
</li>
</ol>
<h2 id="工厂模式举例">工厂模式举例</h2>
<img src="https://s2.loli.net/2023/03/23/gQbBt9vZCYJyMEX.png" alt="image-20230323230856964" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/JeAoBz9OWIRmTap.png" alt="image-20230323230904083" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/iuoR94sgzx5vED2.png" alt="image-20230323230911265" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/gUyOabKxIufjERN.png" alt="image-20230323230919429" style="zoom:67%;" />
<img src="https://s2.loli.net/2023/03/23/RwoE1Vl9cY2QDuG.png" alt="image-20230323231006771" style="zoom:67%;" />
<h2 id="Log4j的4个级别">Log4j的4个级别</h2>
<p>优先级从高到低分别是ERROR、WARN、INFO、DEBUG</p>
<ol>
<li>DEBUG 指定细粒度信息事件是最有用的应用程序调试，一般使用log.debug()进行跟踪调试</li>
<li>INFO 指定能够突出在粗粒度级别的应用程序运行情况的信息的消息，就是输出提示信息。info级别监控系统运行情况，可以帮助程序员有效的了解程序的流转</li>
<li>WARN 指定具有潜在危害的情况，一般很少使用</li>
<li>ERROR  错误事件可能仍然允许应用程序继续运行。就是显示错误信息。比如接口访问超时，用try/catch 捕获异常，发生异常的时候log.error输出错误信息，并不影响程序的运行</li>
</ol>
<h1>JVM</h1>
<h2 id="为什么要在虚拟机中运行">为什么要在虚拟机中运行</h2>
<ol>
<li>
<p>JVM提供了<strong>跨平台</strong>的特性</p>
<p>通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，即 Java 字节码，实现**“一次编写，到处运行”**。</p>
</li>
<li>
<p>JVM提供了<strong>自动内存管理与垃圾回收</strong>的能力</p>
<p>带来了一个托管环境，能够代替我们处理一些代码中冗长而且容易出错的部分</p>
</li>
<li>
<p>JVM提供了诸如数组越界、动态类型、安全权限等的<strong>动态检测能力</strong></p>
<p>可以免于书写这些无关业务逻辑的代码</p>
</li>
</ol>
<h2 id="同步和异步的区别">同步和异步的区别</h2>
<p>同步：你执行了我再执行。</p>
<p>异步：你不执行我先跳过，等你执行了我再执行</p>
<blockquote>
<p>同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。</p>
<p>异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。</p>
</blockquote>
<p><strong>同步的好处：</strong></p>
<ol>
<li>同步流程对结果处理通常更为简单，可以就近处理。</li>
<li>同步流程对结果的处理始终和前文保持在一个上下文内。</li>
<li>同步流程可以很容易捕获、处理异常。</li>
<li>同步流程是最天然的控制过程顺序执行的方式。</li>
</ol>
<p><strong>异步的好处：</strong></p>
<ol>
<li>异步流程可以立即给调用方返回初步的结果。</li>
<li>异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。</li>
<li>异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。</li>
<li>异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。</li>
</ol>
<h2 id="并发和并行的区别">并发和并行的区别</h2>
<img src="https://s2.loli.net/2023/03/08/uVQWge2iH8ZxBca.png" alt="image-20230308223900844" style="zoom: 67%;" />
<h2 id="JAVA运行时数据区域">JAVA运行时数据区域</h2>
<ol>
<li>堆：存放对象实例，分为新生代和老年代，其中新⽣代又分为Eden区，From Survivor和To Survivor区，⽐例是8:1:1</li>
<li>方法区：存储已经被虚拟机加载的类信息，常量，静态变量（永久代，jkd1.8后改为元空间）</li>
<li>虚拟机栈：局部变量表，操作数栈，动态链接，方法返回地址</li>
<li>程序计数器：保存下一条需要执行的字节码指令（可以为空）</li>
<li>本地方法栈：与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</li>
</ol>
<ul>
<li>
<p><strong>成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</strong></p>
<ul>
<li>要想在该方法中使用成员变量，必须使用关键字this</li>
</ul>
</li>
<li>
<p><strong>静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;类体重定义的name&quot;</span>;			<span class="comment">//类中的成员变量并赋值</span></span><br><span class="line"> </span><br><span class="line">	People()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;类体方法中定义的name&quot;</span>;		<span class="comment">//在方法speak中定义和成员变量名字相同的name并赋值</span></span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name);		<span class="comment">//通过this来访问类中的成员变量</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThis</span> </span>&#123;                              <span class="comment">//源文件中只能有一个类是public类，并且源文件的名字必须与这个类的名字完全相同，如                                                      //果没有public类，那么源文件的名字只要和某个类的名字相同就可以了。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;       </span><br><span class="line">		People myPeople = <span class="keyword">new</span> People();</span><br><span class="line">		myPeople.speak();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/02/28/rFUx1wWBl7YkO6A.png" alt="image-20230228161331502"></p>
<p><img src="https://s2.loli.net/2023/02/28/u2UX19jkl6TsEnF.png" alt="image-20230228161317419"></p>
<p><img src="https://s2.loli.net/2023/03/01/Ljd57vMagfht6xu.png" alt="image-20230301144634000"></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1714914983791082793&amp;wfr=spider&amp;for=pc">运行时数据区 (baidu.com)</a></p>
<h2 id="什么时候会出现OOM问题">什么时候会出现OOM问题</h2>
<p>除了程序计数器不会产⽣OOM，其余的均可以产⽣OOM</p>
<p>方法区 OOM：</p>
<p>1、 加载大量的第三方的jar包</p>
<p>2、Tomcat部署的工程过多（30~50个）</p>
<p>3、<strong>大量动态的生成反射类</strong></p>
<h2 id="为什么JVM把永久代换成了元空间">为什么JVM把永久代换成了元空间</h2>
<ol>
<li>在1.7版本中永久代内存是有上限的，虽然可以通过参数设置上限，但是JVM加载的class总数大小是很难去确定的，所以很容易出现OOM的问题，而元空间是存储在本地内存里面，内存上限比较大，可以很好的避免这个问题</li>
<li>永久代的对象是利用FullGC来垃圾回收的，即和老年代同时进行垃圾回收，替换成元空间后简化了FullGC的过程，即有各种垃圾回收算法，可以在不暂停的情况下去并发的释放类的数据，同时也提升了GC的性能</li>
<li>Oracal要合并Hotspot和JRockit的代码，而JRockit中没有永久代</li>
</ol>
<h2 id="方法区放的什么，堆放什么，静态变量放哪，栈放什么">方法区放的什么，堆放什么，静态变量放哪，栈放什么</h2>
<p>在<strong>方法区</strong>中，主要存放以下内容：</p>
<ol>
<li>
<p><strong>类型信息</strong>（Type Information）：每个类在JVM中都有一个对应的Class对象，该对象包含了该<strong>类的类型信息</strong>，如<strong>类名、父类、接口、字段、方法</strong>等信息。</p>
</li>
<li>
<p><strong>运行时常量池</strong>（Runtime Constant Pool）：在编译Java代码时，编译器会将所有的<strong>字面量和符号引用</strong>都存储到该区域中，包括<strong>字符串常量、类和方法名、字段名、接口名</strong>等。</p>
</li>
<li>
<p><strong>静态变量</strong>（Static Variables）：静态变量是类变量，它们的生命周期与类的生命周期相同，存储在方法区中。</p>
</li>
<li>
<p><strong>方法信息</strong>（Method Information）：存储类中的方法信息，包括<strong>方法的字节码、访问修饰符、返回值类型、参数类型</strong>等。</p>
<hr>
</li>
<li>
<p><strong>运行时内存布局</strong>（Memory Layout）：存储类的成员变量和方法的访问信息，包括方法表（Virtual Method Table，即VMT）和字段表（Field Table）等。</p>
</li>
</ol>
<hr>
<p><strong>堆</strong>主要存放以下内容：</p>
<ol>
<li><strong>对象实例</strong>（Object Instances）：Java中所有的<strong>对象实例</strong>都是在堆上创建的，<strong>对象的实例变量</strong>也存储在堆上。</li>
<li><strong>数组</strong>（Arrays）：Java中的数组也是对象，数组元素的实例变量也存储在堆上。</li>
<li><strong>堆栈帧</strong>（Stack Frames）：每个线程在调用方法时都会创建一个堆栈帧，该帧存储方法的局部变量、操作数栈、方法出口等信息。</li>
</ol>
<p>需要注意的是，在堆中存储的对象实例是可被垃圾回收器回收的，当对象不再被引用时，垃圾回收器会回收该对象所占用的内存空间。此外，堆还分为新生代和老年代，新生代又分为Eden区和两个Survivor区，不同的对象在不同的区域中创建和存储，以达到更好的垃圾回收性能和效率。</p>
<hr>
<p><strong>栈</strong>主要存放以下内容：</p>
<ol>
<li><strong>方法调用</strong>（Method Invocation）：每个方法在被调用时都会创建一个栈帧，栈帧中存储了该方法的参数、局部变量、返回地址等信息。当方法执行完毕后，该栈帧会被弹出，恢复到调用该方法的上一级栈帧。</li>
<li><strong>局部变量</strong>（Local Variables）：每个栈帧中都包含了该方法的局部变量，这些局部变量只在该方法执行期间可见。</li>
<li><strong>操作数栈</strong>（Operand Stack）：每个栈帧中都包含了一个操作数栈，用于存储方法执行时的操作数和结果，例如算术运算、逻辑运算等。</li>
</ol>
<p>需要注意的是，栈中存储的数据是基本数据类型和对象引用，而不是对象本身。当一个方法被调用时，JVM会为该方法创建一个新的栈帧，并将该栈帧压入当前线程的栈顶。当方法执行完毕后，该栈帧会被弹出，恢复到调用该方法的上一级栈帧。</p>
<p>栈的大小是有限制的，当栈空间不足时会抛出栈溢出（StackOverflow）异常。</p>
<h2 id="常量池-运行时常量池-字符串常量池">常量池&amp;运行时常量池&amp;字符串常量池</h2>
<p>详细讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/123150212">JVM常量池、Class常量池、运行时常量池、字符串常量池</a></p>
<h3 id="常量池">常量池</h3>
<p>也叫Class常量池(<strong>常量池==Class常量池</strong>)。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区 <strong>各种字面量</strong> (Literal)和 <strong>符号引用</strong> 。（<strong>类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符</strong>）</p>
<img src="https://s2.loli.net/2023/03/22/cRpZ4s5hHPGvoaj.png" alt="image-20230322155514612" style="zoom:67%;" />
<p>举例：</p>
<p><img src="https://s2.loli.net/2023/03/26/3rqvFWTDHdyRS9C.png" alt="image-20230326133812533"></p>
<p>后面的 <strong>#4.#25</strong> 分别表示 <code>class_index</code> 和 <code>name_and_type_index</code> ，这两个都是常量池下标（即所在类结构在常量池的下标和字段名与字段类型在常量池的下标），引用着另外两个常量池项。顺着这个方法把所有引用的常量都找出来</p>
<p>方法举例：</p>
<p><img src="https://s2.loli.net/2023/03/26/Vu64qxME8vIzAiJ.png" alt="image-20230326134826422"></p>
<p><img src="https://s2.loli.net/2023/03/26/ZN7lXypASBuxjiF.png" alt="image-20230326134759567"></p>
<p>在刚加载好一个类的时候，<code>Class</code> 文件里的常量池和每个方法的字节码（Code属性）会被基本原样的拷贝到内存里先放着，也就是说仍然处于使用 “符号引用” 的状态，直到真的要被使用到的时候才会被解析（resolve）为直接引用</p>
<p><strong>直接引用是运行时所能直接使用的形式，即可以表现为直接指针</strong></p>
<p>举例：</p>
<p><img src="https://s2.loli.net/2023/03/26/3aW7Snkvwbe1IQz.png" alt="image-20230326135035024"></p>
<h3 id="Jvm中多态的体现：">Jvm中多态的体现：</h3>
<p><img src="https://s2.loli.net/2023/03/26/PDgwFVlxao1uXh8.png" alt="image-20230326135241107"></p>
<h3 id="运行时常量池">运行时常量池</h3>
<h2 id="JVM中类加载的机制是什么样的">JVM中类加载的机制是什么样的</h2>
<p>JVM中的类加载机制是一种基于双亲委派模型的机制，系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。在加载阶段，JVM会查找并加载指定的类文件；在验证阶段，JVM会验证类文件的正确性；在准备阶段，JVM会为类变量分配内存并设置类变量的初始值。</p>
<p><img src="https://s2.loli.net/2023/02/26/yav87xXSqZUIfsD.png" alt="image-20230226161425883"></p>
<h2 id="JVM内存溢出有哪些场景会导致">JVM内存溢出有哪些场景会导致</h2>
<ol>
<li>
<p>在JVM中，当 Java 堆内存用完时会导致内存溢出。</p>
</li>
<li>
<p>另一种情况是，程序中存在大量循环引用，导致无法被 Java 垃圾回收器回收，从而导致内存溢出。</p>
</li>
<li>
<p>同样，JVM 栈中的局部变量消耗太多的内存也会导致内存溢出。</p>
</li>
<li>
<p>在 JVM 运行时，虚拟机配置的内存大小比需求的大小要小，也会导致内存溢出。</p>
</li>
<li>
<h2 id="类的生命周期">类的生命周期</h2>
<p><img src="https://s2.loli.net/2023/02/23/fmYEjcO83WFhlLG.png" alt="image-20230223095349477"></p>
<h2 id="类的加载过程">类的加载过程</h2>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong></p>
<p>​	jdk 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的</p>
<p><strong>加载：</strong></p>
<ol>
<li>将 class 文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</li>
</ol>
<p>验证：文件格式，元数据，字节码，符号引用，确保加载的类符合 JVM 规范和安全</p>
<p>**准备：**为类变量分配内存并且设置类变量初始值</p>
<p>​	为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</p>
<p>**解析：**虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<blockquote>
<p>在Java语言中，符号引用（Symbolic Reference）指的是一种使用符号名称来标识一个类、接口、字段或方法的方式。与C语言类似，Java中的符号引用也是在编译时或运行时解析的。符号引用是Java虚拟机（JVM）使用的一种内部数据结构，用于定位并加载类或接口，并访问字段或方法。</p>
<p>例如，如果在Java程序中声明了一个类<code>MyClass</code>，那么在程序中可以使用符号<code>MyClass</code>来引用它，而不需要知道<code>MyClass</code>的实际位置。编译器会将符号<code>MyClass</code>转换成对应的类的描述符，然后在运行时根据类的描述符来加载类，并访问其中的字段或方法。</p>
<p>符号引用在Java中起着非常重要的作用，它使得Java程序可以在运行时动态加载类，实现灵活的类加载和重载机制。同时，符号引用还可以使Java程序更加安全，因为Java虚拟机可以检查符号引用指向的对象是否合法，并且在运行时根据对象的实际类型进行调用</p>
</blockquote>
<blockquote>
<p>在Java语言中，直接引用（Direct Reference）指的是一种直接指向对象在内存中的实际地址的引用。在Java中，直接引用主要用于本地方法和JNI（Java Native Interface）方法中，它允许Java程序直接访问本地资源或调用本地库。</p>
<p>与符号引用不同，直接引用是一个具体的内存地址，它指向对象在堆内存中的实际位置。在Java中，直接引用的使用受到严格的限制，只有本地方法和JNI方法才能够使用直接引用，Java程序的其他部分都不能直接使用直接引用。这是因为Java的安全机制要求所有的对象访问都必须通过Java虚拟机来进行，以确保程序的安全性和稳定性。</p>
<p>需要注意的是，在Java中，直接引用并不是对象本身，而是指向对象的一个指针，它只有在本地方法或JNI方法中才能使用。在Java程序中，大部分情况下使用的是符号引用，符号引用是一种更高层次的引用，它提供了更加抽象和安全的对象访问方式。</p>
</blockquote>
<p>**初始化：**对静态变量赋值、并执行静态代码块</p>
<p>​	初始化其实就是执行类构造器方法的<code>()</code>的过程，而且要保证执行前父类的<code>()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的0变成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p>
<h2 id="对象的创建过程">对象的创建过程</h2>
<h3 id="总结">总结</h3>
<ol>
<li>
<p><strong>类加载</strong></p>
<p>因为每一个对象都是类的实例</p>
</li>
<li>
<p><strong>内存分配</strong></p>
<ul>
<li>指针碰撞：适用于内存规整，中间利用分界值指针</li>
<li>空闲列表</li>
</ul>
</li>
<li>
<p><strong>初始化默认值</strong></p>
<p>保证对象实例的字段在Java代码中可以在不赋初值的情况下使用</p>
</li>
<li>
<p><strong>设置对象头（markword和KClassPointer）</strong></p>
<ul>
<li>标记该对象是哪个类的实例</li>
<li>对象的hash码</li>
<li>对象所处的分代年龄</li>
</ul>
</li>
<li>
<p><strong>执行初始化方法</strong></p>
</li>
</ol>
<h3 id="举例：">举例：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">int</span> staicVariabl=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span>   <span class="keyword">int</span>  objVariabl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态初始代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staicVariabl=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象初始化代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        objVariabl=<span class="number">88</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        objVariabl=<span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person=<span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person person=new Person()</p>
<ol>
<li>
<p>构建对象</p>
<p>main线程在栈中申请栈空间，并生成一个栈帧，里面局部变量表中包含有person。</p>
<p>然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM<strong>堆中</strong>申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。</p>
<p><img src="https://s2.loli.net/2023/03/07/4lI1GQ79CbYDjMN.png" alt="image-20230307165405107"></p>
</li>
<li>
<p>初始化对象</p>
<p>执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法（init 方法执行完后objVariabl=88，构造方法执行完后objVariabl=99)</p>
<p><img src="https://s2.loli.net/2023/03/07/k8etDogCbURqz7Z.png" alt="image-20230307165433251"></p>
</li>
<li>
<p>引用对象</p>
<p>对象实例化完毕后，再把栈中的person对象引用地址指向Person对象在堆内存中的地址。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/07/yeTJQg5EFCpPSjf.png" alt="image-20230307165840944"></p>
<h2 id="双亲委派机制">双亲委派机制</h2>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成</p>
<p>保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改</p>
<p>具体而言，即为在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器</p>
<p><img src="https://s2.loli.net/2023/02/26/Suh9KNIkd1RCBpH.png" alt="image-20230226164403300"></p>
</li>
</ol>
<h2 id="多线程的实现方式">多线程的实现方式</h2>
<h2 id="对象的创建过程-2">对象的创建过程</h2>
<h3 id="Step1-类加载检查">Step1:类加载检查</h3>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="Step2-分配内存">Step2:分配内存</h3>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞 ：
<ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ：
<ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="Step3-初始化零值">Step3:初始化零值</h3>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="Step4-设置对象头">Step4:设置对象头</h3>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="Step5-执行-init-方法">Step5:执行 init 方法</h3>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p>
<h2 id="内存泄露场景">内存泄露场景</h2>
<ol>
<li>**实例变量作用域不合理：**如果只需要一个变量作为局部变量，在方法结束就不使用它了，但是把他设置为实例变量，此时如果该类的实例对象生命周期很长也会导致该变量无法回收发生内存泄漏（因为实例对象引用了它）</li>
<li><strong>ThreadLocal中回收key以后可能会发生</strong>，因为Value是强引用，不会主动GC</li>
<li>**不关闭资源引发内存泄漏：**数据库连接、网络连接、IO连接在使用后忘记关闭，GC无法回收它们，会发生内存泄漏</li>
<li>使用散列表时，充当Key 对象的哈希值被改变导致内存泄漏（key 使用逻辑不可变对象，关键域不能被修改）</li>
</ol>
<h2 id="进程和线程区别">进程和线程区别</h2>
<p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位</strong>，在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p>
<p>线程切换时保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong></p>
<ul>
<li>线程是CPU执行、CPU时间分配的基本单位</li>
<li>进程其他系统资源（内存），一系列的系统资源组成的集合</li>
</ul>
<h2 id="线程调度">线程调度</h2>
<p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复</p>
<h2 id="线程的状态">线程的状态</h2>
<ol>
<li>新建（New）</li>
<li>运⾏（Runnable）</li>
<li>阻塞（Blocked）</li>
<li>⽆限期等待（Waiting）</li>
<li>限期等待（Time Waiting）</li>
<li>结束（Terminated）</li>
</ol>
<h2 id="进程的状态">进程的状态</h2>
<ol>
<li>创建状态</li>
<li>就绪状态</li>
<li>运行状态</li>
<li>阻塞状态/等待状态</li>
<li>结束状态</li>
</ol>
<h2 id="进程最多包含多少个线程">进程最多包含多少个线程</h2>
<p>默认情况下，一个线程的栈要预留1M的内存空间，而一个进程中可用的内存空间只有2G，所以理论上一个进程中最多可以开2048个线程。但是内存当然不可能完全拿来作线程的栈，所以实际数目要比这个值要小。</p>
<h2 id="线程的通信方式">线程的通信方式</h2>
<ol>
<li>互斥量：采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，Java 中的synchronized 关键词和各种 Lock</li>
<li>信号量：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最⼤线程数量</li>
<li>事件：通过通知操作的⽅式来保持多线程同步</li>
</ol>
<h2 id="进程的通信方式">进程的通信方式</h2>
<ol>
<li>管道</li>
<li>信号</li>
<li>信号量</li>
<li>消息队列</li>
<li>共享内存</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/26/zSeI9PfidF2g6Wx.png" alt="image-20230226134700122"></p>
<h2 id="sleep和wait的区别">sleep和wait的区别</h2>
<ol>
<li>
<p><strong>wait方法和sleep方法的使用场景不同。</strong></p>
<p>wait方法是Object类的一个方法，通常在同步代码块中使用，用于使线程进入等待状态，直到另一个线程调用了该对象的notify或notifyAll方法来唤醒等待的线程。</p>
<p>sleep方法是Thread类的一个静态方法，用于让线程休眠指定的时间，然后自动唤醒。</p>
</li>
<li>
<p><strong>wait方法和sleep方法的作用不同。</strong></p>
<p>wait方法是用于线程间的协作，<strong>当线程调用wait方法时，它会释放锁并进入等待状态</strong>，等待其他线程调用notify或notifyAll方法唤醒它。wait方法是用于实现线程之间的同步。</p>
<p>sleep方法是用于让线程休眠一段时间，让其他线程有机会执行。<strong>sleep方法不会释放锁</strong>，当线程调用sleep方法时，它仍然持有锁。</p>
</li>
<li>
<p><strong>wait方法和sleep方法的异常不同。</strong></p>
<p>当线程调用wait方法时，如果没有其他线程调用notify或notifyAll方法来唤醒它，它会一直等待下去，直到超时或线程被中断。如果线程被中断，会抛出InterruptedException异常。</p>
<p>当线程调用sleep方法时，它也可能被中断，但中断时不会抛出异常，只是设置中断标志位。如果需要在sleep方法中响应中断，需要在sleep方法中检查中断标志位并进行相应处理。</p>
</li>
</ol>
<p>总之，wait方法和sleep方法都可以用于控制线程的执行，但<strong>wait方法更多的是用于线程间的协作，而sleep方法更多的是用于让线程休眠一段时间。</strong></p>
<h2 id="线程代码举例">线程代码举例</h2>
<p><img src="https://s2.loli.net/2023/03/08/pcZQtYEd5vAmWsI.png" alt="image-20230308104622011"></p>
<h2 id="使线程阻塞的方式">使线程阻塞的方式</h2>
<p>加锁 ----&gt; 线程阻塞</p>
<ol>
<li>
<p>wait()：必须搭配synchronized关键字</p>
<p><img src="https://s2.loli.net/2023/03/08/SOkBTnLbdcjCru2.png" alt="image-20230308105439461"></p>
</li>
<li>
<p>sleep()：只能中断才能唤醒</p>
</li>
<li>
<p>park()：</p>
</li>
<li>
<p>while(true){}</p>
<p><img src="https://s2.loli.net/2023/03/08/ORpoa319QxflsW2.png" alt="image-20230308110533727"></p>
</li>
</ol>
<p>需要加上CAS</p>
<p><img src="https://s2.loli.net/2023/03/08/iv7LBM4Ijk3funJ.png" alt="image-20230308110840024"></p>
<p><img src="https://s2.loli.net/2023/03/08/JNUiSLTn1XPesmW.png" alt="image-20230308111345194"></p>
<h2 id="创建线程的方式">创建线程的方式</h2>
<ol>
<li>
<p>写⼀个类<strong>继承⼦Thread类</strong>，重写run方法</p>
<p>单继承具有局限性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式一：继承Thread类，重写run()方法，调用start()开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run()方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码——————&quot;</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//main()线程，主线程</span></span><br><span class="line">        <span class="comment">//创建一个对象</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">//调用start()方法</span></span><br><span class="line">        testThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写⼀个类<strong>实现Runable接口</strong>，重写run⽅法</p>
<p>避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式2:实现runnable接口,重写run方法，执行线程丢入runnable接口实现类，调用start()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建runnable接口的实现类对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启我们的线程，代理</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(testThread3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;学习&quot;</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写⼀个类<strong>实现Callable接口</strong>，重写call⽅法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个类，重写call()方法，</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在上班-----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = executorService.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = executorService.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = executorService.submit(t3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        Boolean r1 = result1.get();</span><br><span class="line">        Boolean r2 = result2.get();</span><br><span class="line">        Boolean r3 = result3.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使⽤线程池</p>
</li>
</ol>
<h2 id="如何中断一个正在运行中的线程">如何中断一个正在运行中的线程</h2>
<p><img src="https://s2.loli.net/2023/03/27/71y83esawPfxMrq.png" alt="image-20230327232931664"></p>
<h2 id="线程池的状态">线程池的状态</h2>
<ol>
<li>
<p>运行**(RUNNING)**</p>
</li>
<li>
<p><strong>SHUTDOWN</strong></p>
<p>线程池处于SHUTDOWN状态时，不接收新任务，但能处理已添加的任务，通过调用线程池的shutdown()接口</p>
</li>
<li>
<p><strong>STOP</strong></p>
<p>线程池处于STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务，调用线程池的shutdownNow()接口</p>
</li>
<li>
<p><strong>TIDYING</strong></p>
</li>
<li>
<p><strong>TERMINATED</strong></p>
</li>
</ol>
<h2 id="线程池有哪些参数，分别的含义">线程池有哪些参数，分别的含义</h2>
<p>七大核心参数</p>
<ol>
<li>
<p>**corePoolSize：**核⼼线程数</p>
</li>
<li>
<p><strong>maximumPoolSize：</strong> 线程池中最⼤线程数</p>
</li>
<li>
<p>**keepAliveTime：**多余空闲线程数的存活时间，当前线程数⼤于corePoolSize，并且等待时间⼤于keepAliveTime，多于线程或被销毁直到剩下corePoolSize为⽌。</p>
</li>
<li>
<p><strong>TimeUnit unit：</strong> keepAliveTime的单位。</p>
</li>
<li>
<p>**workQueue：**任务队列，被提交但未必执⾏的任务。</p>
</li>
<li>
<p>**threadFactory：**⽤于创建线程池中⼯作线程的线程⼯⼚，⼀般⽤默认的。</p>
</li>
<li>
<p>**handler：**拒绝策略，当堵塞队列满了并且⼯作线程⼤于线程池的最⼤线程数（maximumPoolSize）</p>
<p><img src="https://s2.loli.net/2023/02/26/5wG61dFTamER3M8.png" alt="image-20230226153805288"></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/26/u3yJVo8TY7SZWXg.png" alt="image-20230226153857717"></p>
<h2 id="创建线程池的方式">创建线程池的方式</h2>
<ol>
<li><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建</strong></li>
<li><strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建</strong>（阿里手册不允许）</li>
</ol>
<h2 id="阻塞队列有哪些">阻塞队列有哪些</h2>
<ol>
<li>**ArrayBlockingQueue：**基于数组实现的有界阻塞队列，具有固定容量、先进先出、阻塞队列和线程安全等特点。</li>
<li>**LinkedBlockingQueue：**基于链表实现的可选有界阻塞队列，可以指定容量，如果未指定容量则默认容量为 Integer.MAX_VALUE，同样具有先进先出、阻塞队列和线程安全等特点。</li>
<li>**SynchronousQueue：**没有容量的阻塞队列，每个插入操作必须等待另一个线程的删除操作，同样具有阻塞队列和线程安全等特点。</li>
<li>**PriorityBlockingQueue：**基于堆实现的无界阻塞队列，可以自定义元素的优先级，按照优先级排序，同样具有阻塞队列和线程安全等特点。</li>
</ol>
<h2 id="ArrayBlockingQueue的特点">ArrayBlockingQueue的特点</h2>
<ol>
<li><strong>有界限制</strong>：ArrayBlockingQueue 有一个指定的容量，当队列已满时，继续向队列中添加元素的线程将被阻塞，直到队列中有空闲空间。</li>
<li><strong>先进先出</strong>：ArrayBlockingQueue 遵循先进先出的原则，也就是说，队列中的元素将按照它们被添加到队列中的顺序进行处理。</li>
<li><strong>阻塞队列</strong>：当队列为空时，从队列中获取元素的线程将被阻塞，直到队列中有可用元素。同样地，当队列已满时，向队列中添加元素的线程将被阻塞，直到队列中有空闲空间。</li>
<li><strong>线程安全</strong>：ArrayBlockingQueue 是线程安全的，多个线程可以同时访问它，而不会导致数据的不一致性或其他线程安全问题。</li>
</ol>
<h2 id="介绍强引用、软引用、弱引用、虚引用">介绍强引用、软引用、弱引用、虚引用</h2>
<p>包含虚引用与软引用和弱引用的区别、使用软引用能带来的好处</p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>
<h2 id="虚引用的作用">虚引用的作用</h2>
<p>唯⼀的⽤处：能在对象被GC时收到系统通知</p>
<p>虚引⽤必须和引⽤队列 （ReferenceQueue）联合使⽤。当垃圾回收器准备回收⼀个对象时，如果发现它还有虚引⽤，就会在回收对象的内存之前，把这个虚引⽤加⼊到与之关联的引⽤队列中</p>
<h2 id="如何判断一个常量是废弃常量">如何判断一个常量是废弃常量</h2>
<p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池了。</p>
<h2 id="如何判断一个类是无用的类">如何判断一个类是无用的类</h2>
<ul>
<li>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
</li>
<li>
<p>加载该类的 <code>ClassLoader</code> 已经被回收。</p>
</li>
<li>
<p>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<h2 id="HotSpot-为什么要分为新生代和老年代？">HotSpot 为什么要分为新生代和老年代？</h2>
<p>一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</p>
<h2 id="如何判断对象是否死亡（两种方法）">如何判断对象是否死亡（两种方法）</h2>
<h3 id="引用计数法">引用计数法</h3>
<p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的</li>
</ul>
<p>缺点：<em><em>它很难解决对象之间相互循环引用的问题</em>，</em>*，因为缺乏全局对象图，只维护了局部信息</p>
<h3 id="可达性分析算法">可达性分析算法</h3>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收</p>
<p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象</p>
<p><img src="https://s2.loli.net/2023/02/22/kh4lgQZp7cCorUT.png" alt="image-20230222205338789"></p>
<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
<li>已启动且未停止的 Java 线程</li>
</ul>
<p>当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行</p>
<h2 id="垃圾收集有哪些算法，各自的特点？">垃圾收集有哪些算法，各自的特点？</h2>
<ul>
<li>
<p>标记清除算法</p>
</li>
<li>
<p>标记复制算法</p>
</li>
<li>
<p>标记整理算法</p>
</li>
<li>
<p>分代收集算法</p>
</li>
</ul>
<h2 id="常见的垃圾回收器有哪些？">常见的垃圾回收器有哪些？</h2>
<ul>
<li>
<p>Serial 收集器：单线程+STW</p>
</li>
<li>
<p>ParNew 收集器：<strong>是 Serial 收集器的多线程版本，新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p>
</li>
<li>
<p>Parallel Scavenge 收集器：<strong>关注点是吞吐量</strong>（吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值），<strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p>
</li>
<li>
<p>CMS收集器(Concurrent Mark Sweep)：<strong>关注点是响应时间</strong>，<strong>是并发收集器</strong>，实现<strong>标记-清除”算法</strong></p>
<p>缺点：</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</li>
</ul>
</li>
<li>
<p>G1收集器：使用多个CPU缩短STW停顿时间；局部是标记复制算法；可预测的停顿</p>
<p>G1垃圾回收器抛弃了分代的概念，将堆内存划分为⼤⼩固定的⼏个独⽴区域，并维护⼀个优先级列表，在垃圾回收过程中根据系统允许的最长垃圾回收时间，优先回收垃圾最多的区域。</p>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 	Region(这也就是它的名字 Garbage-First 的由来)</strong></p>
</li>
</ul>
<h2 id="HotSpot默认的垃圾回收器">HotSpot默认的垃圾回收器</h2>
<p>垃圾回收器讲解：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2031199">HotSpot 提供的垃圾收集器</a></p>
<p><strong>小于等于jdk8是paraella gc，大于等于9是g1</strong></p>
<h2 id="CMS垃圾回收器">CMS垃圾回收器</h2>
<p>CMS是老年代回收器，<strong>只能回收老年代的对象</strong>，在收集过程中可以与用户线程并发操作</p>
<ul>
<li>优点：并发收集、低停顿。<br>
其实最主要的是CMS把收集过程中步骤拆分了，而最耗时的操作都是并发执行，自然就会低停顿了。</li>
<li>缺点：<strong>产生大量空间碎片</strong>（可以通过配置重新整理，但是加长停顿时间）、并发阶段会<strong>降低吞吐量</strong>。<strong>无法处理浮动垃圾</strong>。<br>
CMS采用的是标记-清除算法，所以会产生大量的空间碎片。</li>
</ul>
<p>基于标记清除算法</p>
<ol>
<li>
<p><strong>初始标记阶段</strong>只标记GC Root关联的对象，速度很快（更改对象头MarkWord的GC标记字段）</p>
</li>
<li>
<p>在<strong>并发标记阶段</strong>，因为是用户线程和GC线程同时在跑，所以采用的是三色标记的方式进行垃圾标记</p>
<ul>
<li><strong>白色</strong>：对象的默认颜色，从GC Root开始扫描，如果对象是不可达对象的话就是白色，也就是垃圾对象，在并发清理的时候会清理掉。</li>
<li><strong>灰色</strong>：当前对象已经被扫描过，但是当前对象所依赖的其他对象还没有被扫描。</li>
<li><strong>黑色</strong>：当前对象和它所依赖的对象都已经被扫描过，不会对黑色对象和引用的对象再次进行扫描。</li>
</ul>
<p>三色标记的问题：漏标&amp;多标</p>
<p>漏标的解决方案<br>
CMS使用增量更新的方式解决三色标记漏标问题。<br>
增量更新：<br>
将新增的引用维护到一个集合里面，将引用的源头变成灰色，等待重新标记阶段再重新进行一次扫描。比如：当D的引用指向了C，则会将C变成灰色，并将C放在一个新增引用的集合里面；在重新标记阶段会将C作为根节点继续向下扫描。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/27/AV2zXgBioClyFLr.png" alt="image-20230327144652948"></p>
<h2 id="G1垃圾回收器-Garbage-First">G1垃圾回收器(Garbage-First)</h2>
<p>讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fengyuyeguirenenen/article/details/123483286">G1垃圾收集器详解</a></p>
<p><strong>以极高概率满足GC停顿时间的同时</strong>,还<strong>兼具高吞吐量的性能特征</strong></p>
<p>优点：</p>
<ul>
<li>
<p><strong>并行和并发</strong></p>
</li>
<li>
<p><strong>分代收集</strong></p>
<p>和之前的各类回收器不同,它<strong>同时兼顾年轻代和老年代</strong>。对比其他回收器,或者工作在年轻代,或者工作在老年代</p>
</li>
<li>
<p><strong>空间整合</strong></p>
</li>
</ul>
<ol>
<li>
<p>G1是一个并行回收器,它<strong>把堆内存分割为很多不相关的区域(region物理上不连续),把堆分为2048个区域</strong>,每一个region的大小是1 - 32M不等,必须是<strong>2的整数次幂</strong>。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等</p>
</li>
<li>
<p>每次根据允许的收集时间,<strong>优先回收价值最大的Region</strong>(每次回收完以后都有一个空闲的region,在后台维护一个优先列表)，侧重点在于回收垃圾最大量的区间(Region)</p>
</li>
<li>
<p>还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了,它们都是一部分Region (不需要连续)的集合。<strong>通过Region的动态分配方式实现逻辑上的连续。</strong></p>
</li>
<li>
<p><strong>Humongous内存区域</strong>：主要用于存储大对象，如果<strong>超过0.5个region, 就放到H</strong></p>
<p><strong>对于堆中的大对象，默认直接会被分配到老年代</strong>，但是如果它是<strong>一个短期存在的大对象，就会对垃圾收集器造成负面影响</strong>。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/27/VuDv9BFJMSiXLft.png" alt="image-20230327152815036"></p>
<p>相关参数：</p>
<ol>
<li>
<p>**-XX:+UseG1GC:**手动指定使用G1收集器执行内存回收任务（JDK9后不用设置，默认就是G1）</p>
</li>
<li>
<p>**-XX:G1HeapRegionSize:*<em>设置每个Region的大小。值*<em>是2的幂,范围是1MB到32MB之间</em></em>,目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000</p>
</li>
<li>
<p>**-XX:MaxGCPauseMillis:*<em>设置期望达到的*<em>最大GC停顿时间指标</em></em>(JVM会尽力实现,但不保证达到)。默认值是200ms（如果这个值设置很小,如20ms,那么它收集的region会少,这样长时间后,堆内存会满。产生FullGC,FullGC会出现STW,反而影响用户体验)</p>
</li>
<li>
<p>**-XX:ParallelGCThread:**设置STW时GC线程数的值。最多设置为8</p>
</li>
<li>
<p>**-XX:ConcGCThreads:**设置并发标记的线程数。<strong>将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右</strong></p>
</li>
<li>
<p>**-XX:InitiatingHeapOccupancyPercent:**设置触发并发GC周期的Java堆占用率阈值。<strong>超过此值,就触发GC</strong>。默认值是45</p>
</li>
</ol>
<h2 id="GC如何调优">GC如何调优</h2>
<ol>
<li>内存占用</li>
<li>延时</li>
<li>吞吐量</li>
</ol>
<p>通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。 例如，通过追踪 GC<br>
日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</p>
<h3 id="常见的-GC-调优思路">常见的 GC 调优思路</h3>
<ol>
<li>
<p>降低 Minor GC 频率</p>
<p><strong>增大新生代空间</strong></p>
</li>
<li>
<p>降低 Full GC 的频率</p>
<ul>
<li>减少创建大对象</li>
<li>增大堆内存空间</li>
</ul>
</li>
</ol>
<h2 id="JVM调优">JVM调优</h2>
<ol>
<li>调整最大堆内存和最小堆内存（-Xms，-Xmx）</li>
<li>调整新生代和老年代的比值（-XX：NewRatio）</li>
<li>调整survivor区和Eden区的比值（一般为8:1:1）（-XX：SurvivorRatio）</li>
<li>设置年轻代和老年代的大小</li>
</ol>
<h1>JUC</h1>
<h2 id="ThreadLocal是怎么实现的">ThreadLocal是怎么实现的</h2>
<p>ThreadLocal底层是通过ThreadLocalmap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值，不同于synchronized的互斥效果，它是隔离性，各个线程操作自己的数据，还可用于单线程间的全区共享</p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</p>
<p><img src="https://s2.loli.net/2023/03/11/b78yjB9LqzZrx62.png" alt="image-20230311180958325"></p>
<h2 id="ThreadLocal带来的问题及解决">ThreadLocal带来的问题及解决</h2>
<p>内存泄漏：ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤，解决：<strong>手动remove</strong></p>
<h2 id="synchronized-和-Reentrantlock的区别">synchronized 和 Reentrantlock的区别</h2>
<h3 id="相似点：">相似点：</h3>
<ol>
<li>都是加锁方式同步，并且是阻塞式同步</li>
<li>都是可重入锁</li>
<li>都保证了可见性和互斥性</li>
</ol>
<h3 id="区别：">区别：</h3>
<ol>
<li>synchronized是java中的关键字，而Reentrantlock是lock下的实现类，是API层面的锁</li>
<li>synchronized是非公平锁，Reentrantlock默认是非公平锁，但是也可以设置为公平锁</li>
<li>synchronized隐式释放锁，Reentrantlock显示获取锁和释放锁</li>
<li>Reentrantlock等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，可以避免synchronized的死锁。</li>
<li>Reentrantlock可以绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象</li>
</ol>
<h2 id="volatile关键字是怎么实现的">volatile关键字是怎么实现的</h2>
<p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序</p>
<p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取</p>
<h2 id="sleep和wait的区别-2">sleep和wait的区别</h2>
<ol>
<li>sleep⽅法属于Thread类，wait⽅法属于Object类</li>
<li>在调⽤sleep⽅法的过程中，线程不会释放对象锁，⽽wait会释放对象锁，别的线程是可能获取到的</li>
<li>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong></li>
<li><strong>调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态</strong></li>
<li>wait 方法必须配合 synchronized 一起使用，不然在运行时就会抛出 IllegalMonitorStateException 的异常，而 sleep 可以单独使用，无需配合 synchronized 一起使用</li>
</ol>
<h2 id="CAS">CAS</h2>
<p>CAS指令有三个操作数，分别是内存偏移量V（可理解为内存地址），旧的预期值E，准备设置的新值N</p>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了V，则当前线程放弃更新</p>
<h3 id="CAS可能的问题：">CAS可能的问题：</h3>
<ol>
<li><strong>ABA问题</strong>：解决用版本号或时间戳</li>
<li><strong>循环时间长开销大</strong>：CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销，解决用pause指令</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，解决在jdk1.5后：可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作</li>
</ol>
<h2 id="乐观锁和悲观锁">乐观锁和悲观锁</h2>
<p>悲观锁和乐观锁并不是某个具体的“锁”⽽是⼀种并发编程的基本概念</p>
<h3 id="悲观锁">悲观锁</h3>
<p><strong>定义：</strong></p>
<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放</p>
<p>即：<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong></p>
<p><strong>使用场景：</strong></p>
<p>悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能</p>
<h3 id="乐观锁">乐观锁</h3>
<p><strong>定义：</strong></p>
<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</p>
<p><strong>使用场景：</strong></p>
<p>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量</p>
<p><strong>实现：</strong></p>
<ol>
<li>
<p><strong>版本号机制：</strong></p>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功</p>
</li>
<li>
<p><strong>CAS算法</strong></p>
</li>
</ol>
<h2 id="ReentrantLock和Synchronized关键字的区别">ReentrantLock和Synchronized关键字的区别</h2>
<h3 id="ReentrantLock">ReentrantLock</h3>
<p>通过State+AQS实现</p>
<p>重入：同一个线程里面，有多次lock，state都会++</p>
<p>公平锁：</p>
<ol>
<li>尝试去加锁，先拿到自己的线程</li>
<li>看是否需要排队，不需要，则直接compareAndSetState去抢一次state</li>
<li>加锁的时候也会去判断是否需要重入（current == getExclusiveOwnerThread）</li>
<li>如果没有加成功，那就请求入队，addwaiter方法，入队不成功也会一直循环的</li>
<li>没成功的就会park，只有当前排队的线程node是头节点才会去改state</li>
<li>锁空出来，就会把队列第一个unpark</li>
</ol>
<p>非公平锁：</p>
<ol>
<li>直接加锁</li>
<li>如果没加成功，那就再尝试加一次</li>
<li>如果还没有成功，那就排队</li>
</ol>
<p>两者都只重写了lock方法，没有重写unlock方法，二者统一为release</p>
<h3 id="synchronized">synchronized</h3>
<p>讲解：</p>
<ol>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dreambyday/article/details/128767442?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-128767442-blog-106430463.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-128767442-blog-106430463.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=3">synchronized底层原理</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://medlen.blog.csdn.net/article/details/88384493?spm=1001.2101.3001.6650.13&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-13-88384493-blog-128767442.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-13-88384493-blog-128767442.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=19">synchronized底层实现原理及锁优化</a></p>
</li>
</ol>
<p><strong>实现原理：</strong></p>
<blockquote>
<p>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。</p>
<p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
</blockquote>
<p>实现了<strong>可见性和原子性</strong>：</p>
<ul>
<li>
<p><strong>可见性：synchronized每次加锁释放锁都会刷新工作内存，将更新完的数据写回到主内存中，然后从主内存中重新读取最新的数据</strong></p>
<blockquote>
<p>当线程释放锁时，JMM会把该线程对应的工作内存中的共享变量刷新到主内存中<br>
当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量，这样保证了内存的可见性</p>
</blockquote>
</li>
<li>
<p><strong>原子性：同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入</strong></p>
</li>
</ul>
<p>锁升级：MarkWord</p>
<h3 id="区别与联系">区别与联系</h3>
<p><img src="https://s2.loli.net/2023/03/10/D4TCFPvm2ptshUd.png" alt="image-20230310143817042"></p>
<p>区别</p>
<p><img src="https://s2.loli.net/2023/03/10/Z3kJh7zAXvNjDU5.png" alt="image-20230310143905383"></p>
<h2 id="CountdownLatch和Semaphore的实现">CountdownLatch和Semaphore的实现</h2>
<p>CountDownLatch是Java中的一个同步工具类，可以帮助线程协调和等待。在使用CountDownLatch时，我们可以设置一个计数器，然后让多个线程并行执行，当所有线程完成任务后，计数器减为0，主线程才能继续执行。</p>
<p>Semaphore是Java中的一个同步工具类，它可以控制同时访问某个资源的线程数目，以达到限流的效果。在使用Semaphore时，我们可以设置允许访问资源的线程数目，当达到该数目时，后续线程需要等待已有线程释放资源后才能访问。</p>
<p><strong>CountdownLatch：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>); <span class="comment">// 创建CountDownLatch对象，初始计数器为3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建三个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(latch, <span class="string">&quot;Worker1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(latch, <span class="string">&quot;Worker2&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(latch, <span class="string">&quot;Worker3&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await(); <span class="comment">// 等待三个线程执行完成</span></span><br><span class="line">            System.out.println(<span class="string">&quot;All workers have finished their work!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is working...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">5000</span>)); <span class="comment">// 模拟工作耗时</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; has finished its work.&quot;</span>);</span><br><span class="line">        latch.countDown(); <span class="comment">// 计数器减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Worker2 is working...</span><br><span class="line">Worker3 is working...</span><br><span class="line">Worker1 is working...</span><br><span class="line">Worker3 has finished its work.</span><br><span class="line">Worker2 has finished its work.</span><br><span class="line">Worker1 has finished its work.</span><br><span class="line">All workers have finished their work!</span><br></pre></td></tr></table></figure>
<p><strong>Semaphore：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>); <span class="comment">// 创建Semaphore对象，初始许可证数量为2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建五个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker1&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker2&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker3&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker4&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(semaphore, <span class="string">&quot;Worker5&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Semaphore semaphore, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取一个许可证</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot; is working...&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">5000</span>)); <span class="comment">// 模拟工作耗时</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot; has finished its work.&quot;</span>);</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放一个许可证</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker1 is working...</span><br><span class="line">Worker2 is working...</span><br><span class="line">Worker2 has finished its work.</span><br><span class="line">Worker3 is working...</span><br><span class="line">Worker1 has finished its work.</span><br><span class="line">Worker4 is working...</span><br><span class="line">Worker3 has finished its work.</span><br><span class="line">Worker5 is working...</span><br><span class="line">Worker4 has finished its work.</span><br><span class="line">Worker5 has finished its work.</span><br></pre></td></tr></table></figure>
<h1>计网</h1>
<h2 id="常用状态码">常用状态码</h2>
<p>301,302,500，501，502，401,402,403,404</p>
<p><img src="https://s2.loli.net/2023/02/25/RNLkfzU2HGlWge5.png" alt=""></p>
<p><img src="https://s2.loli.net/2023/02/25/LRerzM46Z9tX2Il.png" alt="image-20230225204425405"></p>
<p><img src="https://s2.loli.net/2023/02/25/YvlgQ5eIPfXKFhd.png" alt="image-20230225204414914"></p>
<h2 id="常见的请求头">常见的请求头</h2>
<p>HTTP请求头是在HTTP请求中发送的附加信息</p>
<ol>
<li>User-Agent：指定发送请求的客户端类型和版本。</li>
<li>Accept：指定客户端可接受的内容类型（MIME类型）。</li>
<li>Content-Type：指定发送请求的实体的媒体类型。</li>
<li>Authorization：包含用于身份验证的凭据，如基本身份验证或Bearer令牌。</li>
<li>Cookie：包含在先前的响应中设置的Cookie，用于维护会话状态。</li>
<li>Referer：指示从哪个URL发送请求。</li>
<li>If-Modified-Since：指定一个日期，服务器将只返回在该日期之后更新的资源。</li>
<li>Cache-Control：指定请求/响应链中的缓存行为。</li>
<li>Connection：指定是否在请求后保持打开状态，以允许在同一连接上发送多个请求/响应对。</li>
<li>Host：指定服务器的主机名和端口号</li>
</ol>
<h2 id="HTTP1-2-3缺陷">HTTP1/2/3缺陷</h2>
<h3 id="HTTP缺陷">HTTP缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/wD7QIp951mFfC4P.png" alt="image-20230225204244708"></p>
<h3 id="HTTP1-1缺陷">HTTP1.1缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/6QyaX12SmWkGInN.png" alt="image-20230225204202208"></p>
<p>以及高延迟问题：</p>
<p><img src="https://s2.loli.net/2023/02/25/H3QOgP8r42yD9WA.png" alt="image-20230225204745802"></p>
<h3 id="HTTP-2缺陷">HTTP/2缺陷</h3>
<p><img src="https://s2.loli.net/2023/02/25/xlym3cu2zd5VYKo.png" alt="image-20230225204104566"></p>
<p><img src="https://s2.loli.net/2023/02/25/gHqskGcOQ47jr2U.png" alt="image-20230225204925272"></p>
<p>解决用QUIC：</p>
<p><img src="https://s2.loli.net/2023/02/25/K2zqmTVJr5DZQBP.png" alt="image-20230225204856451"></p>
<h2 id="HTTP的队头阻塞">HTTP的队头阻塞</h2>
<p>多路复用，HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题， 降低了延迟，⼤幅度提⾼了连接的利⽤率</p>
<h2 id="HTTP与HTTPS的区别（细扣）">HTTP与HTTPS的区别（细扣）</h2>
<ul>
<li>https协议需要到ca申请证书</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<h2 id="TCP和UDP的区别">TCP和UDP的区别</h2>
<p><img src="https://s2.loli.net/2023/02/20/ZHiR2TzWVIXnL3A.jpg" alt=""></p>
<p><strong>应用场景：</strong></p>
<p><img src="https://s2.loli.net/2023/02/28/kmJyhqtENjOofG1.png" alt="image-20230228134610615"></p>
<h2 id="https加密过程（详细）">https加密过程（详细）</h2>
<ol>
<li>客户端发送请求：客户端向服务器发送一个HTTPS请求，请求中包含一个特殊的标识（https://），表示客户端希望与服务器进行HTTPS加密通信。</li>
<li>服务器端的SSL证书：服务器收到请求后，会向客户端发送一个SSL证书，证书包含服务器的公钥、证书颁发机构等信息。</li>
<li>客户端验证SSL证书：客户端收到服务器发送的SSL证书后，会验证证书的有效性。验证包括证书的签名是否合法、证书是否过期、证书颁发机构是否可信等，如果验证通过，客户端就可以信任服务器的公钥了。</li>
<li>客户端生成密钥：客户端生成一个随机的对称加密密钥，用于后续的通信数据加密。</li>
<li>客户端使用公钥加密密钥：客户端使用服务器发送的SSL证书中包含的公钥，将生成的对称加密密钥加密后，发送给服务器。</li>
<li>服务器使用私钥解密密钥：服务器收到客户端发送的加密密钥后，使用自己的私钥进行解密，得到对称加密密钥。</li>
<li>通信数据加密：客户端和服务器使用对称加密密钥，对通信数据进行加密和解密。这样，只有客户端和服务器之间才能够解密通信数据，保证了通信的安全性。</li>
<li>通信数据传输：客户端和服务器使用加密后的通信数据进行通信，保证了数据的机密性和完整性。</li>
</ol>
<h2 id="ping的发送和接收过程">ping的发送和接收过程</h2>
<ol>
<li>源主机先构建一个ICMP回送请求消息数据包，包含字段，类型（8），序号(用于区分连续ping的时候发出的多个数据包)以及发送时间</li>
<li>ICMP协议将数据包连同目标主机地址一起交给IP层，IP层进一步将本机IP地址作为源地址，协议字段设置为1表示是ICMP协议</li>
<li>加入MAC头，如果在本地ARP映射表中查找出对应的MAC地址，则直接使用，如果没有，则发送ARP协议查询MAC地址，获得后由数据链路层构建一个数据帧</li>
<li>主机 B 收到这个数据帧后，先检查它的⽬的 MAC 地址，并和本机的 MAC 地址对⽐，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样， IP 层检查后，将有⽤的信息提取后交给 ICMP 协议</li>
<li>主机B会构建⼀个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0 ， 序号为接收到的请求数据包中的序号，然后再发送出去给主机A，在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明⽬标主机不可达；如果接收到了 ICMP 回送响应消息，则说明⽬标主机可达。</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/r4fB1Hn59tekvgQ.png" alt="image-20230220135609934"></p>
<h2 id="如果TCP连接不成功，但是ping可以ping通，如何排查网络问题"><strong>如果TCP连接不成功，但是ping可以ping通，如何排查网络问题</strong></h2>
<ol>
<li>
<p>检查<strong>TCP端口是否开放</strong>。TCP连接需要通过目标主机的TCP端口进行连接，如果目标主机的TCP端口没有开放，则无法建立TCP连接。可以使用telnet命令或者其他网络工具来检查目标主机的TCP端口是否开放。</p>
</li>
<li>
<p>检查<strong>网络防火墙设置</strong>。网络防火墙可能会对TCP连接进行限制，需要检查网络防火墙的设置，确认是否允许该TCP连接通过。</p>
</li>
<li>
<p>检查<strong>DNS解析是否正确</strong>。如果目标主机的域名有多个IP地址，需要检查DNS解析是否正确，确认TCP连接的目标IP地址是否正确。</p>
</li>
<li>
<p>检查<strong>目标主机的TCP连接队列是否满了</strong>。如果目标主机的TCP连接队列已满，可能会导致TCP连接失败。可以尝试增加目标主机的TCP连接队列大小，或者等待目标主机释放部分TCP连接资源。</p>
<hr>
</li>
<li>
<p>检查<strong>网络负载均衡设置</strong>。如果目标主机处于负载均衡环境下，需要检查负载均衡的设置，确认是否允许该TCP连接通过。</p>
</li>
</ol>
<h2 id="浏览器输入一个url的处理过程">浏览器输入一个url的处理过程</h2>
<p><img src="https://s2.loli.net/2023/02/20/BwlAIdDYTcsaOQz.png" alt="image-20230220153505776"></p>
<ol>
<li>解析URL，生成发送给Web服务器的HTTP请求信息（包含服务器名称以及数据源文件的路径名）</li>
<li>通过DNS查询服务器域名对应的IP地址</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/3vGxp6Ynk2NRrlc.png" alt="image-20230220150008877"></p>
<ol start="3">
<li>
<p>通过DNS获得到IP后，把HTTP的传输工作交给操作系统中的协议栈，<strong>建立TCP连接</strong></p>
<p>包含TCP，IP(ICMP，ARP（⽤于根据 IP 地址查询相应的以太⽹ MAC 地址  ）)</p>
<p>具体包含：TCP三次握手，TCP分割数据</p>
<ul>
<li>ICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息。</li>
<li>ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址</li>
</ul>
<p>在发包时：</p>
<blockquote>
<p>先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中的地址。⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询</p>
</blockquote>
</li>
<li>
<p>分别加上HTTP报文，TCP头部，IP头部，MAC头部，MAC包头协议类型只使用0800表示IP协议或者0806表示ARP协议</p>
<p><strong>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象</strong></p>
<p><strong>⽣成了 IP 头部之后，接下来网络包还需要在 IP 头部的前⾯加上 MAC 头部</strong></p>
</li>
<li>
<p>通过网卡传播，转换为电信号</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/20/CcEYbg25nMVQJ78.png" alt="image-20230220153152419"></p>
<ol start="6">
<li>通过交换机
<ul>
<li>交换机⼯作在 MAC 层，是基于以太⽹设计的，也称为⼆层⽹络设备</li>
<li>交换机的端⼝不具有 MAC 地址</li>
<li>将包存⼊缓冲区后，接下来需要查询⼀下这个包的接收⽅ MAC 地址是否已经在 MAC 地址表中有记录了，如果有则直接进行转发，如果没有，则转发到除源端口外的所有端口上</li>
</ul>
</li>
<li>通过路由器
<ul>
<li>路由器是基于 IP 设计的，俗称<strong>三层网络设备</strong>，路由器的各个端⼝都具有 MAC 地址和 IP 地址</li>
</ul>
</li>
<li>服务器的永久重定向响应</li>
<li>服务器处理HTTP请求，并返回HTTP响应，浏览器进行页面渲染</li>
<li>断开TCP连接</li>
</ol>
<h2 id="三次握手过程">三次握手过程</h2>
<ul>
<li>
<p>第一个报文：SYN报文：客户端随机初始化32位序列号client_isn</p>
</li>
<li>
<p>第二个报文：SYN+ACK报文：服务端随机初始化32位序列号server_isn，确认应答号为收到的客户端ISN+1</p>
</li>
<li>
<p>第三个报文：ACK报文：确认应答号为收到服务端的ISN+1</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/28/NSvI7JmfVXDhwHY.png" alt="image-20230228141655187"></p>
<h2 id="四次挥手过程">四次挥手过程</h2>
<ul>
<li>客户端发送FIN报文，客户端进入FIN_WAIT_1状态</li>
<li>服务端收到后发送ACK应答报文，并进入CLOSED_WAIT状态</li>
<li>客户端收到ACK后进入FIN_WAIT_2状态</li>
<li>等服务端处理完数据，会向客户端发送FIN报文，并进入LAST_ACK状态</li>
<li>客户端收到FIN报文后，回一个ACK应答报文，并进入TIME_WAIT状态</li>
<li>服务器收到ACK报文后，进入CLOSED状态</li>
<li>客户端在经过2MSL时间后，自动进入CLOSED状态</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/28/pyobLrQEltsVn3Z.png" alt="image-20230228141632925"></p>
<h2 id="TCP-三次握手，两次、四次不行吗">TCP 三次握手，两次、四次不行吗</h2>
<ul>
<li>三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）</li>
<li>三次握⼿才可以同步双⽅的初始序列号</li>
<li>三次握⼿才可以避免资源浪费</li>
</ul>
<p>**「两次握⼿」：**⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；</p>
<p>**「四次握⼿」：**三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数</p>
<h2 id="TIME-WAIT-状态是做什么用的">TIME_WAIT 状态是做什么用的</h2>
<p>⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都自然消失，再出现的数据包⼀定都是新建立连接所产⽣的</p>
<p>**报文最大生存时间  **：2MSL</p>
<h2 id="为什么是2MSL">为什么是2MSL</h2>
<p><strong>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间</strong></p>
<h2 id="网络拥塞状态下TCP数据传输，从流量控制角度聊聊">网络拥塞状态下TCP数据传输，从流量控制角度聊聊</h2>
<h2 id="TCP是如何保证高可靠的">TCP是如何保证高可靠的</h2>
<ul>
<li>流式传输</li>
<li>一对一传输</li>
<li>重传机制：超时重传+快速重传+SACK+D-SACK</li>
<li>滑动窗口</li>
<li>拥塞控制：慢启动，拥塞避免，拥塞发生，快速回复</li>
<li>流量控制</li>
<li>三次握手、四次挥手</li>
</ul>
<h2 id="ping-基于什么协议">ping 基于什么协议</h2>
<p>ICMP协议</p>
<h2 id="网络层和传输层有什么区别">网络层和传输层有什么区别</h2>
<ol>
<li>网络层和传输层的位置不同。网络层位于OSI模型的第三层，主要负责处理网络间的数据传输和路由；而传输层位于第四层，主要负责端到端的数据传输和可靠性保证。</li>
<li>网络层和传输层的协议不同。网络层使用的协议有IP（Internet Protocol，互联网协议）、ICMP（Internet Control Message Protocol，互联网控制报文协议）等，传输层使用的协议有TCP（Transmission Control Protocol，传输控制协议）、UDP（User Datagram Protocol，用户数据报协议）等。</li>
<li>网络层和传输层的功能不同。网络层的主要功能是负责将数据包从源节点传输到目的节点，实现跨网络的数据传输和路由选择；而传输层的主要功能是提供端到端的数据传输和可靠性保证，确保数据的完整性、可靠性和有序性。</li>
<li>网络层和传输层的数据单位不同。网络层的数据单位是IP数据包，它包含了源IP地址、目的IP地址和数据；而传输层的数据单位是TCP数据段或UDP数据包，它们包含了端口号、序号、确认号等信息。</li>
</ol>
<h2 id="ARP协议？工作机制介绍一下">ARP协议？工作机制介绍一下</h2>
<p>ARP协议是一种用于将IP地址解析为MAC地址的协议</p>
<ol>
<li>当主机A需要向主机B发送数据时，首先会检查自己的ARP缓存中是否已经有了B的MAC地址。如果有，直接发送数据包；如果没有，执行下一步。</li>
<li>主机A会发送一个ARP请求广播消息，该消息包含了主机A的MAC地址和IP地址以及需要解析的目标IP地址（即主机B的IP地址），并将该消息发送到本地网络中的所有主机。</li>
<li>当主机B收到ARP请求消息时，会检查消息中的目标IP地址是否是自己的IP地址。如果是，就会向主机A发送一个ARP响应消息，该消息包含了主机B的MAC地址和IP地址，并将该消息直接发送给主机A。</li>
<li>当主机A收到ARP响应消息时，就可以得到主机B的MAC地址了。主机A将该地址存储到自己的ARP缓存中，并使用该地址发送数据包到主机B。</li>
</ol>
<p>需要注意的是，ARP协议只能在本地网络中进行地址解析，如果需要向其他网络的主机发送数据，就需要进行路由和转发操作，需要使用其他协议，例如IP和路由协议等。</p>
<h2 id="session和cookie的区别">session和cookie的区别</h2>
<ol>
<li>存储位置：Cookie是保存在客户端浏览器中的，而Session是保存在服务器端的。</li>
<li>安全性：Cookie的存储位置是在客户端，容易被窃取或篡改，从而引发安全问题，而Session的存储位置是在服务器端，相对安全。</li>
<li>存储容量：Cookie的存储容量有限，通常只能存储几KB的数据，而Session的存储容量相对较大，可以存储几MB的数据。</li>
<li>浏览器对于单个Cookie的大小有限制（4kb），且对同一个域名下的总Cookie数量也有限制（20个）,而Session没有数据大小限制</li>
<li>生命周期：Cookie可以设置过期时间，可以在客户端保存一段时间，即使关闭了浏览器也可以再次访问，而Session通常在客户端关闭浏览器后失效。</li>
<li>使用方式：Cookie可以被JavaScript读取和设置，可以在客户端进行处理，而Session只能在服务器端进行处理。</li>
<li>功能：Cookie通常用于记住用户的偏好设置和登录状态等信息，而Session通常用于在不同页面间共享数据和维护会话状态等。</li>
</ol>
<p>补充：分布式环境下的session：</p>
<ol>
<li>任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</li>
</ol>
<h2 id="如果客户端禁用Cookie，怎么保持Session同步">如果客户端禁用Cookie，怎么保持Session同步</h2>
<ol>
<li>在URL中传递Session ID：Web应用程序可以将Session ID作为URL的一部分来传递，例如 <a target="_blank" rel="noopener" href="https://example.com/page?sessionid=123456%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%8D%B3%E4%BD%BF%E7%A6%81%E7%94%A8%E4%BA%86Cookie%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87URL%E6%9D%A5%E4%BC%A0%E9%80%92Session">https://example.com/page?sessionid=123456，这样即使禁用了Cookie，也可以通过URL来传递Session</a> ID，从而实现Session同步。但这种方法会增加URL的复杂度和长度，容易被拦截、泄露和篡改</li>
<li>在表单隐藏字段中传递Session ID：Web应用程序可以在HTML表单的隐藏字段中传递Session ID，例如 &lt;input type=“hidden” name=“sessionid” value=“123456”&gt;，这样即使禁用了Cookie，也可以通过表单提交来传递Session ID，从而实现Session同步。但这种方法需要修改所有的表单，增加了代码维护成本。</li>
<li>使用IP地址和浏览器指纹识别：Web应用程序可以使用客户端IP地址和浏览器指纹等信息来识别客户端，从而实现Session同步。但这种方法存在误判和误识别的风险，同时也容易受到欺骗和攻击。</li>
<li>使用其他存储方式：Web应用程序可以使用其他存储方式来保存Session，例如使用数据库、文件系统、内存缓存等。这种方法可以实现Session同步，但也增加了服务器负担和存储成本，并且需要考虑并发访问和数据一致性等问题。</li>
</ol>
<h1>数据库</h1>
<h2 id="Mysql存储引擎有哪些">Mysql存储引擎有哪些</h2>
<h2 id="三大范式">三大范式</h2>
<ol>
<li>每个字段都不能再拆分</li>
<li>在第⼀范式的基础上，非主键字段列完全依赖于主键</li>
<li>在第⼆范式的基础上，非主键字段列依赖于主键且不依赖于其他⾮主键</li>
</ol>
<h2 id="索引的分类">索引的分类</h2>
<p><img src="https://s2.loli.net/2023/02/24/rHYlZaomMWi8cvx.png" alt="image-20230224215556320"></p>
<p><img src="https://s2.loli.net/2023/02/24/AChFDe829wUI1Mg.png" alt="image-20230224215636648"></p>
<p>聚簇索引(Clustered Indexes)保证关键字的值相近的元组存储的物理位置也相同，且一个表只能有一个聚簇索引。字符串类型不建议使用聚簇索引，特别是随机字符串，因为它们会使系统进行大量的移动操作。并不是所有的存储引擎都支持聚簇索引，目前InnoDB支持。如果使用聚簇索引，最好使用AUTO_INCREMENT列作为主键，应该尽量避免使用随机的聚簇主键</p>
<h2 id="索引如何生成的">索引如何生成的</h2>
<p><img src="https://s2.loli.net/2023/02/24/HW1Uj8hqDLQ4Ez7.png" alt="image-20230224215752844"></p>
<p><img src="https://s2.loli.net/2023/02/24/GpDQY54sUzkS1dP.png" alt="image-20230224215901738"></p>
<h2 id="索引的优点和缺点">索引的优点和缺点</h2>
<p>索引是帮助Mysql高效的从磁盘中检索数据的一种数据结构，在Mysql的InnoDB引擎里面采用的是B+树的结构来实现索引和数据的存储</p>
<p>优点：</p>
<ol>
<li>通过B+树的结构来存储数据，可以大大减少数据检索时磁盘的IO次数，从而提升数据查询的性能</li>
<li>B+树索引在进行范围查找的时候，只需要找到起始节点，然后基于叶子节点的链表结构往下读取即可，查询效率较高</li>
<li>通过唯一索引约束，可以保证数据表中每一行数据的唯一性</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据的增删改，需要涉及到索引的维护，当数据量较大的情况下，索引的维护会带来较大的性能开销</li>
<li>一个表中允许存在一个聚簇索引和多个非聚簇索引，但是索引数不能创建太多，否则造成的索引维护成本过高</li>
<li>创建索引的时候，需要考虑到索引字段值的分散性，如果字段的重复数据过多，创建索引反而会带来性能降低</li>
</ol>
<h2 id="创建索引需要注意的点">创建索引需要注意的点</h2>
<ol>
<li>选择选择性高的，即重复度低的列创建索引，比如性别不适合而身份证号适合</li>
<li>选择经常用于查询的列创建索引</li>
<li>多表关联查询时作为关联条件的列适合创建索引</li>
<li>值会频繁变化的列不适合建索引</li>
<li>⼀张表上不要建太多的索引，太多的话会严重影响数据增删改的性能。也会耗费很⼤的磁盘空间</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/24/DqhCnjtN5PAHGY2.png" alt="image-20230324230009913"></p>
<h2 id="联合索引">联合索引</h2>
<p>多个字段组合一起作为索引，它支持最左前缀原则即最左匹配原则，</p>
<h2 id="最左匹配原则">最左匹配原则</h2>
<p>如果想使用联合索引，联合索引的最左边的列必须作为过滤条件，否则联合索引不会生效，mysql会⼀直向右匹配直⾄遇到范围查询(&gt;、&lt;、between、like)就停⽌匹配</p>
<h2 id="覆盖索引">覆盖索引</h2>
<p>不是索引结构，可以理解为是一种优化手段</p>
<p>因为在使⽤辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据</p>
<p>从辅助索引中查询得到记录，⽽不需要通过聚族索引查询获得，MySQL 中将其称为覆盖索引</p>
<p>好处：<strong>不需要查询出包含整⾏记录的所有信息，因此可以减少大量的 I/O 操作</strong></p>
<p>距离：</p>
<p>​		假设我们只需要查询商品的名称、价格信息，我们有什么⽅式来避免回表呢？我们可以建⽴⼀个组合索引，即商品编码、名称、价格作为⼀个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从⽽避免回表</p>
<h2 id="索引在更新-插入后究竟何时更新">索引在更新/插入后究竟何时更新</h2>
<p>是在更新/插入查询返回之前，还是在查询返回之后的某个时间，还是在执行使用索引的查询时？</p>
<ol>
<li>第一部分是在索引中插入/更新/删除条目。一旦记录发生更改，索引就会立即更新，并且此过程会阻塞查询直到完成。</li>
</ol>
<h2 id="什么情况下建立索引，什么情况不建立索引">什么情况下建立索引，什么情况不建立索引</h2>
<h3 id="适合建索引的情况">适合建索引的情况</h3>
<ol>
<li>
<p>频繁作为where条件语句查询字段</p>
</li>
<li>
<p>关联字段需要建立索引</p>
</li>
<li>
<p>排序字段可以建立索引</p>
</li>
<li>
<p>分组字段可以建立索引(因为分组前提是排序)</p>
</li>
<li>
<p>统计字段可以建立索引（如.count(),max()）</p>
</li>
</ol>
<h3 id="不适合建索引的情况">不适合建索引的情况</h3>
<ol>
<li>
<p>频繁更新的字段不适合建立索引</p>
</li>
<li>
<p>where条件中用不到的字段不适合建立索引</p>
</li>
<li>
<p>可以确定表数据比较少不需要建立索引</p>
</li>
<li>
<p>数据重复且发布比较均匀的字段不适合建索引（如性别，真假值）</p>
</li>
<li>
<p>参与列计算的列不适合建索引</p>
</li>
</ol>
<h2 id="数据库的索引对应的什么文件">数据库的索引对应的什么文件</h2>
<p>.idb：表示数据文件</p>
<p>frm：表示表的定义文件，即表结构信息文件</p>
<h2 id="为什么MySQL数据库使用B-树不使用B树">为什么MySQL数据库使用B+树不使用B树</h2>
<p>当存储同数量级的数据的时候，B+树的⾼度⽐B树的⾼度⼩，这样的话进程IO操作的次数就少，效果就⾼。因为B+树的所有⾮叶⼦节点只存索引，数据存在叶⼦节点，⼀般3层的树⾼度，即可存千万级别的数据，⽽B数不⾏</p>
<p>B+树：</p>
<ol>
<li>
<p>非叶子结点不存储data，只存储索引，可以放更多的索引</p>
<p>data存：索引所在行的偏移地址或者行中所有列的数据</p>
</li>
<li>
<p>叶子节点包含所有索引字段</p>
</li>
<li>
<p>叶子节点用指针连接，提高区间的访问性能</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/08/uImSp7VvAFiZbBy.png" alt="image-20230308204237150"></p>
<p>InnoDB中：</p>
<ol>
<li>表必须建主键，并且推荐使用整型的自增主键</li>
<li>聚集索引-叶子节点包含了完整的数据记录</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/08/Z1YUDE4MreA6CvL.png" alt="image-20230308210906180"></p>
<h2 id="Mysql数据库挂掉怎么备份和恢复">Mysql数据库挂掉怎么备份和恢复</h2>
<h2 id="Mysql-索引很慢，怎么排查，怎么处理">Mysql 索引很慢，怎么排查，怎么处理</h2>
<p>虽然命中索引，但SQL效率仍然慢，可能有哪些原因？</p>
<ol>
<li>索引字段重复值或者空值太多。</li>
<li>查询条件范围太广返回结果数太多，全索引扫描。</li>
<li>没有利用到覆盖索引，造成大量回表。</li>
<li>查询字段过多，并且包含大字段。</li>
<li>索引字段数据分布太随机，回表不多也会引起大量随机io。</li>
<li>统计信息不准。</li>
<li>表的单行数据值很大，需要较多io。</li>
<li>表中包含多个索引， 命中的索引不是最优的索引。</li>
</ol>
<h2 id="索引失效的场景">索引失效的场景</h2>
<p><img src="https://s2.loli.net/2023/02/26/a1SBGAW3rfKmeiw.png" alt="image-20230226101837093"></p>
<p>可能导致失效的原因：</p>
<ol>
<li>对索引字段进行了运算或者使用了函数</li>
<li>查询中的数据类型和字段类型不一致（需要进行转换的时候）</li>
<li>违反了索引的最左匹配原则</li>
<li>全表扫描更快</li>
</ol>
<h2 id="一个字段为性别，是否适合建立索引">一个字段为性别，是否适合建立索引</h2>
<p>索引分聚集索引和非聚集索引，性别字段因为可重复肯定只能建立非聚集索引，然而因为非聚集索引叶子节点存储的是索引值和聚集索引值，需要回表。所以在性别这种辨别度较低的字段上建立索引，索引树可能只有两个节点，跟线性查找没有太大区别，并且因为回表的存在导致在聚集索引树和非聚集索引树来回切换反而导致查询时间更慢。并且维护该索引还要一定的开销。另外，数据库优化器最终很大概率也不会选择走这个索引。综上，在辨别度较低的字段上建立索引得不偿失</p>
<h2 id="数据库索引为什么用B-树不用哈希、红黑树">数据库索引为什么用B+树不用哈希、红黑树</h2>
<p>平衡二叉树（AVL）：所有左右子树高度差不能超过1，查找效率固定为O(logn)，插入时，最多只需要1次旋转，删除时，需要维护整条路径</p>
<p>红黑树：追求大致的平衡，确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍</p>
<p>B树查询时间复杂度在1到树高之间，B+树的查询复杂度则稳定为树高</p>
<hr>
<p>不用二叉树：顺序插入时，会形成一个链表，查询性能大大降低，大数据量情况下，层级较深，检索速度慢（解决，使用红黑树，因为是自平衡二叉树）</p>
<p>不用红黑树：大数据量情况下，层级较深，检索速度慢</p>
<p>不用B树（多路平衡查找树）：插入时中间元素会发生向上裂变，但是缺点是每个节点会存储数据，利用不够充分</p>
<p><img src="https://s2.loli.net/2023/02/24/achAUCkrNx3EuTK.png" alt="image-20230224214811313"></p>
<p>不用hash：</p>
<p><img src="https://s2.loli.net/2023/02/24/gSEuB2awq5P4bOk.png" alt="image-20230224215420443"></p>
<p>B+树：在裂变的同时叶子节点还存有值，即所有节点都会存在于叶子节点中，并且叶子节点还有单向链表，Mysql中进行了优化，增加了一个指向相邻叶子节点的链表指针，提高了区间访问性能</p>
<p>总结：</p>
<p><img src="https://s2.loli.net/2023/02/24/JWDU6OykbZQji1u.png" alt="image-20230224215524002"></p>
<h2 id="3层千万数据的计算">3层千万数据的计算</h2>
<p><img src="https://s2.loli.net/2023/02/24/nA1kdmhj2Pu3fsv.png" alt="image-20230224215839309"></p>
<h2 id="Mysql如何分库分表">Mysql如何分库分表</h2>
<p>shardingJDBC/Mycat</p>
<h2 id="Mysql的锁">Mysql的锁</h2>
<p>全局锁</p>
<p>表级锁：</p>
<ul>
<li>表锁
<ul>
<li>表共享读锁</li>
<li>表独占写锁</li>
</ul>
</li>
<li>元数据锁：MDL，加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性</strong></li>
<li>意向锁：为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，<strong>使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</strong>
<ul>
<li>意向共享锁（IS）：意向共享锁与表读锁是兼容的，由语句<strong>select … lock in share mode</strong>添加</li>
<li>意向排它锁（IX）：意向排他锁与表读锁、写锁都是互斥的，由<strong>insert、update、delete、select…for update</strong>添加</li>
</ul>
</li>
</ul>
<p>行锁：</p>
<ul>
<li>
<p>行锁：在RC，RR级别下支持</p>
<ul>
<li>
<p>S为共享锁</p>
<p>防止不可重复读，因为当事务对数据加上共享锁后，其他事务就只能对该数据进行读操作，不能进行修改操作，因此也就避免了不可重复读的问题（不可重复读：前后两次读取的结果不一样）</p>
</li>
<li>
<p>X为排他锁</p>
</li>
</ul>
</li>
<li>
<p>间隙锁：防止产生幻读的，在RR隔离级别下支持</p>
</li>
<li>
<p>临键锁：行锁和间隙锁组合，在RR级别下支持</p>
</li>
</ul>
<p>在RR隔离级别中，innodb使用<strong>next-key锁</strong>进行搜索和索引扫描，防止幻读，定位到索引区间后，降级为<strong>间隙锁</strong></p>
<h2 id="数据库的乐观锁和悲观锁">数据库的乐观锁和悲观锁</h2>
<p>**数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和一致性以及数据库的统一性。**乐观锁和悲观锁是并发控制主要采用的技术手段。</p>
<p>悲观锁：假定会发生并发冲突，会对操作的数据进行加锁，直到提交事务，才会释放锁，其他事务才能进行修改。实现方式：<strong>使用数据库中的锁机制。</strong></p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过。给表增加version字段，在修改提交之前检查version与原来取到的version值是否相等，若相等，表示数据没有被修改，可以更新，否则，数据为脏数据，不能更新。实现方式：乐观锁一般使用版本号机制或CAS算法实现。</p>
<h2 id="Mysql死锁如何解决">Mysql死锁如何解决</h2>
<p><strong>产生条件：</strong></p>
<ol>
<li>互斥条件：共享资源x,y只能被一个线程占有</li>
<li>请求和保持条件：线程t1已经获得了共享资源x，在等待共享资源y的时候不释放共享资源x</li>
<li>不可抢占条件：其余线程不能去抢占线程t1已经占有的资源</li>
<li>循环等待条件：线程t1等待线程t2释放资源，线程t2也等待线程t1释放资源</li>
</ol>
<p>**原因：**死锁的关键在于：两个(或以上)的Session加锁的顺序不一致</p>
<p><strong>解决关键：</strong>（让不同的session加锁有次序），上面的条件1为特征，无法破坏，其余三点都可以外部干预进行破坏</p>
<ul>
<li>解决条件2：第一次执行的时候一次性申请所有的共享资源</li>
<li>解决条件3：如果申请不到就主动释放它占有的资源</li>
<li>解决条件4：按照顺序申请锁资源，相当于给资源一个编号</li>
</ul>
<p>**如何找到：**可以调用jstack命令，导出线程的dump日志，然后定位到具体的死锁程序代码</p>
<p><strong>如何避免：</strong></p>
<ul>
<li>事务尽可能小，不要将复杂逻辑放进一个事务里。</li>
<li>涉及多行记录时，约定不同事务以相同顺序访问。</li>
<li>业务中要及时提交或者回滚事务，可减少死锁产生的概率。</li>
<li>表要有合适的索引。</li>
<li>可尝试将隔离级别改为 RC</li>
</ul>
<h2 id="如何优化锁">如何优化锁</h2>
<ol>
<li>
<p>尽量使用较低的隔离级别。</p>
</li>
<li>
<p>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</p>
</li>
<li>
<p>选择合理的事务大小，小事务发生锁冲突的几率也更小。</p>
</li>
<li>
<p>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</p>
</li>
<li>
<p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</p>
</li>
<li>
<p>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；</p>
</li>
</ol>
<h2 id="写sql需要注意的点，SQL调优">写sql需要注意的点，SQL调优</h2>
<ol>
<li>尽量不要用select * ，尽量覆盖索引，在二级索引下就能查到想要的</li>
<li>尽量减少子查询，使用关联查询（left join,right join,inner join）替代</li>
<li>小表查询大表时尽量用in不要用exists</li>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>
<li>用limit限制返回的条数，避免内存溢出</li>
<li>缩小数据集的条件要放前面</li>
<li>update的时候如果不走索引，会把行级锁升级为表级锁，这样会大大降低并发性</li>
</ol>
<hr>
<ol>
<li>主键顺序导入：插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能，一般都让主键id自增</li>
<li>一个SQL不会操作两张表，在程序中作为参数的传递，永远单表查询</li>
<li>批量插入代替循环插入，使用batch批处理：orderMapper.insertBatch(list)</li>
<li>当pageNo比较大的时候，查询效率变低，所以可以用上次查询的最大id或者order by的那个字段的最大值或者最小值来做一个条件的过滤</li>
</ol>
<h2 id="百万级别的数据优化">百万级别的数据优化</h2>
<ol>
<li>
<p>最左前缀原则</p>
</li>
<li>
<p>不要对索引做以下处理</p>
<p>计算：+、-、*、/、！=、is null、is not null、or</p>
<p>函数：sum()、round()</p>
<p>手动/自动类型转换：id = “1”</p>
</li>
<li>
<p>索引不要放在范围查询右边，范围之后索引都失效</p>
</li>
<li>
<p>减少select * 的使用</p>
</li>
<li>
<p>like模糊搜索</p>
</li>
<li>
<p>order by优化：少用文件内排序，尽可能通过覆盖索引使其使用索引排序</p>
</li>
</ol>
<h2 id="嵌套查询和嵌套结果的区别">嵌套查询和嵌套结果的区别</h2>
<h2 id="慢查询">慢查询</h2>
<p><img src="https://s2.loli.net/2023/02/26/Nkl2bneTUWYH9m6.png" alt="image-20230226101225801"></p>
<h2 id="Mysql-limit">Mysql limit</h2>
<p>limit x,y的含义是：扫描x条，然后往后扫描截取y条</p>
<h2 id="事务的四大特性">事务的四大特性</h2>
<ol>
<li>
<p>原子性(A)：undo log实现</p>
</li>
<li>
<p>一致性©</p>
<p>事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。</p>
</li>
<li>
<p><strong>隔离性(I)：加锁以及MVCC实现</strong></p>
<p>在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</p>
</li>
<li>
<p><strong>持久性(D)：redo log实现</strong></p>
</li>
</ol>
<h2 id="日志">日志</h2>
<p>Redo-Log保证已提交事务的持久性，undo是用于消除未提交事务的影响</p>
<p><img src="https://s2.loli.net/2023/03/01/cqUmuotCl2OP8MR.png" alt="image-20230301094518509"></p>
<p>binLog是逻辑日志，RedoLog是物理日志</p>
<h2 id="MVCC（RC与RR）">MVCC（RC与RR）</h2>
<p>多版本并发控制（MVCC=Multi-Version Concurrency Control），是一种用来解决读 - 写冲突的无锁并发控制。也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读</p>
<p><strong>重点为：版本链+undo回滚日志+对比规则</strong></p>
<p>read view中四变量：</p>
<ul>
<li>活跃事务（活跃事务就是没提交的事务）集合；</li>
<li>当前事务id</li>
<li>集合中的最小值；</li>
<li>集合中最大值的下个值</li>
</ul>
<p>当执行查询sql时会生成一致性视图read-view</p>
<p>RC隔离级别下每次执行快照读时生成readview，所以第一次没提交读不到，第二次提交了，生成了新的快照读就读到了，故会出现不可重复读的问题</p>
<p>RR可重复读级别下所有的select都会使用同一个read-view</p>
<p><strong>即只读自己事务前已经commit的事务，加上自己事务未提交的事务，别人同时做的未提交操作，和后面commit事务就不读了</strong></p>
<p>m_ids表示还没有提交的事务的列表</p>
<p><img src="https://s2.loli.net/2023/03/14/notulHYyIpLFca2.png" alt="image-20230314100408986"></p>
<p><img src="https://s2.loli.net/2023/03/06/byeINEqtK6JxkLa.png" alt="image-20230306155955830"></p>
<p><img src="https://s2.loli.net/2023/03/14/gvHiQx1m5ujNOES.png" alt="image-20230314100438155"></p>
<p><strong>其他任何情况都要一直沿着版本链查询undo日志，直到符合这三个条件为止</strong></p>
<p>数组中是未提交事务，外面的是当前最大的事务id（包含已提交的）</p>
<p>快照读是MVCC负责的，当前读是通过锁</p>
<p>幻读通过加间隙锁解决幻读</p>
<p>注：</p>
<ol>
<li>
<p><strong>当前读就是显式加锁的 SQL 语句（lock in share mode 或 for update）</strong><br>
例如：select * from T where id=10 for update;<br>
此外 insert update 和 delete 这些隐式加锁的语句也是使用当前读。</p>
</li>
<li>
<p><strong>没有显示加锁的查询语句就是快照读了。</strong></p>
<p>例如：select * from T where id=10;</p>
</li>
</ol>
<h2 id="left-join-和-right-join-的区别">left join 和 right join 的区别</h2>
<h2 id="内连接和外连接的区别">内连接和外连接的区别</h2>
<p>内连接：只查询公共部分</p>
<p>外连接：不光公共部分，还有左或右的独立部分</p>
<h2 id="in-、where-和-exist-怎么用">in 、where 和 exist 怎么用</h2>
<p>原则：<strong>小表驱动大表的原则</strong></p>
<ol>
<li>
<p><strong>in</strong></p>
<p>如：select * from A where id in (select id from B)</p>
<p>in()中的查询只执行一次，<strong>它查询出B中的所有的id并缓存起来，然后检查A表中查询出的id在缓存中是否存在</strong>，如果存在则将A的查询数据加入到结果集中，直到遍历完A表中所有的结果集为止。当B表的数据较大时不适合使用in()查询，因为它会将B表中的数据全部遍历一次</p>
<p><strong>结论：IN()查询适合B表数据比A表数据小的情况，IN()查询是从缓存中取数据</strong></p>
</li>
<li>
<p><strong>exist</strong></p>
<p>如：select * from A where exists(select id from b <a target="_blank" rel="noopener" href="http://whereB.id">whereB.id</a> = <a target="_blank" rel="noopener" href="http://A.id">A.id</a>)</p>
<p>EXISTS()查询是将主查询的结果集,即<strong>外表查询的结果,放到子查询中做验证</strong>，根据验证结果是true或false来决定主查询数据结果是否得以保存</p>
<p>结论：<strong>当B表的数据比A表的数据大时适合使用EXISTS()查询，因为它不用遍历B操作，只执行一次查询就OK了</strong></p>
</li>
</ol>
<h2 id="buffer-pool的原理">buffer pool的原理</h2>
<p>Buffer pool是MySQL中的一个缓存区，用于存储磁盘上的表和索引数据。当MySQL需要读取磁盘上的数据时，它会首先查找buffer pool中是否已经有了这些数据，如果有，直接从buffer pool中读取，如果没有，则从磁盘中读取，并将数据存储到buffer pool中，以便后续访问。<strong>它可以显著提高MySQL的查询性能和吞吐量。</strong></p>
<p>参数：innodb_buffer_pool_size</p>
<h1>操作系统</h1>
<h2 id="Linux查看端口占用情况">Linux查看端口占用情况</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 8080或者netstat -tln | grep 8080</span><br></pre></td></tr></table></figure>
<h2 id="linux系统命令，看系统上有哪些网络连接，数量和状态">linux系统命令，看系统上有哪些网络连接，数量和状态</h2>
<h1>高并发和高可用</h1>
<h2 id="服务器问题">服务器问题</h2>
<ol>
<li>负载均衡 在服务器端可以设置负载均衡，将客户端的请求分配到不同的服务器上，避免单一服务器负荷过大，导致登录响应时间变慢或者登录失败。可以使用一些负载均衡工具，例如Nginx、HAProxy等。</li>
<li>分布式架构 采用分布式架构，将用户数据、登录服务器等服务分布到不同的物理节点上，减轻单节点的负荷，提高系统的稳定性和可用性。</li>
<li>缓存 将常用的id缓存到内存中，避免频繁访问数据库，减少服务器的负担，提高id申请的可用性。</li>
<li>异步处理 对于客户端登录请求，可以采用异步处理方式，避免请求阻塞导致系统负载过大。可以使用一些异步处理工具，例如Celery等。</li>
<li>引入限流机制 为了避免大量的客户端同时登录，可以采用限流机制，对客户端的请求进行限制，例如限制每秒最多只能接收多少个请求。</li>
</ol>
<h1>场景题</h1>
<h2 id="怎样防止前端重复提交">怎样防止前端重复提交</h2>
<ol>
<li>
<p>客户端标识</p>
<p>客户端可以设置一个表示，表明这个请求已经提交了，并且在接下来的请求中判断该表示，如果为真 ，则不再处理这个请求</p>
</li>
<li>
<p>客户端存储</p>
<p>客户端也可以使用localStorage等客户端存储方式来记录表单是否已经提交，如果已经提交，则不再处理该请求。</p>
</li>
<li>
<p>禁用提交按钮</p>
<p>在表单提交后，禁用提交按钮，避免用户多次点击。</p>
</li>
<li>
<p>使用定时器设置一段时间内禁用提交按钮</p>
</li>
<li>
<p><strong>服务端利用token机制</strong></p>
<p>在表单渲染时，生成一个唯一的 Token 并隐藏在表单中；在表单提交时，服务器端验证 Token 的有效性，如果无效或已使用，则视为重复提交</p>
</li>
<li>
<p><strong>session</strong></p>
<p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p>
<p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p>
</li>
<li>
<p>提交完成后页面重定向</p>
</li>
<li>
<p><strong>使用AOP自定义切入实现</strong></p>
<p>实现原理：</p>
<ol>
<li>自定义防止重复提交标记（@AvoidRepeatableCommit）。</li>
<li>对需要防止重复提交的Congtroller里的mapping方法加上该注解。</li>
<li>新增Aspect切入点，为@AvoidRepeatableCommit加入切入点。</li>
<li>每次提交表单时，Aspect都会保存当前key到reids（须设置过期时间）。</li>
<li>重复提交时Aspect会判断当前redis是否有该key，若有则拦截。</li>
</ol>
</li>
</ol>
<h2 id="单点登录">单点登录</h2>
<p>指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的系统。简而言之，多个系统，统一登陆。</p>
<p><strong>原理：</strong></p>
<p>sso需要一个独立的认证中心，所有子系统都通过认证中心的登录入口进行登录，登录时带上自己的地址，子系统只接受认证中心的授权，授权通过令牌（token）实现，sso认证中心验证用户的用户名密码正确，创建全局会话和token，token作为参数发送给各个子系统，子系统拿到token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p>
<p><strong>实现方式：</strong></p>
<p>Cookies，Session同步，分布式Session</p>
<h1>面经</h1>
<h2 id="IO密集型任务把IO和业务逻辑分离有什么好处">IO密集型任务把IO和业务逻辑分离有什么好处</h2>
<ol>
<li>提高应用程序的响应速度：将IO和业务逻辑分离可以让应用程序更加高效地利用计算资源，以便更快地响应请求。当IO和业务逻辑被分离开来，可以使用异步编程技术来使应用程序更好地利用CPU和其他资源。这有助于提高应用程序的吞吐量和响应速度。</li>
<li>更好的可维护性：将IO和业务逻辑分离可以使代码更加模块化，易于维护和扩展。将IO操作和业务逻辑分开意味着可以在需要时更容易更改或替换IO操作，而不影响业务逻辑。这有助于确保代码的可重用性和可维护性。</li>
<li>更好的测试性：将IO和业务逻辑分离可以使单元测试更加容易。通过将IO操作模拟为模拟实现，可以在没有访问实际IO设备的情况下对业务逻辑进行测试。这有助于确保代码的正确性和可靠性。</li>
<li>更好的可伸缩性：将IO和业务逻辑分离可以使应用程序更容易扩展。当IO和业务逻辑分离时，可以更容易地将业务逻辑分布到多个服务器上，而不会影响IO性能。这有助于确保应用程序在面对不断增长的流量和负载时能够保持稳定性和可靠性。</li>
</ol>
<h1>笔试记录</h1>
<h2 id="阿里">阿里</h2>
<h3 id="满二叉子树的数量">满二叉子树的数量</h3>
<p>给定一颗二叉树，试求这课二叉树有多少个节点满足以该节点为根的子树是满二叉树？满二叉树指每一层都达到节点最大值。</p>
<p>第一行输入n表示节点数量，接下来n行第一个代表左儿子，第二个代表右儿子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            nums[i][<span class="number">0</span>] = in.nextInt();</span><br><span class="line">            nums[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Main().isFullTree(nums, <span class="number">1</span>)；</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(nums, nums[root - <span class="number">1</span>][<span class="number">0</span>]), height(nums, nums[root - <span class="number">1</span>][<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFullTree</span><span class="params">(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFullTree(nums, nums[root - <span class="number">1</span>][<span class="number">0</span>]) &amp;&amp; isFullTree(nums, nums[root - <span class="number">1</span>][<span class="number">1</span>]) &amp;&amp; height(nums, nums[root - <span class="number">1</span>][<span class="number">0</span>]) == height(nums, nums[root - <span class="number">1</span>][<span class="number">1</span>])) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述解法时间复杂度O(n)，空间复杂度o(log(n))</p>
<p>法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span> <span class="params">(TreeNode left, TreeNode right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    nodeList.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        nodeList.add(<span class="keyword">new</span> TreeNode(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i][<span class="number">0</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).left = nodeList.get(nums[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i][<span class="number">1</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).right = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeList.get(i + <span class="number">1</span>).right = nodeList.get(nums[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三元组计数">三元组计数</h3>
<p>给定一个数组，计算有多少个三元组0&lt;=i&lt;j&lt;k&lt;n，且max(nums[i], nums[j], nums[k]) - min(nums[i], nums[j], nums[k]) = 1。</p>
<p>第一行输入n表示数组个数，第二行输入n个整数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = map.get(nums[i]);</span><br><span class="line">            <span class="keyword">int</span> high = map.get(nums[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (low == <span class="number">1</span> &amp;&amp; high == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (high &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += low * high * (high - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += high * low * (low - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乘2除2">乘2除2</h3>
<p>在n个元素的数组中选择k个元素，每个元素要么乘以2，要么除以2并向下取整，使得操作完后数组的极差尽可能小，并且输出极差。极差为最大值减去最小值。</p>
<p>第一行输入整数n和k。第二行输入n个整数表示数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queueMin = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queueMid = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queueMax = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">    <span class="keyword">int</span> minMin = Integer.MAX_VALUE, midMin = Integer.MAX_VALUE, maxMin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k ; i ++) &#123;</span><br><span class="line">        minMin = Math.min(minMin, <span class="number">2</span> * nums[i]);</span><br><span class="line">        queueMin.add(<span class="number">2</span> * nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i ++) &#123;</span><br><span class="line">        midMin = Math.min(midMin, nums[i]);</span><br><span class="line">        queueMid.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        res = Math.min(res, queueMid.peek() - midMin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = Math.min(res, Math.max(queueMin.peek(), queueMid.peek()) - Math.min(minMin, midMin));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempMin = queueMin.poll();</span><br><span class="line">        queueMid.add(tempMin / <span class="number">2</span>);</span><br><span class="line">        midMin = Math.min(midMin, tempMin / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> tempMid = queueMid.poll();</span><br><span class="line">        queueMax.add(tempMid / <span class="number">2</span>);</span><br><span class="line">        maxMin = Math.min(maxMin, tempMid / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == k - <span class="number">1</span>) &#123;</span><br><span class="line">            res = Math.min(res, Math.max(queueMid.peek(), queueMax.peek()) - Math.min(Math.min(minMin, midMin), maxMin));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = Math.min(res, Math.max(Math.max(queueMin.peek(), queueMid.peek()), queueMax.peek()) - Math.min(Math.min(minMin, midMin), maxMin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述解法时间复杂度O(nlog(n))，空间复杂度O(n)</p>
<h2 id="蚂蚁">蚂蚁</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextLine().charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        String[] str = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            str[i] = input.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        System.out.print(digui(str, alpha, n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">digui</span><span class="params">(String[] str, <span class="keyword">int</span> layer, <span class="keyword">int</span>[] alpha, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (layer == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] alpha_tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        String s = str[layer];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> ((alpha_tmp[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &amp;&amp; alpha[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                alpha[c - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                ans += digui(str, layer + <span class="number">1</span>, alpha, n);</span><br><span class="line">                alpha[c- <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            alpha_tmp[c - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">杨译茗</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">https://boomboom-yang.github.io/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://boomboom-yang.github.io" target="_blank">YYM‘s Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/">面试题目整理</a></div><div class="post_share"><div class="social-share" data-image="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/05/22/RjklgVawrtOcuPf.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/05/22/RjklgVawrtOcuPf.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.loli.net/2021/05/22/qKAvWJgRe3IQVp5.jpg" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/05/22/qKAvWJgRe3IQVp5.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/12/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://images.unsplash.com/photo-1655438819488-69bfb10a6c21?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL基础学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"><img class="next-cover" src="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4375.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAV力扣刷题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/05/22/2KPMBkSoU3ahebr.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">杨译茗</div><div class="author-info__description">心栖梦归处，不负韶华年</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/boomboom-yang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/boomboom-yang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2476165779@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">致敬那些奋斗的岁月！永无止境！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">jdk1.8新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">8大基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">1.4.</span> <span class="toc-text">装箱与拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E7%BC%93%E5%AD%98%E6%98%AF%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">Integer缓存是放在哪里的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text">String的不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">好处：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">创建对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.8.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.8.2.</span> <span class="toc-text">获取class对象的方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%EF%BC%9A"><span class="toc-number">1.8.3.</span> <span class="toc-text">反射获取：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.8.4.</span> <span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.9.</span> <span class="toc-text">JAVA反射机制的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%92%8Cnew%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">反射和new对象的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">1.11.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.12.</span> <span class="toc-text">浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode"><span class="toc-number">1.13.</span> <span class="toc-text">两个不相等的对象有相同的hashcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals() 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95"><span class="toc-number">1.15.</span> <span class="toc-text">为什么重写 equals() 时必须重写 hashCode() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E4%B8%8ELinkedList%E7%9A%84%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">ArrayList与LinkedList的两者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.17.</span> <span class="toc-text">ArrayList初始容量以及扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.19.</span> <span class="toc-text">HashMap会出现的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.21.</span> <span class="toc-text">HashTable的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.22.</span> <span class="toc-text">HashSet的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashcode-%E6%96%B9%E6%B3%95"><span class="toc-number">1.23.</span> <span class="toc-text">为什么重写equals()就一定要重写hashcode()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Hashmap%E6%98%AF%E6%89%A9%E5%B1%95%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B6%E4%BB%96"><span class="toc-number">1.24.</span> <span class="toc-text">为什么Hashmap是扩展为红黑树而不是其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.25.</span> <span class="toc-text">红黑树和B+树的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%8F%AF%E4%BB%A5%E9%94%AE%E5%80%BC%E5%AF%B9%E5%90%8C%E6%97%B6%E4%B8%BAnull%E5%90%97"><span class="toc-number">1.26.</span> <span class="toc-text">HashMap可以键值对同时为null吗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">讲讲对Spring的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-number">2.1.1.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">2.1.2.</span> <span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9spring-IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">讲讲对spring IOC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9Spring-AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">讲讲对Spring AOP的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E5%AF%B9Spring-DI%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.4.</span> <span class="toc-text">讲讲对Spring DI的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E5%AF%B9Spring-MVC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.</span> <span class="toc-text">说下对Spring MVC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">AOP的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.7.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%B8%AD-ApplicationContext-%E5%92%8C-BeanFactory-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">Spring 中 ApplicationContext 和 BeanFactory 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.9.</span> <span class="toc-text">懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8BBean%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.10.</span> <span class="toc-text">单例Bean的创建步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.11.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.12.</span> <span class="toc-text">循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">2.12.1.</span> <span class="toc-text">三级缓存解决不了的场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABean%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.13.</span> <span class="toc-text">创建Bean实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.14.</span> <span class="toc-text">Spring中实现数据库事务的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.15.</span> <span class="toc-text">@Transactional具体实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E9%A9%ACSpring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.16.</span> <span class="toc-text">黑马Spring事务实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">2.17.</span> <span class="toc-text">spring事务的失效场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB"><span class="toc-number">2.18.</span> <span class="toc-text">事务的传播级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">2.19.</span> <span class="toc-text">自动装配原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.20.</span> <span class="toc-text">“#{}”和“${}”的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.21.</span> <span class="toc-text">BeanFactory和FactoryBean的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DI%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.22.</span> <span class="toc-text">DI的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Setter%E6%B3%A8%E5%85%A5"><span class="toc-number">2.22.1.</span> <span class="toc-text">Setter注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.22.1.1.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B1%9E%E6%80%A7"><span class="toc-number">2.22.1.2.</span> <span class="toc-text">简单属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">2.22.2.</span> <span class="toc-text">构造器注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">2.22.2.1.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B1%9E%E6%80%A7-2"><span class="toc-number">2.22.2.2.</span> <span class="toc-text">简单属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">2.22.3.</span> <span class="toc-text">自动配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">2.23.</span> <span class="toc-text">纯注解开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.24.</span> <span class="toc-text">Spring中Bean的作用域有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.25.</span> <span class="toc-text">将一个类声明为 Bean 的注解有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component%E5%92%8C-Bean%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.26.</span> <span class="toc-text">@Component和@Bean注解的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boot%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.27.</span> <span class="toc-text">Boot注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBootConfiguration-%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.27.1.</span> <span class="toc-text">@SpringBootConfiguration 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ComponentScan-%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.27.2.</span> <span class="toc-text">@ComponentScan 注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IOC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.28.</span> <span class="toc-text">Spring IOC的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.28.1.</span> <span class="toc-text">注入 Bean 的注解有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.29.</span> <span class="toc-text">@Autowired和@Resource的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E5%92%8CJDBC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.30.</span> <span class="toc-text">Mybatis和JDBC的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.31.</span> <span class="toc-text">JDBC操作数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%A6%81%E5%81%9A%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">2.32.</span> <span class="toc-text">MyBatis新建一个查询要做那些事情？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%92%8CSpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.33.</span> <span class="toc-text">Spring和SpringBoot的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.34.</span> <span class="toc-text">工厂模式举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log4j%E7%9A%844%E4%B8%AA%E7%BA%A7%E5%88%AB"><span class="toc-number">2.35.</span> <span class="toc-text">Log4j的4个级别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">为什么要在虚拟机中运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">同步和异步的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">并发和并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.4.</span> <span class="toc-text">JAVA运行时数据区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">什么时候会出现OOM问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JVM%E6%8A%8A%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%8D%A2%E6%88%90%E4%BA%86%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">3.6.</span> <span class="toc-text">为什么JVM把永久代换成了元空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%94%BE%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A0%86%E6%94%BE%E4%BB%80%E4%B9%88%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%94%BE%E5%93%AA%EF%BC%8C%E6%A0%88%E6%94%BE%E4%BB%80%E4%B9%88"><span class="toc-number">3.7.</span> <span class="toc-text">方法区放的什么，堆放什么，静态变量放哪，栈放什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.8.</span> <span class="toc-text">常量池&amp;运行时常量池&amp;字符串常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.8.1.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jvm%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%93%E7%8E%B0%EF%BC%9A"><span class="toc-number">3.8.2.</span> <span class="toc-text">Jvm中多态的体现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.8.3.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">3.9.</span> <span class="toc-text">JVM中类加载的机制是什么样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E5%AF%BC%E8%87%B4"><span class="toc-number">3.10.</span> <span class="toc-text">JVM内存溢出有哪些场景会导致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.11.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.12.</span> <span class="toc-text">类的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">3.13.</span> <span class="toc-text">对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.13.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-number">3.13.2.</span> <span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">3.14.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.15.</span> <span class="toc-text">多线程的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-2"><span class="toc-number">3.16.</span> <span class="toc-text">对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="toc-number">3.16.1.</span> <span class="toc-text">Step1:类加载检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">3.16.2.</span> <span class="toc-text">Step2:分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="toc-number">3.16.3.</span> <span class="toc-text">Step3:初始化零值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">3.16.4.</span> <span class="toc-text">Step4:设置对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step5-%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95"><span class="toc-number">3.16.5.</span> <span class="toc-text">Step5:执行 init 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%9C%BA%E6%99%AF"><span class="toc-number">3.17.</span> <span class="toc-text">内存泄露场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">3.18.</span> <span class="toc-text">进程和线程区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.19.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.20.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.21.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%9A%E5%8C%85%E5%90%AB%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.22.</span> <span class="toc-text">进程最多包含多少个线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.23.</span> <span class="toc-text">线程的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.24.</span> <span class="toc-text">进程的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.25.</span> <span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.26.</span> <span class="toc-text">线程代码举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.27.</span> <span class="toc-text">使线程阻塞的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.28.</span> <span class="toc-text">创建线程的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.29.</span> <span class="toc-text">如何中断一个正在运行中的线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.30.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">3.31.</span> <span class="toc-text">线程池有哪些参数，分别的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.32.</span> <span class="toc-text">创建线程池的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.33.</span> <span class="toc-text">阻塞队列有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.34.</span> <span class="toc-text">ArrayBlockingQueue的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">3.35.</span> <span class="toc-text">介绍强引用、软引用、弱引用、虚引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.36.</span> <span class="toc-text">虚引用的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="toc-number">3.37.</span> <span class="toc-text">如何判断一个常量是废弃常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">3.38.</span> <span class="toc-text">如何判断一个类是无用的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-number">3.39.</span> <span class="toc-text">HotSpot 为什么要分为新生代和老年代？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1%EF%BC%88%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">3.40.</span> <span class="toc-text">如何判断对象是否死亡（两种方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.40.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.40.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">3.41.</span> <span class="toc-text">垃圾收集有哪些算法，各自的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.42.</span> <span class="toc-text">常见的垃圾回收器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.43.</span> <span class="toc-text">HotSpot默认的垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.44.</span> <span class="toc-text">CMS垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-Garbage-First"><span class="toc-number">3.45.</span> <span class="toc-text">G1垃圾回收器(Garbage-First)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98"><span class="toc-number">3.46.</span> <span class="toc-text">GC如何调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-GC-%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF"><span class="toc-number">3.46.1.</span> <span class="toc-text">常见的 GC 调优思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">3.47.</span> <span class="toc-text">JVM调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">4.1.</span> <span class="toc-text">ThreadLocal是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">4.2.</span> <span class="toc-text">ThreadLocal带来的问题及解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%92%8C-Reentrantlock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">synchronized 和 Reentrantlock的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E7%82%B9%EF%BC%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">相似点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">4.4.</span> <span class="toc-text">volatile关键字是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB-2"><span class="toc-number">4.5.</span> <span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">4.6.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">4.6.1.</span> <span class="toc-text">CAS可能的问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.7.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.7.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E5%92%8CSynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.</span> <span class="toc-text">ReentrantLock和Synchronized关键字的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">4.8.1.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">4.8.2.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">4.8.3.</span> <span class="toc-text">区别与联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountdownLatch%E5%92%8CSemaphore%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.</span> <span class="toc-text">CountdownLatch和Semaphore的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">常用状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">5.2.</span> <span class="toc-text">常见的请求头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-2-3%E7%BC%BA%E9%99%B7"><span class="toc-number">5.3.</span> <span class="toc-text">HTTP1&#x2F;2&#x2F;3缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%BA%E9%99%B7"><span class="toc-number">5.3.1.</span> <span class="toc-text">HTTP缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1%E7%BC%BA%E9%99%B7"><span class="toc-number">5.3.2.</span> <span class="toc-text">HTTP1.1缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2%E7%BC%BA%E9%99%B7"><span class="toc-number">5.3.3.</span> <span class="toc-text">HTTP&#x2F;2缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">5.4.</span> <span class="toc-text">HTTP的队头阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BB%86%E6%89%A3%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">HTTP与HTTPS的区别（细扣）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.6.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">https加密过程（详细）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">5.8.</span> <span class="toc-text">ping的发送和接收过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CTCP%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E4%BD%86%E6%98%AFping%E5%8F%AF%E4%BB%A5ping%E9%80%9A%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98"><span class="toc-number">5.9.</span> <span class="toc-text">如果TCP连接不成功，但是ping可以ping通，如何排查网络问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">5.10.</span> <span class="toc-text">浏览器输入一个url的处理过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">5.11.</span> <span class="toc-text">三次握手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">5.12.</span> <span class="toc-text">四次挥手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97"><span class="toc-number">5.13.</span> <span class="toc-text">TCP 三次握手，两次、四次不行吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIME-WAIT-%E7%8A%B6%E6%80%81%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">5.14.</span> <span class="toc-text">TIME_WAIT 状态是做什么用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2MSL"><span class="toc-number">5.15.</span> <span class="toc-text">为什么是2MSL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E4%B8%8BTCP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%8C%E4%BB%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%A7%92%E5%BA%A6%E8%81%8A%E8%81%8A"><span class="toc-number">5.16.</span> <span class="toc-text">网络拥塞状态下TCP数据传输，从流量控制角度聊聊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84"><span class="toc-number">5.17.</span> <span class="toc-text">TCP是如何保证高可靠的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping-%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.18.</span> <span class="toc-text">ping 基于什么协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.19.</span> <span class="toc-text">网络层和传输层有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">5.20.</span> <span class="toc-text">ARP协议？工作机制介绍一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.21.</span> <span class="toc-text">session和cookie的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%81%E7%94%A8Cookie%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81Session%E5%90%8C%E6%AD%A5"><span class="toc-number">5.22.</span> <span class="toc-text">如果客户端禁用Cookie，怎么保持Session同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.1.</span> <span class="toc-text">Mysql存储引擎有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84"><span class="toc-number">6.4.</span> <span class="toc-text">索引如何生成的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">6.5.</span> <span class="toc-text">索引的优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">6.6.</span> <span class="toc-text">创建索引需要注意的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">6.7.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">6.8.</span> <span class="toc-text">最左匹配原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">6.9.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%9C%A8%E6%9B%B4%E6%96%B0-%E6%8F%92%E5%85%A5%E5%90%8E%E7%A9%B6%E7%AB%9F%E4%BD%95%E6%97%B6%E6%9B%B4%E6%96%B0"><span class="toc-number">6.10.</span> <span class="toc-text">索引在更新&#x2F;插入后究竟何时更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8D%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">6.11.</span> <span class="toc-text">什么情况下建立索引，什么情况不建立索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.11.1.</span> <span class="toc-text">适合建索引的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.11.2.</span> <span class="toc-text">不适合建索引的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6"><span class="toc-number">6.12.</span> <span class="toc-text">数据库的索引对应的什么文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%B8%8D%E4%BD%BF%E7%94%A8B%E6%A0%91"><span class="toc-number">6.13.</span> <span class="toc-text">为什么MySQL数据库使用B+树不使用B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%82%E6%8E%89%E6%80%8E%E4%B9%88%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">6.14.</span> <span class="toc-text">Mysql数据库挂掉怎么备份和恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql-%E7%B4%A2%E5%BC%95%E5%BE%88%E6%85%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">6.15.</span> <span class="toc-text">Mysql 索引很慢，怎么排查，怎么处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.16.</span> <span class="toc-text">索引失效的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%B8%BA%E6%80%A7%E5%88%AB%EF%BC%8C%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">6.17.</span> <span class="toc-text">一个字段为性别，是否适合建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E4%B8%8D%E7%94%A8%E5%93%88%E5%B8%8C%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">6.18.</span> <span class="toc-text">数据库索引为什么用B+树不用哈希、红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%B1%82%E5%8D%83%E4%B8%87%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">6.19.</span> <span class="toc-text">3层千万数据的计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E5%A6%82%E4%BD%95%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">6.20.</span> <span class="toc-text">Mysql如何分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E7%9A%84%E9%94%81"><span class="toc-number">6.21.</span> <span class="toc-text">Mysql的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">6.22.</span> <span class="toc-text">数据库的乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">6.23.</span> <span class="toc-text">Mysql死锁如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%94%81"><span class="toc-number">6.24.</span> <span class="toc-text">如何优化锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99sql%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%8CSQL%E8%B0%83%E4%BC%98"><span class="toc-number">6.25.</span> <span class="toc-text">写sql需要注意的点，SQL调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96"><span class="toc-number">6.26.</span> <span class="toc-text">百万级别的数据优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%9C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.27.</span> <span class="toc-text">嵌套查询和嵌套结果的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.28.</span> <span class="toc-text">慢查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql-limit"><span class="toc-number">6.29.</span> <span class="toc-text">Mysql limit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">6.30.</span> <span class="toc-text">事务的四大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">6.31.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%EF%BC%88RC%E4%B8%8ERR%EF%BC%89"><span class="toc-number">6.32.</span> <span class="toc-text">MVCC（RC与RR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#left-join-%E5%92%8C-right-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.33.</span> <span class="toc-text">left join 和 right join 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.34.</span> <span class="toc-text">内连接和外连接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in-%E3%80%81where-%E5%92%8C-exist-%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">6.35.</span> <span class="toc-text">in 、where 和 exist 怎么用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer-pool%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.36.</span> <span class="toc-text">buffer pool的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">7.1.</span> <span class="toc-text">Linux查看端口占用情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%EF%BC%8C%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%95%B0%E9%87%8F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">7.2.</span> <span class="toc-text">linux系统命令，看系统上有哪些网络连接，数量和状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">高并发和高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text">服务器问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E9%98%B2%E6%AD%A2%E5%89%8D%E7%AB%AF%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4"><span class="toc-number">9.1.</span> <span class="toc-text">怎样防止前端重复提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">9.2.</span> <span class="toc-text">单点登录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E6%8A%8AIO%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">10.1.</span> <span class="toc-text">IO密集型任务把IO和业务逻辑分离有什么好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">笔试记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E9%87%8C"><span class="toc-number">11.1.</span> <span class="toc-text">阿里</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">11.1.1.</span> <span class="toc-text">满二叉子树的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E8%AE%A1%E6%95%B0"><span class="toc-number">11.1.2.</span> <span class="toc-text">三元组计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%982%E9%99%A42"><span class="toc-number">11.1.3.</span> <span class="toc-text">乘2除2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9A%82%E8%9A%81"><span class="toc-number">11.2.</span> <span class="toc-text">蚂蚁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="JAV力扣刷题"><img src="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4375.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAV力扣刷题"/></a><div class="content"><a class="title" href="/2023/03/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" title="JAV力扣刷题">JAV力扣刷题</a><time datetime="2023-03-14T15:08:53.000Z" title="发表于 2023-03-14 23:08:53">2023-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="面试问题整理"><img src="https://www.splitshire.com/wp-content/uploads/2021/10/SplitShire-21-4354.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试问题整理"/></a><div class="content"><a class="title" href="/2023/03/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="面试问题整理">面试问题整理</a><time datetime="2023-03-07T10:17:37.000Z" title="发表于 2023-03-07 18:17:37">2023-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL基础学习笔记"><img src="https://images.unsplash.com/photo-1655438819488-69bfb10a6c21?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL基础学习笔记"/></a><div class="content"><a class="title" href="/2023/02/12/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL基础学习笔记">MySQL基础学习笔记</a><time datetime="2023-02-12T08:45:54.000Z" title="发表于 2023-02-12 16:45:54">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/" title="瑞吉外卖项目"><img src="https://cdn.stocksnap.io/img-thumbs/960w/coastal-sunset_GYJOTKPBW3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="瑞吉外卖项目"/></a><div class="content"><a class="title" href="/2023/02/12/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/" title="瑞吉外卖项目">瑞吉外卖项目</a><time datetime="2023-02-12T08:45:32.000Z" title="发表于 2023-02-12 16:45:32">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/05/SSM%E5%AD%A6%E4%B9%A0/" title="SSM学习"><img src="https://cdn.stocksnap.io/img-thumbs/960w/nature-landscape_S1W7ELWFFR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM学习"/></a><div class="content"><a class="title" href="/2023/02/05/SSM%E5%AD%A6%E4%B9%A0/" title="SSM学习">SSM学习</a><time datetime="2023-02-05T03:55:19.000Z" title="发表于 2023-02-05 11:55:19">2023-02-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 杨译茗</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,欢迎来到我的世界！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'twikoo-4g298nsce5004c8a',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'twikoo-4g298nsce5004c8a',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="6748041442" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>